<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linux基础</title>
      <link href="/2023/10/17/ctf-xue-xi/yi-ji-chu-zhi-shi/linux-ji-chu/"/>
      <url>/2023/10/17/ctf-xue-xi/yi-ji-chu-zhi-shi/linux-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-Linux目录结构"><a href="#1-1-Linux目录结构" class="headerlink" title="1.1 Linux目录结构"></a>1.1 Linux目录结构</h2><h3 id="1-1-1-Linux-系统目录结构"><a href="#1-1-1-Linux-系统目录结构" class="headerlink" title="1.1.1 Linux 系统目录结构"></a>1.1.1 Linux 系统目录结构</h3><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/Linux%E7%AE%80%E6%98%93%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.jpg" alt="img"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">├── <span class="token punctuation">\</span>:├── bin <span class="token comment"># 用于存放二进制命令</span>-<span class="token operator">&gt;</span> usr/bin     ├── boot <span class="token comment"># 内核及引导系统程序所在的目录，包括一些连接文件和镜像文件</span>    ├── dev <span class="token comment"># 所有设备文件的目录（如磁盘、光驱等）</span>    ├── etc <span class="token comment"># 配置文件默认路径、服务启动命令存放目录</span>    ├── home <span class="token comment"># 用户主目录，root用户为/root</span>    ├── lib <span class="token comment"># 32位库文件存放目录，存放着系统最基本的动态连接共享库</span>    -<span class="token operator">&gt;</span> usr/lib     ├── lib64 <span class="token comment"># 64位库文件存放目录</span>    -<span class="token operator">&gt;</span> usr/lib64     ├── media <span class="token comment"># 媒体文件存放目录，linux会把识别的设备（如U盘、光驱等）挂载到这个目录下</span>    ├── mnt <span class="token comment"># 临时挂载设备目录</span>    ├── opt <span class="token comment"># 自定义软件安装存放目录</span>    ├── proc<span class="token comment"># 虚拟目录，是系统内存的映射，进程及内核信息存放目录</span>    ├── root <span class="token comment"># Root用户主目录</span>    ├── run <span class="token comment"># 系统运行时产生临时文件，存放目录</span>    ├── sbin <span class="token comment"># 系统管理命令存放目录</span>    -<span class="token operator">&gt;</span> usr/sbin     ├── srv <span class="token comment"># 服务启动之后需要访问的数据目录</span>    ├── sys <span class="token comment"># 系统使用目录</span>    ├── tmp <span class="token comment"># 临时文件目录</span>    ├── usr <span class="token comment"># 系统命令和帮助文件目录</span>    └── var<span class="token comment"># 存放内容易变的文件的目录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-1-2-核心文件"><a href="#1-1-2-核心文件" class="headerlink" title="1.1.2 核心文件"></a>1.1.2 核心文件</h3><p><strong>1）/dev目录：</strong></p><table><thead><tr><th>文件名</th><th>作用</th></tr></thead><tbody><tr><td>/dev/hd[a-t]</td><td>IDE设备</td></tr><tr><td>/dev/sd[a-z]</td><td>SCSI设备(/dev/sda)</td></tr><tr><td>/dev/cdrom</td><td>光驱</td></tr><tr><td>/dev/null</td><td>无限数据接收设备,相当于  黑洞</td></tr><tr><td>/dev/zero</td><td>无限零资源，要多少有多少</td></tr></tbody></table><p><strong>2）/etc目录：</strong></p><table><thead><tr><th>文件名</th><th>作用</th></tr></thead><tbody><tr><td>/etc/sysconfig/network-scripts/ifcfg-eth1</td><td>网卡配置文件，第二块ifcfg-eth0</td></tr><tr><td>/etc/resolv.conf</td><td>Linux系统过时的DNS客户端配置文件</td></tr><tr><td>/etc/hostname</td><td>主机名配置文件</td></tr><tr><td>/etc/hosts</td><td>系统本地的[域名解析文件局域网；域名和IP解析文件)</td></tr><tr><td>/etc/fstab</td><td>配置开机设备自动挂载的文件</td></tr><tr><td>/etc/rc.local</td><td>存放开机自启动程序命令的文件</td></tr><tr><td>/etc/issue</td><td>软件bug，和特定版本有关。</td></tr><tr><td>/etc/motd</td><td>配置用户登录系统之后显示提示内容的文件</td></tr><tr><td>/etc/redhat-release</td><td>声明Red Hat版本号和名称信息的文件</td></tr><tr><td>/etc/sysctl.conf</td><td>Linux内核参数设置文件（系统优化）</td></tr><tr><td>/etc/profile、/etc/bashrc、.bashrc、.bash_profile</td><td>配置系统的环境变量/别名等的文件</td></tr></tbody></table><p><strong>3）/proc目录：</strong></p><table><thead><tr><th>文件名</th><th>作用</th></tr></thead><tbody><tr><td>/proc/cpuinfo</td><td>当前cpu信息文件</td></tr><tr><td>/proc/meminfo</td><td>当前内存信息文件</td></tr><tr><td>/proc/loadavg</td><td>当前系统的平均负载文件</td></tr><tr><td>/proc/mounts</td><td>当前设备挂载列表信息文件</td></tr><tr><td>/proc/interrupts</td><td>当前系统中断信息文件</td></tr></tbody></table><p><strong>4）/usr目录：</strong></p><table><thead><tr><th>文件名</th><th>作用</th></tr></thead><tbody><tr><td>/usr/local/</td><td>编译安装软件默认的位置路径</td></tr><tr><td>/usr/src</td><td>源代码目录</td></tr></tbody></table><p><strong>5）/var目录：</strong></p><table><thead><tr><th>文件名</th><th>作用</th></tr></thead><tbody><tr><td>/var/log/messages</td><td>linux系统日志文件，系统启动后的信息和错误日志，保存系统故障</td></tr><tr><td>/var/log/secure</td><td>安全日志（ssh日志记录到这里），监控日志</td></tr><tr><td>/var/log/dmesg</td><td>记录硬件信息加载情况的日志文件(dmesg)</td></tr><tr><td>/var/log/lastlog</td><td>有哪些用户登录lastlog</td></tr><tr><td>/var/log/maillog</td><td>与邮件相关的日志信息</td></tr><tr><td>/var/log/cron</td><td>与定时任务相关的日志信息</td></tr><tr><td>/var/log/spooler</td><td>与UUCP和news设备相关的日志信息</td></tr><tr><td>/var/log/boot.log</td><td>守护进程启动和停止相关的日志消息</td></tr></tbody></table><h2 id="1-2-目录操作"><a href="#1-2-目录操作" class="headerlink" title="1.2 目录操作"></a>1.2 目录操作</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看当前工作目录</span><span class="token builtin class-name">pwd</span><span class="token comment"># 清除屏幕</span><span class="token function">clear</span> <span class="token comment"># 当前用户目录</span><span class="token builtin class-name">cd</span> ~<span class="token comment"># 根目录</span><span class="token builtin class-name">cd</span> /<span class="token comment"># 上一次访问的目录</span><span class="token builtin class-name">cd</span> -<span class="token comment"># 上一级目录</span><span class="token builtin class-name">cd</span> <span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查看目录内信息</strong></p><p><code>ls</code>的命令选项：</p><table><thead><tr><th>命令选项</th><th>含义</th></tr></thead><tbody><tr><td><code>ls</code></td><td>列出当前目录中的文件和子目录。</td></tr><tr><td><code>ls -l</code></td><td>以长格式（详细信息）列出文件和子目录。</td></tr><tr><td><code>ls -a</code></td><td>列出包括隐藏文件在内的所有文件和子目录。</td></tr><tr><td><code>ls -lh</code></td><td>以长格式列出文件和子目录，以人类可读的格式显示文件大小。</td></tr><tr><td><code>ls -t</code></td><td>按修改时间排序，最新的文件/目录在前面。</td></tr><tr><td><code>ls -S</code></td><td>按文件大小排序，最大的文件在前面。</td></tr><tr><td><code>ls -r</code></td><td>反向排序，与默认排序相反。</td></tr><tr><td><code>ls -R</code></td><td>递归列出所有子目录中的文件和子目录。</td></tr></tbody></table><p>例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ll查看当前目录下内容（LL的小写）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Linux下文件的详细信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">r:Read   w:write  x: execute执行-rw-r--r-- <span class="token number">1</span> root root  <span class="token number">34942</span> Jan <span class="token number">19</span>  <span class="token number">2018</span> bootstrap.jar第一位代表文件类型：    <span class="token number">1</span>.“-”：代表普通文件    <span class="token number">2</span>.“d”：代表目录    <span class="token number">3</span>.“l”：链接文件（符号链接；小写的L）或软链接    <span class="token number">4</span>.“c”：字符设备文件    <span class="token number">5</span>.“b”：块设备文件    <span class="token number">6</span>.“s”：套接字文件    <span class="token number">7</span>.“p”：命名管道文件第一字段后9位：前三位代表当前用户对文件权限：可以读/可以写/不能执行中间三位代表当前组的其他用户对当前文件的操作权限：可以读/不能写/不能执行后三位其他用户对当前文件权限：可以读/不能写/不能执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>更改文件的权限</strong></p><p><code>chmod</code>的命令选项：</p><table><thead><tr><th>命令选项</th><th>含义</th></tr></thead><tbody><tr><td><code>chmod</code></td><td>用于更改文件或目录的权限。</td></tr><tr><td><code>chmod [权限] [文件/目录]</code></td><td>指定要更改权限的文件或目录以及权限设置。</td></tr><tr><td><code>chmod +x</code></td><td>添加执行权限。</td></tr><tr><td><code>chmod -x</code></td><td>移除执行权限。</td></tr><tr><td><code>chmod u=rw</code></td><td>设置用户（所有者）的读写权限。</td></tr><tr><td><code>chmod g=rx</code></td><td>设置组的读和执行权限。</td></tr><tr><td><code>chmod o=r</code></td><td>设置其他用户的只读权限。</td></tr><tr><td><code>chmod a+rw</code></td><td>添加读写权限给所有用户（等同于<code>chmod u+rw, g+rw, o+rw</code>）。</td></tr><tr><td><code>chmod -R</code></td><td>递归更改权限，用于目录及其内容。</td></tr><tr><td><code>chmod --reference=[参考文件] [文件/目录]</code></td><td>参考其他文件的权限设置。</td></tr><tr><td><code>chmod --version</code></td><td>显示<code>chmod</code>命令的版本信息。</td></tr></tbody></table><p>例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 为文件拥有者（user）添加执行权限；</span><span class="token function">chmod</span> u+x web.xml （---x------）<span class="token comment"># 为文件拥有者所在组（group）添加执行权限；</span><span class="token function">chmod</span> g+x web.xml （------x---）<span class="token comment"># 为所有用户分类，添加可执行权限；</span><span class="token function">chmod</span> <span class="token number">111</span> web.xml  （---x--x--x）<span class="token comment"># 为所有用户分类，添加可写入权限；</span><span class="token function">chmod</span> <span class="token number">222</span> web.xml （--w--w--w-）<span class="token comment"># 为所有用户分类，添加可读取权限；</span><span class="token function">chmod</span> <span class="token number">444</span> web.xml （-r--r--r--）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>创建目录</strong></p><p><code>mkdir</code>的命令选项：</p><table><thead><tr><th>命令选项</th><th>含义</th></tr></thead><tbody><tr><td><code>mkdir</code></td><td>创建新目录。</td></tr><tr><td><code>mkdir -p</code></td><td>递归创建目录。如果父级目录不存在，也会创建。</td></tr><tr><td><code>mkdir -m</code></td><td>指定新创建目录的权限（权限模式）。</td></tr><tr><td><code>mkdir -v</code></td><td>显示创建的每个目录。</td></tr><tr><td><code>mkdir --version</code></td><td>显示<code>mkdir</code>命令的版本信息。</td></tr></tbody></table><p>例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 在当前目录下创建aaa目录，相对路径；</span><span class="token function">mkdir</span> aaa<span class="token comment"># 在当前目录下创建bbb目录，相对路径；</span><span class="token function">mkdir</span> ./bbb<span class="token comment"># 在根目录下创建ccc目录，绝对路径；</span><span class="token function">mkdir</span> /ccc<span class="token comment"># 递归创建目录</span><span class="token function">mkdir</span> -p temp/temp2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>搜索命令</strong></p><p><code>find</code>的命令选项：</p><table><thead><tr><th>命令选项</th><th>含义</th></tr></thead><tbody><tr><td><code>find</code></td><td>用于搜索文件和目录。</td></tr><tr><td><code>find [路径]</code></td><td>指定要搜索的起始路径。</td></tr><tr><td><code>find -name</code></td><td>按文件名进行搜索。</td></tr><tr><td><code>find -iname</code></td><td>不区分大小写地按文件名进行搜索。</td></tr><tr><td><code>find -type</code></td><td>按文件类型进行搜索（例如，<code>f</code> 表示普通文件，<code>d</code> 表示目录）。</td></tr><tr><td><code>find -size</code></td><td>按文件大小进行搜索。</td></tr><tr><td><code>find -user</code></td><td>按文件所有者进行搜索。</td></tr><tr><td><code>find -group</code></td><td>按文件所属组进行搜索。</td></tr><tr><td><code>find -mtime</code></td><td>按文件修改时间进行搜索。</td></tr><tr><td><code>find -exec</code></td><td>对搜索结果执行指定的命令。</td></tr><tr><td><code>find -print</code></td><td>将搜索结果打印到标准输出。</td></tr><tr><td><code>find -maxdepth</code></td><td>限制搜索的最大深度。</td></tr><tr><td><code>find -mindepth</code></td><td>限制搜索的最小深度。</td></tr><tr><td><code>find -delete</code></td><td>删除搜索到的文件和目录。</td></tr></tbody></table><p>例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查询根目录下（包括子目录），名以b的目录和文件；</span><span class="token function">find</span> / -name <span class="token string">'b'</span><span class="token comment"># 查询根目录下（包括子目录），名以b开头的目录和文件； </span><span class="token function">find</span> / -name <span class="token string">'b*'</span><span class="token comment"># 查询当前目录下（包括子目录），名以b的目录和文件；</span><span class="token function">find</span> <span class="token builtin class-name">.</span> -name <span class="token string">'b'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>移动目录</strong></p><p><code>mv</code>的命令选项：</p><table><thead><tr><th>命令选项</th><th>含义</th></tr></thead><tbody><tr><td><code>mv</code></td><td>用于移动文件或重命名文件。</td></tr><tr><td><code>mv [源文件/目录] [目标文件/目录]</code></td><td>指定源文件/目录和目标位置。</td></tr><tr><td><code>mv -b</code></td><td>在覆盖目标文件时进行备份。</td></tr><tr><td><code>mv -f</code></td><td>强制移动，不询问确认。</td></tr><tr><td><code>mv -i</code></td><td>交互式移动，需要用户确认。</td></tr><tr><td><code>mv -u</code></td><td>仅在目标文件不存在或源文件更新时移动。</td></tr><tr><td><code>mv --version</code></td><td>显示<code>mv</code>命令的版本信息。</td></tr><tr><td><code>mv --help</code></td><td>显示<code>mv</code>命令的帮助信息。</td></tr></tbody></table><p>例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 文件重命名</span><span class="token function">mv</span> old_name new_name <span class="token comment"># 将根目录下的aaa目录，移动到bbb目录下(假如没有bbb目录，则重命名为bbb)；</span><span class="token function">mv</span>/aaa /bbb    <span class="token comment"># 将当前目录下的bbbb目录，移动到usr目录下，并且修改名称为bbb；</span><span class="token function">mv</span>bbbb usr/bbb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复制目录</strong></p><p><code>cp</code>的命令选项：</p><table><thead><tr><th>命令参数</th><th>含义</th></tr></thead><tbody><tr><td><code>cp file1 file2</code></td><td>复制 <code>file1</code> 到 <code>file2</code>。</td></tr><tr><td><code>cp -i file1 file2</code></td><td>在复制前进行交互式确认。</td></tr><tr><td><code>cp -r directory1 directory2</code></td><td>递归复制整个目录。</td></tr><tr><td><code>cp -u file1 file2</code></td><td>仅在源文件新于目标文件或目标文件不存在时复制。</td></tr><tr><td><code>cp -v file1 file2</code></td><td>显示正在复制的文件。</td></tr><tr><td><code>cp -p file1 file2</code></td><td>保留文件的权限、时间戳等。</td></tr><tr><td><code>cp -l file1 file2</code></td><td>创建硬链接而不是复制文件。</td></tr></tbody></table><p>例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 将/目录下的aaa目录复制到/bbb目录下，在/bbb目录下的名称为aaa</span><span class="token function">cp</span> -r /aaa /bbb<span class="token comment"># 将/目录下的aa目录复制到/bbb目录下，且修改名为aaa;</span><span class="token function">cp</span> -r /aaa /bbb/aaa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>删除目录</strong></p><p><code>rm</code>的命令选项：</p><table><thead><tr><th>命令选项</th><th>含义</th></tr></thead><tbody><tr><td><code>rm</code></td><td>用于删除文件或目录。</td></tr><tr><td><code>rm -f</code></td><td>强制删除，不提示确认。</td></tr><tr><td><code>rm -i</code></td><td>交互式删除，删除前提示用户确认。</td></tr><tr><td><code>rm -r</code></td><td>递归删除，用于删除目录及其内容。</td></tr><tr><td><code>rm -v</code></td><td>显示详细的操作信息，包括删除的文件名。</td></tr><tr><td><code>rm -d</code></td><td>删除空目录。</td></tr><tr><td><code>rm --</code></td><td>指定删除的文件名以横杠开头的情况。</td></tr><tr><td><code>rm -rf</code></td><td>强制递归删除，删除目录及其内容，无需确认。</td></tr><tr><td><code>rm -ri</code></td><td>交互式递归删除，删除前提示用户确认。</td></tr></tbody></table><p>例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 强制式删除指定目录</span><span class="token comment"># 强制删除/目录下的bbb目录。如果bbb目录中还有子目录，也会被强制删除，不会提示；</span><span class="token function">rm</span> -rf /bbb<span class="token comment"># 删除目录或文件</span><span class="token comment"># 普通删除。会询问你是否删除每一个文件</span><span class="token function">rm</span> -r /bbb<span class="token comment"># 目录的删除</span><span class="token function">rmdir</span> test01<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查看树状目录结构</strong></p><p><code>tree</code>命令的命令选项：</p><table><thead><tr><th>命令选项</th><th>含义</th></tr></thead><tbody><tr><td><code>tree</code></td><td>用于显示当前目录的树状结构。</td></tr><tr><td><code>tree [路径]</code></td><td>指定要显示树状结构的目录路径。</td></tr><tr><td><code>tree -d</code></td><td>仅显示目录，不显示文件。</td></tr><tr><td><code>tree -f</code></td><td>显示文件名称，而不是仅显示目录。</td></tr><tr><td><code>tree -L [级别]</code></td><td>限制显示的深度级别，只显示指定级别的目录。</td></tr><tr><td><code>tree -a</code></td><td>显示所有文件和目录，包括隐藏的。</td></tr><tr><td><code>tree -I [模式]</code></td><td>忽略与指定模式匹配的文件或目录。</td></tr><tr><td><code>tree -s</code></td><td>显示文件和目录的大小。</td></tr><tr><td><code>tree -h</code></td><td>以人类可读的格式显示文件和目录的大小。</td></tr><tr><td><code>tree -v</code></td><td>显示详细信息，包括文件和目录的权限和所有者。</td></tr></tbody></table><p>例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tree test01/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>批量操作</strong></p><p>需要采用<code>{}</code>进行参数的传入了。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token punctuation">{</span>dirA,dirB<span class="token punctuation">}</span>  <span class="token comment"># 批量创建测试目录</span><span class="token function">touch</span> dirA/<span class="token punctuation">{</span>A1,A2,A3<span class="token punctuation">}</span>    <span class="token comment"># dirA创建三个文件dirA/A1,dirA/A2,dirA/A3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>递归删除.pyc格式的文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> <span class="token builtin class-name">.</span> -name <span class="token string">'*.pyc'</span> -exec <span class="token function">rm</span> -rf <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">\</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打印当前文件夹下指定大小的文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> <span class="token builtin class-name">.</span> -name <span class="token string">"*"</span> -size 145800c -print<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>递归删除指定大小的文件(145800)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> <span class="token builtin class-name">.</span> -name <span class="token string">"*"</span> -size 145800c -exec <span class="token function">rm</span> -rf <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">\</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>递归删除指定大小的文件，并打印出来</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> <span class="token builtin class-name">.</span> -name <span class="token string">"*"</span> -size 145800c -print -exec <span class="token function">rm</span> -rf <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">\</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>"."</code> 表示从当前目录开始递归查找</li><li><code>“ -name '*.exe' "</code>根据名称来查找，要查找所有以.exe结尾的文件夹或者文件</li><li><code>" -type f "</code>查找的类型为文件</li><li><code>"-print"</code> 输出查找的文件目录名</li><li><code>-size 145800c</code> 指定文件的大小</li><li><code>-exec rm -rf {} \;</code> 递归删除（前面查询出来的结果）</li></ul><h2 id="1-3-文件操作"><a href="#1-3-文件操作" class="headerlink" title="1.3 文件操作"></a>1.3 文件操作</h2><p><strong>删除文件</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rm</span> -r a.java删除当前目录下的a.java文件（每次回询问是否删除y：同意）<span class="token comment"># 强制删除</span><span class="token function">rm</span> -rf a.java强制删除当前目录下的a.java文件<span class="token function">rm</span> -rf ./a*强制删除当前目录下以a开头的所有文件；<span class="token function">rm</span> -rf ./*强制删除当前目录下所有文件（慎用）；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>创建文件</strong></p><p><code>touch</code>的命令选项：</p><table><thead><tr><th>命令选项</th><th>含义</th></tr></thead><tbody><tr><td><code>touch</code></td><td>用于创建空文件或更新时间戳。</td></tr><tr><td><code>touch [文件]</code></td><td>指定要创建或更新的文件名。</td></tr><tr><td><code>touch -a</code></td><td>仅更新文件的访问时间戳。</td></tr><tr><td><code>touch -m</code></td><td>仅更新文件的修改时间戳。</td></tr><tr><td><code>touch -c</code></td><td>仅在文件不存在时创建新文件。</td></tr><tr><td><code>touch -t</code></td><td>使用指定的时间戳来设置文件的时间戳。</td></tr><tr><td><code>touch --version</code></td><td>显示<code>touch</code>命令的版本信息。</td></tr><tr><td><code>touch --help</code></td><td>显示<code>touch</code>命令的帮助信息。</td></tr></tbody></table><p>例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> testFile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>split拆分文件</strong></p><p>split命令：可以将一个大文件分割成很多个小文件，有时需要将文件分割成更小的片段，比如为提高可读性，生成日志等。</p><blockquote><p>b：值为每一输出档案的大小，单位为 byte。<br>-C：每一输出档中，单行的最大 byte 数。<br>-d：使用数字作为后缀。<br>-l：值为每一输出档的行数大小。<br>-a：指定后缀长度(默认为2)。</p></blockquote><p>使用split命令将上面创建的date.file文件分割成大小为10KB的小文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost split<span class="token punctuation">]</span><span class="token comment"># split -b 10k date.file </span><span class="token punctuation">[</span>root@localhost split<span class="token punctuation">]</span><span class="token comment"># ls</span>date.file  xaa  xab  xac  xad  xae  xaf  xag  xah  xai  xaj<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>文件被分割成多个带有字母的后缀文件，如果想用数字后缀可使用-d参数，同时可以使用-a length来指定后缀的长度：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost split<span class="token punctuation">]</span><span class="token comment"># split -b 10k date.file -d -a 3</span><span class="token punctuation">[</span>root@localhost split<span class="token punctuation">]</span><span class="token comment"># ls</span>date.file  x000  x001  x002  x003  x004  x005  x006  x007  x008  x009<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>为分割后的文件指定文件名的前缀：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost split<span class="token punctuation">]</span><span class="token comment"># split -b 10k date.file -d -a 3 split_file</span><span class="token punctuation">[</span>root@localhost split<span class="token punctuation">]</span><span class="token comment"># ls</span>date.file  split_file000  split_file001  split_file002  split_file003  split_file004  split_file005  split_file006  split_file007  split_file008  split_file009<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用-l选项根据文件的行数来分割文件，例如把文件分割成每个包含10行的小文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">split</span> -l <span class="token number">10</span> date.file<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-4-文件内容操作"><a href="#1-4-文件内容操作" class="headerlink" title="1.4 文件内容操作"></a>1.4 文件内容操作</h2><p><strong>修改文件内容</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 进入一般模式</span><span class="token function">vim</span> a.java   <span class="token comment"># 进入插入模式(编辑模式)</span>i<span class="token punctuation">(</span>按键<span class="token punctuation">)</span>   <span class="token comment"># 退出</span>ESC<span class="token punctuation">(</span>按键<span class="token punctuation">)</span>  <span class="token comment"># 保存退出（shift+：调起输入框）</span>:wq <span class="token comment"># 不保存退出（shift+：调起输入框）（内容有更改）(强制退出，不保留更改内容)</span>:q！<span class="token comment"># 不保存退出（shift+：调起输入框）（没有内容更改）</span>:q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>文件内容的查看</strong></p><p><code>cat</code>的命令选项：</p><table><thead><tr><th>命令选项</th><th>含义</th></tr></thead><tbody><tr><td><code>cat</code></td><td>用于查看文件内容或将多个文件连接。</td></tr><tr><td><code>cat [文件]</code></td><td>显示指定文件的内容。</td></tr><tr><td><code>cat -n</code></td><td>显示行号，将行号添加到每行前面。</td></tr><tr><td><code>cat -b</code></td><td>显示行号，只对非空行添加行号。</td></tr><tr><td><code>cat -s</code></td><td>压缩多个空白行为一个空白行。</td></tr><tr><td><code>cat -E</code></td><td>在每行的末尾显示美元符号（$），表示行尾。</td></tr><tr><td><code>cat -T</code></td><td>在制表符位置显示”^I”，表示制表符。</td></tr><tr><td><code>cat -v</code></td><td>显示不可打印字符和制徽符号。</td></tr><tr><td><code>cat -A</code></td><td>结合了 <code>-E</code> 和 <code>-T</code> 选项的效果。</td></tr><tr><td><code>cat -u</code></td><td>不缓冲输出，适用于非交互式操作。</td></tr><tr><td><code>cat --version</code></td><td>显示<code>cat</code>命令的版本信息。</td></tr><tr><td><code>cat --help</code></td><td>显示<code>cat</code>命令的帮助信息。</td></tr></tbody></table><p>例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看a.java文件的最后一页内容；</span><span class="token function">cat</span> a.java<span class="token comment"># 从第一页开始查看a.java文件内容，按回车键一行一行进行查看，按空格键一页一页进行查看，q退出；</span><span class="token function">more</span> a.java<span class="token comment"># 从第一页开始查看a.java文件内容，按回车键一行一行的看，按空格键一页一页的看，支持使用PageDown和PageUp翻页，q退出；</span><span class="token function">less</span> a.java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结下more 和 less的区别:</strong></p><ol><li>less可以按键盘上下方向键显示上下内容,more不能通过上下方向键控制显示</li><li>less不必读整个文件，加载速度会比more更快</li><li>less退出后shell不会留下刚显示的内容,而more退出后会在shell上留下刚显示的内容.</li><li>由于more不能后退.</li></ol><p><strong>查看某文件下的用户操作日志</strong><br>到达操作的目录下，执行下面的程序：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> .bash_history<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>实时查看文件后几行(实时查看日志)</strong></p><p><code>tail</code>的命令选项：</p><table><thead><tr><th>命令选项</th><th>含义</th></tr></thead><tbody><tr><td><code>tail</code></td><td>用于查看文件末尾的内容。</td></tr><tr><td><code>tail [文件]</code></td><td>显示指定文件的末尾内容。</td></tr><tr><td><code>tail -n [行数]</code></td><td>显示指定行数的末尾内容，默认为10行。</td></tr><tr><td><code>tail -f</code></td><td>跟踪文件，实时显示文件的新增内容。</td></tr><tr><td><code>tail -c [字节数]</code></td><td>显示指定字节数的末尾内容。</td></tr><tr><td><code>tail -q</code></td><td>静默模式，不显示文件名。</td></tr><tr><td><code>tail -v</code></td><td>显示文件名，即使只查看一个文件。</td></tr><tr><td><code>tail --version</code></td><td>显示<code>tail</code>命令的版本信息。</td></tr><tr><td><code>tail --help</code></td><td>显示<code>tail</code>命令的帮助信息。</td></tr></tbody></table><p>例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看a.java文件的后10行内容；</span><span class="token function">tail</span> -f a.java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>前后几行查看：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看a.java文件的前10行内容；</span><span class="token function">head</span> a.java<span class="token comment"># 查看a.java文件的后10行内容；</span><span class="token function">tail</span> -f a.java<span class="token comment"># 查看a.java文件的前7行内容；</span><span class="token function">head</span> -n <span class="token number">7</span> a.java<span class="token comment"># 查看a.java文件的后7行内容；</span><span class="token function">tail</span> -n <span class="token number">7</span> a.java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>文件内部搜索指定的内容</strong></p><p><code>grep</code>的命令选项：</p><table><thead><tr><th>命令选项</th><th>含义</th></tr></thead><tbody><tr><td><code>grep</code></td><td>用于在文本中搜索指定模式的字符串。</td></tr><tr><td><code>grep [模式] [文件]</code></td><td>指定要搜索的模式和文件名。</td></tr><tr><td><code>grep -i</code></td><td>不区分大小写进行搜索。</td></tr><tr><td><code>grep -v</code></td><td>反向匹配，显示不包含模式的行。</td></tr><tr><td><code>grep -r</code></td><td>递归搜索，用于目录及其子目录。</td></tr><tr><td><code>grep -l</code></td><td>仅显示包含模式的文件名，而不是匹配的行。</td></tr><tr><td><code>grep -n</code></td><td>显示行号，将行号添加到匹配的行前面。</td></tr><tr><td><code>grep -c</code></td><td>统计匹配的行数而不显示匹配的行。</td></tr><tr><td><code>grep -o</code></td><td>仅显示匹配的部分，而不是整行。</td></tr><tr><td><code>grep --version</code></td><td>显示<code>grep</code>命令的版本信息。</td></tr><tr><td><code>grep --help</code></td><td>显示<code>grep</code>命令的帮助信息。</td></tr></tbody></table><p>例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 在123.txt文件中搜索under字符串，大小写敏感，显示行；</span><span class="token function">grep</span> under <span class="token number">123</span>.txt<span class="token comment"># 在123.txt文件中搜索under字符串，大小写敏感，显示行及行号；</span><span class="token function">grep</span> -n under <span class="token number">123</span>.txt<span class="token comment"># 在123.txt文件中搜索under字符串，大小写敏感，显示没搜索到的行；</span><span class="token function">grep</span> -v under <span class="token number">123</span>.txt<span class="token comment"># 在123.txt文件中搜索under字符串，大小写敏感，显示行；</span><span class="token function">grep</span> -i under <span class="token number">123</span>.txt<span class="token comment"># 在123.txt文件中搜索under字符串，大小写敏感，显示行及行号；</span><span class="token function">grep</span> -ni under <span class="token number">123</span>.txt<span class="token comment"># 从test开头文件中，查找含有start的行</span><span class="token function">grep</span> <span class="token string">"start"</span> test*<span class="token comment"># 查看包含https的行，并展示前1行(-A)，后1行(-B)</span><span class="token function">grep</span> -A <span class="token number">1</span> -B <span class="token number">1</span> <span class="token string">"https"</span> wget-log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>终止当前操作</strong></p><p><code>Ctrl+c</code>和<code>Ctrl+z</code>都是中断命令，但是作用却不一样。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Ctrl+Z 可以将任务中断，但是任务并没有结束，在进程中只是维持挂起的状态，用户可以使用fg/bg操作前台或后台的任务，fg命令重新启动前台被中断的任务，bg命令把被中断的任务放在后台执行。</span>ctrl+z<span class="token comment"># Ctrl+C 可以强制中断程序的执行。</span>ctrl+c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>重定向功能</strong><br>可以使用 &gt; 或 &lt; 将命令的输出的命令重定向到test.txt文件中（没有则创建一个）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">'Hello World'</span> <span class="token operator">&gt;</span> /root/test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>数据统计</strong></p><p><code>awk</code>的命令选项：</p><table><thead><tr><th>命令选项</th><th>含义</th></tr></thead><tbody><tr><td><code>awk</code></td><td>用于处理文本数据，执行指定的程序。</td></tr><tr><td><code>awk 'program' [文件]</code></td><td>指定要处理的文本文件和<code>awk</code>程序。</td></tr><tr><td><code>awk -F [分隔符]</code></td><td>指定字段分隔符，用于分割每行的字段。</td></tr><tr><td><code>awk -v var=value</code></td><td>定义一个<code>awk</code>变量并赋值。</td></tr><tr><td><code>awk -f [脚本文件]</code></td><td>从外部文件加载<code>awk</code>程序。</td></tr><tr><td><code>awk -W version</code></td><td>显示<code>awk</code>的版本信息。</td></tr><tr><td><code>awk --help</code></td><td>显示<code>awk</code>命令的帮助信息。</td></tr></tbody></table><p>例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">awk</span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token string">'cmd'</span> <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>一次读取一行文本，按输入分隔符进行切片，切成多个组成部分。</li><li>将切片直接保存在内建的变量中，$1,$2…($0表示行的全部)。</li><li>支持对单个切片的判断，支持循环判断，默认分隔符为空格。</li><li>-F 指定分隔符(默认为空格)</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 将 email.out 进行切分，打印出第1/3列内容</span><span class="token function">awk</span> <span class="token string">'{print $1,$3}'</span> email.out  <span class="token comment"># 将`email.out`进行切分，打印出第1/3列内容</span><span class="token function">awk</span> <span class="token string">'{print $1,$3}'</span> email.out <span class="token comment"># 将`email.out`进行切分，当第1列为tcp,第2列为1的列，全部打印</span><span class="token function">awk</span> <span class="token string">'$1=="tcp" &amp;&amp; $2==1{print $0}'</span> email.out<span class="token comment">#  在上面的基础上将表头进行打印(NR表头)</span><span class="token function">awk</span> <span class="token string">'($1=="tcp" &amp;&amp; $2==1)|| NR==1 {print $0}'</span> email.out<span class="token comment">#  以`,`为分隔符，切分数据，并打印第二列的内容</span><span class="token function">awk</span> -F <span class="token string">","</span> <span class="token string">'{print $2}'</span> test.txt<span class="token comment"># 将日志中第1/3列进行打印，并对第1列的数据进行分类统计</span><span class="token function">awk</span> <span class="token string">'{print $1,$3}'</span> email.out <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{count[$1]++} END {for(i in count) print i "\t" count[i]}'</span><span class="token comment">#  根据逗号`,`切分数据，并将第一列存在文件`test01.txt`中</span><span class="token function">awk</span> -F <span class="token string">","</span> '<span class="token punctuation">{</span>print <span class="token variable">$1</span> <span class="token operator">&gt;&gt;</span> <span class="token string">"test01.txt"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>替换文件内容</strong></p><p><code>sed</code>的命令选项：</p><table><thead><tr><th>命令选项</th><th>含义</th></tr></thead><tbody><tr><td><code>sed</code></td><td>用于编辑和转换文本流。</td></tr><tr><td><code>sed 's/模式/替换/'</code></td><td>替换文本中与模式匹配的内容。</td></tr><tr><td><code>sed -n</code></td><td>静默模式，只显示经过<code>sed</code>处理的行。</td></tr><tr><td><code>sed -e</code></td><td>后跟一个<code>sed</code>脚本命令，多个命令可以用分号分隔。</td></tr><tr><td><code>sed -f</code></td><td>从外部文件加载<code>sed</code>脚本。</td></tr><tr><td><code>sed -i</code></td><td>直接编辑文件，而不是输出到标准输出。</td></tr><tr><td><code>sed -r</code></td><td>启用扩展正则表达式（支持更多的模式匹配特性）。</td></tr><tr><td><code>sed -l</code></td><td>生成<code>l</code>选项的输出，用于查看<code>sed</code>脚本的命令。</td></tr><tr><td><code>sed --version</code></td><td>显示<code>sed</code>命令的版本信息。</td></tr><tr><td><code>sed --help</code></td><td>显示<code>sed</code>命令的帮助信息。</td></tr></tbody></table><p><strong>sed替换标记</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g <span class="token comment"># 表示行内全面替换。  </span>p <span class="token comment"># 表示打印行。  </span>w <span class="token comment"># 表示把行写入一个文件。  </span>x <span class="token comment"># 表示互换模板块中的文本和缓冲区中的文本。  </span>y <span class="token comment"># 表示把一个字符翻译为另外的字符（但是不用于正则表达式）</span><span class="token punctuation">\</span><span class="token number">1</span> <span class="token comment"># 子串匹配标记</span><span class="token operator">&amp;</span> <span class="token comment"># 已匹配字符串标记</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sed</span> <span class="token punctuation">[</span>option<span class="token punctuation">]</span> <span class="token string">'sed commond'</span> filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>全名Stream Editor，流编辑器</li><li>适合用于对文本行内容进行处理</li><li>sed commond为正则表达式</li><li>sed commond中为三个/，分别为源内容，替换后的内容</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 替换解析</span><span class="token function">sed</span> -i <span class="token string">'s/^Str/String/'</span> replace.java <span class="token comment"># 将末尾的.替换为；(转义.)</span><span class="token function">sed</span> -i <span class="token string">'s/\.$/\;/'</span><span class="token comment"># 全文将Jack替换为me(g是全部替换,不加只替换首个)</span><span class="token function">sed</span> -i <span class="token string">'s/Jack/me/g/ replace.java# 删除replace.java中的空格(d是删除)sed -i '</span>/^ *$/d<span class="token string">' replace.java# 删除包含Interger的行(d是删除)sed -i '</span>/Interger/d<span class="token string">' replace.java# 多命令一起执行grep '</span>input<span class="token string">' 123.txt | sed '</span>s/<span class="token punctuation">\</span>"//g<span class="token punctuation">;</span> s/,/<span class="token punctuation">\</span>n/g<span class="token string">'# 替换后将数据保存在文中grep  123.txt | sed -n '</span>s/<span class="token punctuation">\</span>"//gw test01.txt'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>管道操作符</strong> |`</p><ul><li>可将指令连接起来，前一个指令的输出作为后一个指令的输入</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> ~ <span class="token operator">|</span><span class="token function">grep</span> <span class="token string">"test"</span><span class="token function">find</span> ~               <span class="token comment"># 查找当前用户所有文件</span><span class="token function">grep</span> <span class="token string">"test"</span>             <span class="token comment"># 从文件中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用管道注意的要点</p><ul><li>只处理前一个命令正确输出，不处理错误输出。</li><li>右边命令必须能够接收标准输入流，否则传递过程中数据会被抛弃</li><li>sed，awk，grep，cut，head，top，less，more，c，join，sort，split等</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 从email.log文件中查询包含error的行</span><span class="token function">grep</span> <span class="token string">'error'</span> email.log<span class="token comment"># 获取到error的行,并取[]含有数字的</span><span class="token function">grep</span> <span class="token string">'error'</span> email.log <span class="token operator">|</span> <span class="token function">grep</span> -o <span class="token string">'\[0-9\]'</span><span class="token comment"># 并过滤掉含有当前进程</span><span class="token function">ps</span> -ef<span class="token operator">|</span><span class="token function">grep</span> tomcat <span class="token operator">|</span><span class="token function">grep</span> -v <span class="token comment"># 替换后将数据保存在文中</span><span class="token function">grep</span>  <span class="token number">123</span>.txt <span class="token operator">|</span> <span class="token function">sed</span> -n <span class="token string">'s/\"//gw test01.txt'</span><span class="token comment"># 将文件`123.txt`，按`,`切分，去除`"`，按`:`切分后，将第一列存到文件`test01.txt`中**</span><span class="token function">grep</span> <span class="token string">'input'</span> <span class="token number">123</span>.txt <span class="token operator">|</span> <span class="token function">awk</span> -F <span class="token string">','</span> <span class="token string">'{print $2}'</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/\"//g; s/,/\n/g'</span> <span class="token operator">|</span> <span class="token function">awk</span> -F <span class="token string">":"</span> <span class="token string">'{print $1 &gt;&gt; "test01.txt"}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>数据裁剪</strong></p><p><code>cut</code>的命令选项：</p><table><thead><tr><th>命令选项</th><th>含义</th></tr></thead><tbody><tr><td><code>cut</code></td><td>用于从文本行中剪切字段。</td></tr><tr><td><code>cut -f [字段列表]</code></td><td>指定要剪切的字段列表。</td></tr><tr><td><code>cut -d [分隔符]</code></td><td>指定字段的分隔符。</td></tr><tr><td><code>cut -c [字符列表]</code></td><td>按字符位置剪切，而不是字段。</td></tr><tr><td><code>cut -b [字节列表]</code></td><td>按字节位置剪切，而不是字段。</td></tr><tr><td><code>cut --complement</code></td><td>补集，保留未列出的字段。</td></tr><tr><td><code>cut -s</code></td><td>静默模式，跳过没有分隔符的行。</td></tr><tr><td><code>cut --version</code></td><td>显示<code>cut</code>命令的版本信息。</td></tr><tr><td><code>cut --help</code></td><td>显示<code>cut</code>命令的帮助信息。</td></tr></tbody></table><p>例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 文件截取</span><span class="token function">cut</span> -d <span class="token string">"："</span> -f <span class="token number">1</span> cut.txt<span class="token comment"># 管道截取</span><span class="token punctuation">[</span>root@localhost shell<span class="token punctuation">]</span><span class="token comment"># echo $PATH</span>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin<span class="token comment"># 按:分割。截取第3列</span><span class="token punctuation">[</span>root@localhost shell<span class="token punctuation">]</span><span class="token comment"># echo $PATH | cut -d ":" -f 3</span>/usr/sbin<span class="token comment"># 按:分割。截取第3列之后数据</span><span class="token punctuation">[</span>root@localhost shell<span class="token punctuation">]</span><span class="token comment"># echo $PATH | cut -d ":" -f 3-</span>/usr/sbin:/usr/bin:/root/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-5-用户权限操作"><a href="#1-5-用户权限操作" class="headerlink" title="1.5 用户权限操作"></a>1.5 用户权限操作</h2><h3 id="1-5-1-用户操作"><a href="#1-5-1-用户操作" class="headerlink" title="1.5.1 用户操作"></a>1.5.1 用户操作</h3><p>添加用户<code>sum</code>:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">useradd</span> –d /usr/sum -m <span class="token function">sum</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关于useradd的某些参数：</p><p><strong>-u：</strong> 指定 UID，这个 UID 必须是大于等于500，并没有其他用户占用的 UID</p><p><strong>-g：</strong> 指定默认组，可以是 GID 或者 GROUPNAME，同样也必须真实存在</p><p><strong>-G：</strong> 指定额外组</p><p><strong>-c：</strong> 指定用户的注释信息</p><p><strong>-d：</strong> 指定用户的家目录</p><p>已创建的用户<code>sum</code>设置密码</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">passwd</span> <span class="token function">sum</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用户添加<code>root</code>权限</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">visudo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>找到<code>root</code>用户权限位置<br>添加与<code>root</code>用户相同权限</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">## Allow root to run any commands anywhere</span>root    <span class="token assign-left variable">ALL</span><span class="token operator">=</span><span class="token punctuation">(</span>ALL<span class="token punctuation">)</span>       ALLeses    <span class="token assign-left variable">ALL</span><span class="token operator">=</span><span class="token punctuation">(</span>ALL<span class="token punctuation">)</span>       ALL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>新建的用户在面显示</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>切换下刚才添加的用户</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">su</span> <span class="token function">sum</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>sum: x:1000:1000:: /usr/sum :/bin/bash<br>sum: x:0:1000:: /usr/sum :/bin/bash</p><p>回到root用户</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">exit</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>修改已有用户信息<code>usermod</code></strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">usermod</span> 选项 用户名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除用户文件夹</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rm</span> -rf /usr/sum<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除用户<code>sum</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">userdel</span> <span class="token function">sum</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-5-2-添加组"><a href="#1-5-2-添加组" class="headerlink" title="1.5.2 添加组"></a>1.5.2 添加组</h3><p><strong>添加用户组</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">groupadd</span> groupname<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>修改用户组</strong><br>使用者权限：管理员用户</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">groupmod</span> 选项 用户组<span class="token function">groupmod</span>  -n new-usergroup  usergroup<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>常用的选项有：</p><ul><li>-g GID 为用户组指定新的组标识号。</li><li>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li><li>-n新用户组 将用户组的名字改为新名字</li></ul><p><strong>删除用户组</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">groupdel</span> groupname<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到自己的分组和分组id</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /etc/group<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-5-3-sudo用户权限操作"><a href="#1-5-3-sudo用户权限操作" class="headerlink" title="1.5.3 sudo用户权限操作"></a>1.5.3 sudo用户权限操作</h3><blockquote><p>比如我们使用普通用户操作用户或者操作用户组、以及修改网卡配置文件的时候，需要切换到root用户才操作，此时我们可以使用sudo命令提高普通用户的操作权限，以达到操作目的</p></blockquote><p><code>sudo</code>：控制用户对系统命令的使用权限,root允许的操作。<br>通过sudo可以提高普通用户的操作权限。<br><strong>使用者权限</strong>：普通用户</p><p>使用root用户权限执行命令，操作</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> -s<span class="token function">sudo</span> <span class="token function">vi</span> /etc/sysconfig/network-scripts/ifcfg-ens33 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-5-4-更换文件所有者"><a href="#1-5-4-更换文件所有者" class="headerlink" title="1.5.4 更换文件所有者"></a>1.5.4 更换文件所有者</h3><p>格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chown</span> <span class="token punctuation">[</span>-R<span class="token punctuation">]</span> 所有者 文件或目录<span class="token function">chown</span> <span class="token punctuation">[</span>-R<span class="token punctuation">]</span> 所有者:所属组 文件或目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将<code>kibana-8.3.3-linux-x86_64.tar.gz</code>所有者改为用户<code>sum</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chown</span> -R <span class="token function">sum</span> /usr/sum/kibana-8.3.3-linux-x86_64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将<code>kibana-8.3.3-linux-x86_64.tar.gz</code>所有者改为用户<code>sum</code>、所有组改为<code>sum</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chown</span> -R sum:sum /usr/sum/kibana-8.3.3-linux-x86_64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-6-软连接与硬连接"><a href="#1-6-软连接与硬连接" class="headerlink" title="1.6 软连接与硬连接"></a>1.6 软连接与硬连接</h2><p><strong>1、创建软连接</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ln <span class="token operator">-</span>s <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>app <span class="token operator">/</span>data<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：创建软连接时，data目录后不加 / (加上后是查找其下一级目录)；</p><p><strong>2、删除软连接</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">rm <span class="token operator">-</span>rf <span class="token operator">/</span>data<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：取消软连接最后没有/，rm -rf 软连接。加上/是删除文件夹；</p><p>文件软硬链接示意图：</p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E6%96%87%E4%BB%B6%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Alt"></p><h2 id="1-7-压缩和解压缩"><a href="#1-7-压缩和解压缩" class="headerlink" title="1.7 压缩和解压缩"></a>1.7 压缩和解压缩</h2><h3 id="1-7-1-tar"><a href="#1-7-1-tar" class="headerlink" title="1.7.1 tar"></a>1.7.1 tar</h3><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/tar%E5%91%BD%E4%BB%A4.png" alt="在这里插入图片描述"></p><p>压缩(-c)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 将当前目录下a.java、b.java打包</span><span class="token function">tar</span> -cvf start.tar a.java b.java<span class="token comment"># 将当前目录下的所欲文件打包压缩成haha.tar文件</span><span class="token function">tar</span> -cvf start.tar ./*<span class="token comment"># 将当前目录下a.java、b.java打包</span><span class="token function">tar</span> -zcvf start.tar.gz a.java b.java<span class="token comment"># 将当前目录下的所欲文件打包压缩成start.tar.gz文件</span><span class="token function">tar</span> -zcvf start.tar.gz ./*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解压缩(-x)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 解压start.tar压缩包，到当前文件夹下；</span><span class="token function">tar</span> -xvf start.tar<span class="token comment"># 解压start.tar压缩包，到/usr/local目录下；</span><span class="token function">tar</span> -xvf start.tar -C usr/local <span class="token comment"># 解压start.tar.gz压缩包，到当前文件夹下；</span><span class="token function">tar</span> -zxvf start.tar.gz<span class="token comment"># 解压start.tar.gz压缩包，到/usr/local目录下；</span><span class="token function">tar</span> -zxvf start.tar.gz -C usr/local<span class="token comment"># 解压缩`tar.xz`文件</span><span class="token function">tar</span> -xf node-v12.18.1-linux-x64.tar.xz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-7-2-unzip-zip"><a href="#1-7-2-unzip-zip" class="headerlink" title="1.7.2 unzip/zip"></a>1.7.2 unzip/zip</h3><p>压缩(zip)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 将单个文件压缩(lib.zip)</span><span class="token function">zip</span> lib.zip tomcat.jar<span class="token comment"># 将目录进行压缩(lib.zip)</span><span class="token function">zip</span> -r lib.zip lib/<span class="token comment"># 将多个文件压缩为zip文件(lib.zip)</span><span class="token function">zip</span> -r lib.zip tomcat-embed.jar xml-aps.jar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解压缩(unzip)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 解压一个zip格式压缩包</span><span class="token function">unzip</span> file1.zip  <span class="token comment"># 将`english.zip`包，解压到指定目录下`/usr/app/`</span><span class="token function">unzip</span> -d /usr/app/com.lydms.english.zip<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-7-3-gzip-gunzip"><a href="#1-7-3-gzip-gunzip" class="headerlink" title="1.7.3 gzip/gunzip"></a>1.7.3 gzip/gunzip</h3><p>gzip 压缩文件或目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -N N为数字1到9，为压缩率，9最高，默认6</span><span class="token comment">#-r 压缩目录</span><span class="token comment"># 默认压缩之后不会保留源文件，源文件变为\*.gz格式</span><span class="token comment"># 压缩/root/install.log文件</span><span class="token function">gzip</span> /root/install.log<span class="token function">ls</span> /root/install.log<span class="token punctuation">\</span>*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>gunzip解压缩gzip压缩的文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 解压缩/root下install.log.gz</span>gunzip /root /install.log.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-7-4-bzip2-bunzip2"><a href="#1-7-4-bzip2-bunzip2" class="headerlink" title="1.7.4 bzip2/bunzip2"></a>1.7.4 bzip2/bunzip2</h3><p>bzip2 压缩文件（压缩率比gzip高）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -N N为数字1到9，为压缩率，9最高，默认6</span><span class="token comment"># 默认压缩之后不会保留源文件，源文件变为\*.bz2格式</span><span class="token comment"># 压缩/root/install.log文件</span><span class="token function">bzip2</span> /root/install.log<span class="token function">ls</span> /root/install.log<span class="token punctuation">\</span>*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>bunzip2解压缩bzip2压缩的文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 解压缩/root下install.log.bz2</span>bunzip2 /root /install.log.bz2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="1-8-Docker常用命令"><a href="#1-8-Docker常用命令" class="headerlink" title="1.8 Docker常用命令"></a>1.8 Docker常用命令</h2><p><strong>1、下载镜像</strong><br><a href="https://so.csdn.net/so/search?q=Linux%E6%9C%8D%E5%8A%A1%E5%99%A8&amp;spm=1001.2101.3001.7020">Linux服务器</a>下载安装包镜像命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://mirrors.huaweicloud.com/elasticsearch/7.8.0/elasticsearch-7.8.0-windows-x86_64.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://mirrors.huaweicloud.com/">华为开源镜像站</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">https://mirrors.huaweicloud.com/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>2、常用命令</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 1、查看docker中下载好的镜像：</span><span class="token function">docker</span> images<span class="token comment"># 2、查询需要的容器名称：</span><span class="token function">docker</span> search mysql<span class="token comment"># 3、将需要的docker容器下载运行到本地(名称、端口号、msyql密码、ID)：</span><span class="token function">docker</span> run -di --name<span class="token operator">=</span>first -p <span class="token number">3306</span>:3306 -e <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span>root 26d26dsfsd31a<span class="token comment"># 4、查看运行的docker容器：</span><span class="token function">docker</span> <span class="token function">ps</span><span class="token comment"># 5、查看所有的docker容器（包括未运行的）：</span><span class="token function">docker</span> <span class="token function">ps</span> -a<span class="token comment"># 6、停止当前运行的docker容器：</span><span class="token function">docker</span> stop first<span class="token comment"># 7、启动docker容器：</span><span class="token function">docker</span> start first<span class="token comment"># 8、重启docker容器：</span><span class="token function">docker</span> restart first<span class="token comment"># 9、删除docker容器：</span><span class="token function">docker</span> <span class="token function">rm</span> first<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-9-运维常用命令"><a href="#1-9-运维常用命令" class="headerlink" title="1.9 运维常用命令"></a>1.9 运维常用命令</h2><p><strong>1、扫描服务器端口号</strong></p><p><strong>查看服务器是否可用</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ping</span> <span class="token number">49.32</span>.587.164<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>查看服务器指定端口是否可用</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">telnet <span class="token number">49.32</span>.587.164 <span class="token number">8093</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>1、shutdown(关闭计算机)</strong></p><p>shutdown是最常用也是最安全的关机和重启命令，它会在关机之前调用fsck检查磁盘，其中-h和-r是最常用的参数：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-h：停止系统服务并关机  -r： 停止系统服务后重启  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>案例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">shutdown</span> -h now  --立即关机  <span class="token function">shutdown</span> -h <span class="token number">10</span>:53  --到10:53关机，如果该时间小于当前时间，则到隔天  <span class="token function">shutdown</span> -h +10  --10分钟后自动关机  <span class="token function">shutdown</span> -r now  --立即重启  <span class="token function">shutdown</span> -r +30 <span class="token string">'The System Will Reboot in 30 Mins'</span>   --30分钟后重启并并发送通知给其它在线用户  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>强制重启</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">reboot</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>2、查看各种连接状态数量(ESTABLISHED、CLOSE_WAIT、TIME_WAIT)</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">netstat</span> -n <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看处于<code>ESTABLISHED</code>状态连接</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">netstat</span> -nt <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{if($NF=="ESTABLISHED"){wait[$5]++}}END{for(i in wait) print i,wait[i]}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看处于<code>CLOSE_WAIT</code>状态连接</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">netstat</span> -nt <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{if($NF=="CLOSE_WAIT"){wait[$5]++}}END{for(i in wait) print i,wait[i]}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看处于<code>TIME_WAIT</code>状态连接</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">netstat</span> -nt <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{if($NF=="TIME_WAIT"){wait[$5]++}}END{for(i in wait) print i,wait[i]}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>3、ping命令</strong></p><p>对 <a href="http://www.baidu.com/">www.baidu.com</a> 发送 4 个 ping 包, 检查与其是否联通</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ping</span> -c <span class="token number">4</span> www.baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>4、netstat 命令</strong><br><code>netstat 命令用于显示各种网络相关信息，如网络连接, 路由表, 接口状态等等;</code><br>列出所有处于监听状态的tcp端口:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">netstat</span> -lt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看所有的端口信息, 包括 PID 和进程名称</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">netstat</span> -tulpn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>5、查看当前端口号占用情况</strong><br>1.用于查看某一端口的占用情况</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">lsof</span> -i:8080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.显示tcp，udp的端口和进程等相关情况</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">netstat</span> -tunlp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.指定端口号的进程情况</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">netstat</span> -tunlp<span class="token operator">|</span><span class="token function">grep</span> <span class="token number">8080</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>4.查看PID进程信息</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> -aux <span class="token operator">|</span><span class="token function">grep</span> <span class="token number">28990</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>根据PID，查看JVM中各线程信息(‘0x9eb’为nid值)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jstack <span class="token number">2246</span><span class="token operator">|</span><span class="token function">grep</span> <span class="token string">'0x9eb'</span> -A <span class="token number">50</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>6、ps 命令</strong><br>过滤得到当前系统中的 ssh 进程信息</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'ssh'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>7、管道命令</strong><br><code>简单来说, Linux 中管道的作用是将上一个命令的输出作为下一个命令的输入, 像 pipe 一样将各个命令串联起来执行, 管道的操作符是 |</code><br>管道命令查看当前运行的程序中，名称为java的程序</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> -ef<span class="token operator">|</span><span class="token function">grep</span> java<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看/etc/passwd文件中的root内容</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /etc/passwd <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'root'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看当前系统的ip连接（Windows和Linux通用）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">netstat</span> -an<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将sh test.sh任务放到后台，并将打印的日志输出到<code>nohup.out</code>文件中，<strong>终端不再能够接收任何输入（标准输入）</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nohup</span> <span class="token function">sh</span> test.sh  <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将sh test.sh任务放到后台，并将打印的日志输出到<code>test.out</code>文件中，<strong>终端不再能够接收任何输入（标准输入）</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nohup</span> <span class="token function">sh</span> test.sh <span class="token operator">&gt;&gt;</span> test.out  <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将sh test.sh任务放到后台，并将打印的日志输出到nohup.out文件中，<strong>终端能够接收任何输入</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nohup</span> <span class="token function">sh</span> test.sh  <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>8、添加Host地址</strong><br>打开配置文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/hosts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在打开的文件中添加</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">49.235</span>.32.164 www.baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>保存文件后，重启网络</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/etc/init.d/network restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-10-其他命令"><a href="#1-10-其他命令" class="headerlink" title="1.10 其他命令"></a>1.10 其他命令</h2><p><strong>1、xargs</strong></p><p>给其他命令传递参数的一个过滤器</p><p><strong>补充说明</strong></p><p><strong>xargs 命令</strong> 是给其他命令传递参数的一个过滤器，也是组合多个命令的一个工具。它擅长将标准输入数据转换成命令行参数，xargs 能够处理管道或者 stdin 并将其转换成特定命令的命令参数。xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。xargs 的默认命令是 echo，空格是默认定界符。这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。xargs 是构建单行命令的重要组件之一。</p><p><strong>xargs 命令用法</strong></p><p>xargs 用作替换工具，读取输入数据重新格式化后输出。</p><p><code>-n</code>：指定每行输出数量</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> test.txt <span class="token operator">|</span> <span class="token function">xargs</span> -n3a b cd e fg h ij k lm n o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>-d</code>：按指定内容分隔文本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span> <span class="token builtin class-name">echo</span> <span class="token string">"nameXnameXnameXname"</span> <span class="token operator">|</span> <span class="token function">xargs</span> -dXname name name name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>-l</code>：文本命令替换</p><p>xargs 的一个 选项 -I ，使用 -I 指定一个替换字符串{}，这个字符串在 xargs 扩展时会被替换掉，当 -I 与 xargs 结合使用，每一个参数命令都会被执行一次：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> *.jpg <span class="token operator">|</span> <span class="token function">xargs</span> -n1 -I <span class="token function">cp</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> /data/images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>-t</code>：将执行的命令，打印出来</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-t echo<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token function">ls</span> * <span class="token operator">|</span><span class="token function">xargs</span> -t -n1 -I <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token function">cp</span> -r <span class="token punctuation">{</span><span class="token punctuation">}</span> /root/ddd/ echo<span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结合使用—指定X切分，并每行2个</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@VM-0-9-centos ~<span class="token punctuation">]</span> <span class="token builtin class-name">echo</span> <span class="token string">"nameXnameXnameXname"</span> <span class="token operator">|</span> <span class="token function">xargs</span> -dX -n2name namename name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><p><strong>查看历史使用命令</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">history</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>过滤与<code>es</code>相关命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">history</span> <span class="token operator">|</span> <span class="token function">grep</span> es<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>查看占用资源</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> -au占用的资源是从进程启动开始，计算的平均占用资源，比如cpu等<span class="token function">top</span>实时占用的资源；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>查看当前目录所占存储</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">du</span> -lh查看当前文件下各文件夹占用存储空间<span class="token function">du</span> -sh查看当前文件夹所占存储空间<span class="token function">du</span> --max-depth<span class="token operator">=</span><span class="token operator">&lt;</span>目录层数<span class="token operator">&gt;</span> 超过指定层数的目录后，予以忽略。<span class="token function">du</span> --max-depth<span class="token operator">=</span><span class="token number">1</span> 只查看当前目录下文件占用的存储空间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>管道命令：</strong><br>根据项目查看进程，更加PID查看项目，以及项目路径</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> -ef 查看所有的进程<span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> mysql查看mysql相关的进程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过进程PID查看所占用的端口号</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">netstat</span> -nap <span class="token operator">|</span><span class="token function">grep</span> 进程ID<span class="token punctuation">(</span>PID<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>查看Linux下系统存储使用率</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">df</span> -h查看系统硬盘使用情况<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>杀死进程(根据PID)</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">kill</span> -9 <span class="token number">2630</span>进程pid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>关闭防火墙</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">service</span> iptables stop      临时关闭防火墙<span class="token function">chkconfig</span> iptables off     防火墙开启不启动<span class="token function">service</span> iptables status    查看防火墙状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>开机启动选项</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">msconfig查看开机启动选项<span class="token function">chkconfig</span>查看开机启动服务列表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>查看MySQL服务的程序的状态</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">service</span> mysql start        开启MySQL    <span class="token function">service</span> mysql status       查看MySQL的状态    <span class="token function">service</span> mysql stop         关闭MySQL    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>查看系统变量</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token environment constant">$USER</span>   输出某个变量<span class="token builtin class-name">set</span>         输出所有变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>2、curl语法</strong></p><p><strong>GET请求</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token string">"http://www.wangchujiang.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>POST请求</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#  普通文本</span><span class="token function">curl</span> -d<span class="token string">'login=emma＆password=123'</span> -X POST https://wangchujiang.com/login<span class="token comment">#  Json格式</span><span class="token function">curl</span> -l -H <span class="token string">"Content-type: application/json"</span> -X POST -d <span class="token string">'{"phone":"13521389587","password":"test"}'</span> http://wangchujiang.com/apis/users.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3、查询支持解析器</strong></p><p>Centos默认的解析器是<code>bash</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /etc/shells<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>列表</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/bin/sh<span class="token comment"># Centos默认的解析器是bash</span>/bin/bash/sbin/nologin/usr/bin/sh/usr/bin/bash/usr/sbin/nologin/bin/tcsh/bin/csh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>指定解析器执行<br>脚本以<code>#!/bin/bash</code>开头（指定解析器）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token builtin class-name">echo</span> <span class="token string">"helloworld"</span><span class="token number">12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>4、跨服务器文件复制</strong></p><p><code>scp</code>：用于服务器之间文件复制</p><p>将本服务器<code>/home/lydms/spark.tgz</code>文件复制到<code>hadoop102</code>服务器的<code>/home/lydms</code>，使用用户名为<code>lydms</code>。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">scp [本机文件所在位置] [目标服务器用户名] @ [服务器地址] ： [目标服务器目录] scp /home/lydms/spark.tgz lydms:hadoop102:/home/lydms123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>将源服务器<code>hadoop102</code>下<code>/home/lydms/spark.tgz</code>文件复制到本机<code>/home/lydms</code>，源用户名为<code>lydms</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">scp</span> <span class="token punctuation">[</span>目标服务器用户名<span class="token punctuation">]</span> @ <span class="token punctuation">[</span>服务器地址<span class="token punctuation">]</span>:<span class="token punctuation">[</span>目标服务器目录<span class="token punctuation">]</span> <span class="token punctuation">[</span>本机文件所在位置<span class="token punctuation">]</span> <span class="token function">scp</span> lydms:hadoop102:/home/lydms/spark.tgz /home/lydms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="1-11-Linux内核优化"><a href="#1-11-Linux内核优化" class="headerlink" title="1.11 Linux内核优化"></a>1.11 Linux内核优化</h2><p>打开配置文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/sysctl.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        Linux在系统运行时修改内核参数(/proc/sys与/etc/sysctl.conf)，而不需要重新引导系统，这个功能是通过/proc虚拟文件系统实现的。</p><p>​        在/proc/sys目录下存放着大多数的内核参数，并且设计成可以在系统运行的同时进行更改, 可以通过更改/proc/sys中内核参数对应的文件达到修改内核参数的目的(修改过后，保存配置文件就马上自动生效)，不过重新启动机器后之前修改的参数值会失效，所以只能是一种临时参数变更方案。(适合调试内核参数优化值的时候使用，如果设置值有问题，重启服务器还原原来的设置参数值了。简单方便。)</p><p>​        但是如果调试内核参数优化值结束后，需要永久保存参数值，就要通过修改/etc/sysctl.conf内的内核参数来永久保存更改。但只是修改sysctl文件内的参数值，确认保存修改文件后，设定的参数值并不会马上生效，如果想使参数值修改马上生效，并且不重启服务器，可以执行下面的命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sysctl –p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        下面介绍一下/proc/sys下内核文件与配置文件sysctl.conf中变量的对应关系：</p><p>​        由于可以修改的内核参数都在/proc/sys目录下，所以sysctl.conf的变量名省略了目录的前面部分（/proc/sys）。</p><pre><code>     即将/proc/sys中的文件转换成sysctl中的变量依据下面两个简单的规则：</code></pre><ul><li><p>去掉前面部分/proc/sys</p></li><li><p>将文件名中的斜杠变为点</p></li></ul><p>这两条规则可以将/proc/sys中的任一文件名转换成sysctl中的变量名。</p><p>例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/proc/sys/net/ipv4/ip_forward ＝》 net.ipv4.ip_forward/proc/sys/kernel/hostname ＝》 kernel.hostname<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以使用下面命令查询所有可修改的变量名</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sysctl –a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-11-1-Linux内核参数注释"><a href="#1-11-1-Linux内核参数注释" class="headerlink" title="1.11.1 Linux内核参数注释"></a>1.11.1 Linux内核参数注释</h3><p>下列文件所在目录：<code>/proc/sys/net/ipv4/</code></p><table><thead><tr><th>名称</th><th>默认值</th><th>建议值</th><th>描述</th></tr></thead><tbody><tr><td><strong>tcp_syn_retries</strong></td><td>5（约180s）</td><td>1（对于大负载而物理通信良好的网络而言，这个值偏高，可修改为2）</td><td>对于一个新建连接，内核要发送多少个 SYN 连接请求才 决定放弃。不应大于255。(这个值仅仅是针对对外的连接，对进来的连接,是由<strong>tcp_retries1</strong>决定的)</td></tr><tr><td><strong>tcp_synack_retries</strong></td><td>5（约180s）</td><td>1</td><td>对于远端的连接请求SYN，内核会发送SYN ＋ ACK数据报，以确认收到上一个 SYN连接请求包。这是所谓的三次握手机制的第二个步骤。这里决定内核在放弃连接之前所送出的 SYN+ACK 数目。不应该大于255。</td></tr><tr><td><strong>tcp_keepalive_time</strong></td><td>7200</td><td>600</td><td>TCP发送keepalive探测消息的间隔时间（秒），用于确认TCP连接是否有效。防止两边建立连接但不发送数据的攻击。</td></tr><tr><td><strong>tcp_keepalive_probes</strong></td><td>9</td><td>3</td><td>TCP发送keepalive探测消息的间隔时间（秒），用于确认TCP连接是否有效。</td></tr><tr><td><strong>tcp_keepalive_intvl</strong></td><td>75</td><td>15</td><td>探测消息未获得响应时，重发该消息的间隔时间（秒）。 (对于普通应用来说,这个值有一些偏大,可以根据需要改小.特别是web类服务器需要改小该值,15是个比较合适的值)</td></tr><tr><td><strong>tcp_retries1</strong></td><td>3</td><td>3</td><td>放弃回应一个TCP连接请求前﹐需要进行多少次重试。RFC规定最低的数值是3</td></tr><tr><td><strong>tcp_retries2</strong></td><td>15</td><td>5</td><td>在丢弃激活(已建立通讯状况)的TCP连接之前﹐需要进行多少次重试。根据RTO的值来决定，相当于13-30分钟(RFC1122规定，必须大于100秒).(这个值根据目前的网络设置,可以适当地改小,我的网络内修改为了5)</td></tr><tr><td><strong>tcp_orphan_retries</strong></td><td>7</td><td>3</td><td>在近端丢弃TCP连接之前﹐要进行多少次重试。默认值是7个﹐相当于 50秒 - 16分钟﹐视 RTO 而定。如果您的系统是负载很大的web服务器﹐那么也许需要降低该值﹐这类 sockets 可能会耗费大量的资源。另外参的考<strong>tcp_max_orphans</strong>。(事实上做NAT的时候,降低该值也是好处显著的,我本人的网络环境中降低该值为3)</td></tr><tr><td><strong>tcp_fin_timeout</strong></td><td>60</td><td>2</td><td>对于本端断开的socket连接，TCP保持在FIN-WAIT-2状态的时间。对方可能会断开连接或一直不结束连接或不可预料的进程死亡。默认值为 60 秒。</td></tr><tr><td><strong>tcp_max_tw_buckets</strong></td><td>180000</td><td>36000</td><td>系统在同时所处理的最大 timewait sockets 数目。如果超过此数的话﹐time-wait socket 会被立即砍除并且显示警告信息。之所以要设定这个限制﹐纯粹为了抵御那些简单的 DoS 攻击﹐不过﹐如果网络条件需要比默认值更多﹐则可以提高它(或许还要增加内存)。(事实上做NAT的时候最好可以适当地增加该值)</td></tr><tr><td><strong>tcp_tw_recycle</strong></td><td>0</td><td>1</td><td>打开快速 TIME-WAIT sockets 回收。除非得到技术专家的建议或要求﹐请不要随意修改这个值。(做NAT的时候，建议打开它)</td></tr><tr><td><strong>tcp_tw_reuse</strong></td><td>0</td><td>1</td><td>表示是否允许重新应用处于TIME-WAIT状态的socket用于新的TCP连接(这个对快速重启动某些服务,而启动后提示端口已经被使用的情形非常有帮助)</td></tr><tr><td><strong>tcp_max_orphans</strong></td><td>8192</td><td>32768</td><td>系统所能处理不属于任何进程的TCP sockets最大数量。假如超过这个数量﹐那么不属于任何进程的连接会被立即reset，并同时显示警告信息。之所以要设定这个限制﹐纯粹为了抵御那些简单的 DoS 攻击﹐千万不要依赖这个或是人为的降低这个限制。如果内存大更应该增加这个值。(这个值Redhat AS版本中设置为32768,但是很多防火墙修改的时候,建议该值修改为2000)</td></tr><tr><td><strong>tcp_abort_on_overflow</strong></td><td>0</td><td>0</td><td>当守护进程太忙而不能接受新的连接，就象对方发送reset消息，默认值是false。这意味着当溢出的原因是因为一个偶然的猝发，那么连接将恢复状态。只有在你确信守护进程真的不能完成连接请求时才打开该选项，该选项会影响客户的使用。(对待已经满载的sendmail,apache这类服务的时候,这个可以很快让客户端终止连接,可以给予服务程序处理已有连接的缓冲机会,所以很多防火墙上推荐打开它)</td></tr><tr><td><strong>tcp_syncookies</strong></td><td>0</td><td>1</td><td>只有在内核编译时选择了CONFIG_SYNCOOKIES时才会发生作用。当出现syn等候队列出现溢出时象对方发送syncookies。目的是为了防止syn flood攻击。</td></tr><tr><td><strong>tcp_stdurg</strong></td><td>0</td><td>0</td><td>使用 TCP urg pointer 字段中的主机请求解释功能。大部份的主机都使用老旧的 BSD解释，因此如果您在 Linux打开它﹐或会导致不能和它们正确沟通。</td></tr><tr><td><strong>tcp_max_syn_backlog</strong></td><td>1024</td><td>16384</td><td>对于那些依然还未获得客户端确认的连接请求﹐需要保存在队列中最大数目。对于超过 128Mb 内存的系统﹐默认值是 1024 ﹐低于 128Mb 的则为 128。如果服务器经常出现过载﹐可以尝试增加这个数字。警告﹗假如您将此值设为大于 1024﹐最好修改include/net/tcp.h里面的TCP_SYNQ_HSIZE﹐以保持TCP_SYNQ_HSIZE*16(SYN Flood攻击利用TCP协议散布握手的缺陷，伪造虚假源IP地址发送大量TCP-SYN半打开连接到目标系统，最终导致目标系统Socket队列资源耗尽而无法接受新的连接。为了应付这种攻击，现代Unix系统中普遍采用多连接队列处理的方式来缓冲(而不是解决)这种攻击，是用一个基本队列处理正常的完全连接应用(Connect()和Accept() )，是用另一个队列单独存放半打开连接。这种双队列处理方式和其他一些系统内核措施(例如Syn-Cookies/Caches)联合应用时，能够比较有效的缓解小规模的SYN Flood攻击(事实证明)</td></tr><tr><td><strong>tcp_window_scaling</strong></td><td>1</td><td>1</td><td>该文件表示设置tcp/ip会话的滑动窗口大小是否可变。参数值为布尔值，为1时表示可变，为0时表示不可变。tcp/ip通常使用的窗口最大可达到 65535 字节，对于高速网络，该值可能太小，这时候如果启用了该功能，可以使tcp/ip滑动窗口大小增大数个数量级，从而提高数据传输的能力(RFC 1323)。</td></tr><tr><td><strong>tcp_timestamps</strong></td><td>1</td><td>1</td><td>Timestamps 用在其它一些东西中﹐可以防范那些伪造的sequence 号码。一条1G的宽带线路或许会重遇到带 out-of-line数值的旧sequence 号码(假如它是由于上次产生的)。Timestamp 会让它知道这是个 ‘旧封包’。(该文件表示是否启用以一种比超时重发更精确的方法（RFC 1323）来启用对 RTT 的计算；为了实现更好的性能应该启用这个选项。)</td></tr><tr><td><strong>tcp_sack</strong></td><td>1</td><td>1</td><td>使用 Selective ACK﹐它可以用来查找特定的遗失的数据报— 因此有助于快速恢复状态。该文件表示是否启用有选择的应答（Selective Acknowledgment），这可以通过有选择地应答乱序接收到的报文来提高性能（这样可以让发送者只发送丢失的报文段）。(对于广域网通信来说这个选项应该启用，但是这会增加对 CPU 的占用。)</td></tr><tr><td><strong>tcp_fack</strong></td><td>1</td><td>1</td><td>打开FACK拥塞避免和快速重传功能。(注意，当<strong>tcp_sack</strong>设置为0的时候，这个值即使设置为1也无效)[这个是TCP连接靠谱的核心功能]</td></tr><tr><td><strong>tcp_dsack</strong></td><td>1</td><td>1</td><td>允许TCP发送”两个完全相同”的SACK。</td></tr><tr><td><strong>tcp_ecn</strong></td><td>0</td><td>0</td><td>TCP的直接拥塞通告功能。</td></tr><tr><td><strong>tcp_reordering</strong></td><td>3</td><td>6</td><td>TCP流中重排序的数据报最大数量。 (一般有看到推荐把这个数值略微调整大一些,比如5)</td></tr><tr><td><strong>tcp_retrans_collapse</strong></td><td>1</td><td>0</td><td>对于某些有bug的打印机提供针对其bug的兼容性。(一般不需要这个支持,可以关闭它)</td></tr><tr><td>*<em>tcp_wmem</em>***：*<em>min**<strong><strong>default</strong></strong>max*</em></td><td>409616384131072</td><td>819213107216777216</td><td>发送缓存设置min：为TCP socket预留用于发送缓冲的内存最小值。每个tcp socket都可以在建议以后都可以使用它。默认值为4096(4K)。default：为TCP socket预留用于发送缓冲的内存数量，默认情况下该值会影响其它协议使用的net.core.wmem_default 值，一般要低于net.core.wmem_default的值。默认值为16384(16K)。max: 用于TCP socket发送缓冲的内存最大值。该值不会影响net.core.wmem_max，”静态”选择参数SO_SNDBUF则不受该值影响。默认值为131072(128K)。（对于服务器而言，增加这个参数的值对于发送数据很有帮助,在我的网络环境中,修改为了51200 131072 204800）</td></tr><tr><td>*<em>tcp_<strong><strong>r</strong></strong>mem</em>***：*<em>min**<strong><strong>default</strong></strong>max*</em></td><td>409687380174760</td><td>3276813107216777216</td><td>接收缓存设置同tcp_wmem</td></tr><tr><td>*<em>tcp_mem</em>***：*<em>min**<strong><strong>default</strong></strong>max*</em></td><td>根据内存计算</td><td>7864321048576 1572864</td><td><strong>low</strong>：当TCP使用了低于该值的内存页面数时，TCP不会考虑释放内存。即低于此值没有内存压力。(理想情况下，这个值应与指定给 tcp_wmem 的第 2 个值相匹配 - 这第 2 个值表明，最大页面大小乘以最大并发请求数除以页大小 (131072 * 300 / 4096)。 )<strong>pressure</strong>：当TCP使用了超过该值的内存页面数量时，TCP试图稳定其内存使用，进入pressure模式，当内存消耗低于low值时则退出pressure状态。(理想情况下这个值应该是 TCP 可以使用的总缓冲区大小的最大值 (204800 * 300 / 4096)。 )<strong>high</strong>：允许所有tcp sockets用于排队缓冲数据报的页面量。(如果超过这个值，TCP 连接将被拒绝，这就是为什么不要令其过于保守 (512000 * 300 / 4096) 的原因了。 在这种情况下，提供的价值很大，它能处理很多连接，是所预期的 2.5 倍；或者使现有连接能够传输 2.5 倍的数据。 我的网络里为192000 300000 732000)一般情况下这些值是在系统启动时根据系统内存数量计算得到的。</td></tr><tr><td><strong>tcp_app_win</strong></td><td>31</td><td>31</td><td>保留max(window/2^tcp_app_win, mss)数量的窗口由于应用缓冲。当为0时表示不需要缓冲。</td></tr><tr><td><strong>tcp_adv_win_scale</strong></td><td>2</td><td>2</td><td>计算缓冲开销bytes/2^tcp_adv_win_scale(如果tcp_adv_win_scale &gt; 0)或者bytes-bytes/2^(-tcp_adv_win_scale)(如果tcp_adv_win_scale BOOLEAN&gt;0)</td></tr><tr><td><strong>tcp_low_latency</strong></td><td>0</td><td>0</td><td>允许 TCP/IP 栈适应在高吞吐量情况下低延时的情况；这个选项一般情形是的禁用。(但在构建Beowulf 集群的时候,打开它很有帮助)</td></tr><tr><td><strong>tcp_westwood</strong></td><td>0</td><td>0</td><td>启用发送者端的拥塞控制算法，它可以维护对吞吐量的评估，并试图对带宽的整体利用情况进行优化；对于 WAN通信来说应该启用这个选项。</td></tr><tr><td><strong>tcp_bic</strong></td><td>0</td><td>0</td><td>为快速长距离网络启用 Binary Increase Congestion；这样可以更好地利用以 GB 速度进行操作的链接；对于WAN 通信应该启用这个选项。</td></tr><tr><td><strong>ip_forward</strong></td><td>0</td><td>－</td><td>NAT必须开启IP转发支持，把该值写1</td></tr><tr><td><strong>ip_local_port_range</strong>:minmax</td><td>3276861000</td><td>102465000</td><td>表示用于向外连接的端口范围，默认比较小，这个范围同样会间接用于NAT表规模。</td></tr><tr><td><strong>ip_conntrack_max</strong></td><td>65535</td><td>65535</td><td>系统支持的最大ipv4连接数，默认65536（事实上这也是理论最大值），同时这个值和你的内存大小有关，如果内存128M，这个值最大8192，1G以上内存这个值都是默认65536</td></tr></tbody></table><p> 所处目录<code>/proc/sys/net/ipv4/netfilter/</code>，文件需要打开防火墙才会存在</p><table><thead><tr><th>名称</th><th>默认值</th><th>建议值</th><th>描述</th></tr></thead><tbody><tr><td><strong>ip_conntrack_max</strong></td><td>65536</td><td>65536</td><td>系统支持的最大ipv4连接数，默认65536（事实上这也是理论最大值），同时这个值和你的内存大小有关，如果内存128M，这个值最大8192，1G以上内存这个值都是默认65536,这个值受/proc/sys/net/ipv4/ip_conntrack_max限制</td></tr><tr><td><strong>ip_conntrack_tcp_timeout_established</strong></td><td>432000</td><td>180</td><td>已建立的tcp连接的超时时间，默认432000，也就是5天。影响：这个值过大将导致一些可能已经不用的连接常驻于内存中，占用大量链接资源，从而可能导致NAT ip_conntrack: table full的问题。建议：对于NAT负载相对本机的 NAT表大小很紧张的时候，可能需要考虑缩小这个值，以尽早清除连接，保证有可用的连接资源；如果不紧张，不必修改</td></tr><tr><td><strong>ip_conntrack_tcp_timeout_time_wait</strong></td><td>120</td><td>120</td><td>time_wait状态超时时间，超过该时间就清除该连接</td></tr><tr><td><strong>ip_conntrack_tcp_timeout_close_wait</strong></td><td>60</td><td>60</td><td>close_wait状态超时时间，超过该时间就清除该连接</td></tr><tr><td><strong>ip_conntrack_tcp_timeout_fin_wait</strong></td><td>120</td><td>120</td><td>fin_wait状态超时时间，超过该时间就清除该连接</td></tr></tbody></table><p> 文件所处目录<code>/proc/sys/net/core/</code></p><table><thead><tr><th>名称</th><th>默认值</th><th>建议值</th><th>描述</th></tr></thead><tbody><tr><td>netdev_max_backlog</td><td>1024</td><td>16384</td><td>每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目，对重负载服务器而言，该值需要调高一点。</td></tr><tr><td>somaxconn</td><td>128</td><td>16384</td><td>用来限制监听(LISTEN)队列最大数据包的数量，超过这个数量就会导致链接超时或者触发重传机制。web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而nginx定义的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值。对繁忙的服务器,增加该值有助于网络性能</td></tr><tr><td>wmem_default</td><td>129024</td><td>129024</td><td>默认的发送窗口大小（以字节为单位）</td></tr><tr><td>rmem_default</td><td>129024</td><td>129024</td><td>默认的接收窗口大小（以字节为单位）</td></tr><tr><td>rmem_max</td><td>129024</td><td>873200</td><td>最大的TCP数据接收缓冲</td></tr><tr><td>wmem_max</td><td>129024</td><td>873200</td><td>最大的TCP数据发送缓冲</td></tr></tbody></table><h3 id="1-11-2-修改内核参数的方法"><a href="#1-11-2-修改内核参数的方法" class="headerlink" title="1.11.2 修改内核参数的方法"></a>1.11.2 修改内核参数的方法</h3><p>1、使用echo value方式直接追加到文件里如<code>echo "1" &gt;/proc/sys/net/ipv4/tcp_syn_retries</code>，但这种方法设备重启后又会恢复为默认值</p><p>2、把参数添加到<code>/etc/sysctl.conf</code>中，然后执行sysctl -p使参数生效，永久生效</p><h3 id="1-11-3-内核生产环境优化参数"><a href="#1-11-3-内核生产环境优化参数" class="headerlink" title="1.11.3 内核生产环境优化参数"></a>1.11.3 内核生产环境优化参数</h3><p>这里所列参数是生产中常用的参数：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">net.ipv4.tcp_syn_retries <span class="token operator">=</span> <span class="token number">1</span>net.ipv4.tcp_synack_retries <span class="token operator">=</span> <span class="token number">1</span>net.ipv4.tcp_keepalive_time <span class="token operator">=</span> <span class="token number">600</span>net.ipv4.tcp_keepalive_probes <span class="token operator">=</span> <span class="token number">3</span>net.ipv4.tcp_keepalive_intvl <span class="token operator">=</span><span class="token number">15</span>net.ipv4.tcp_retries2 <span class="token operator">=</span> <span class="token number">5</span>net.ipv4.tcp_fin_timeout <span class="token operator">=</span> <span class="token number">2</span>net.ipv4.tcp_max_tw_buckets <span class="token operator">=</span> <span class="token number">36000</span>net.ipv4.tcp_tw_recycle <span class="token operator">=</span> <span class="token number">1</span>net.ipv4.tcp_tw_reuse <span class="token operator">=</span> <span class="token number">1</span>net.ipv4.tcp_max_orphans <span class="token operator">=</span> <span class="token number">32768</span>net.ipv4.tcp_syncookies <span class="token operator">=</span> <span class="token number">1</span>net.ipv4.tcp_max_syn_backlog <span class="token operator">=</span> <span class="token number">16384</span>net.ipv4.tcp_wmem <span class="token operator">=</span> <span class="token number">8192</span> <span class="token number">131072</span> <span class="token number">16777216</span>net.ipv4.tcp_rmem <span class="token operator">=</span> <span class="token number">32768</span> <span class="token number">131072</span> <span class="token number">16777216</span>net.ipv4.tcp_mem <span class="token operator">=</span> <span class="token number">786432</span> <span class="token number">1048576</span> <span class="token number">1572864</span>net.ipv4.ip_local_port_range <span class="token operator">=</span> <span class="token number">1024</span> <span class="token number">65000</span>net.ipv4.ip_conntrack_max <span class="token operator">=</span> <span class="token number">65536</span>net.ipv4.netfilter.ip_conntrack_max<span class="token operator">=</span><span class="token number">65536</span>net.ipv4.netfilter.ip_conntrack_tcp_timeout_established<span class="token operator">=</span><span class="token number">180</span>net.core.somaxconn <span class="token operator">=</span> <span class="token number">16384</span>net.core.netdev_max_backlog <span class="token operator">=</span> <span class="token number">16384</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-12-进程管理"><a href="#1-12-进程管理" class="headerlink" title="1.12 进程管理"></a>1.12 进程管理</h2><h3 id="1-12-1-Top命令"><a href="#1-12-1-Top命令" class="headerlink" title="1.12.1 Top命令"></a>1.12.1 Top命令</h3><p>实时占用的资源:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">top</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>top命令执行结果分为两个区域：<strong>统计信息区</strong>和<strong>进程信息区</strong></p><h4 id="统计信息区"><a href="#统计信息区" class="headerlink" title="统计信息区"></a>统计信息区</h4><p><strong>TOP：任务队列信息，与uptime命令执行结果相同.</strong></p><ul><li><code>15:33:39</code>：系统时间</li><li><code>up 5:40</code>：主机已运行时间</li><li><code>2 users</code>：用户连接数（不是用户数，who命令）</li><li><code>load average: 1.09, 1.04, 0.98</code>：系统平均负载，统计最近1，5，15分钟的系统平均负载</li></ul><p><strong>Tasks：进程信息</strong></p><ul><li><code>123 total</code>：进程总数</li><li><code>3 running</code>：正在运行的进程数</li><li><code>120 sleeping</code>：睡眠的进程数</li><li><code>0 stopped</code>：停止的进程数</li><li><code>0 zombie</code>：僵尸进程数</li></ul><p><strong>%CPU(s)：CPU信息（当有多个CPU时，这些内容可能会超过两行）</strong></p><ul><li><code>42.1 us</code>：用户空间所占CPU百分比</li><li><code>2.0 sy</code>：内核空间占用CPU百分比</li><li><code>0.0 ni</code>：用户进程空间内改变过优先级的进程占用CPU百分比</li><li><code>49.2 id</code>：空闲CPU百分比</li><li><code>0.0 wa</code>：等待输入输出的CPU时间百分比</li><li><code>6.0 hi</code>：硬件CPU终端占用百分比</li><li><code>0.7 si</code>：软中断占用百分比</li><li><code>0.0 st</code>：虚拟机占用百分比</li></ul><p><strong>KiB Mem：内存信息（与第五行的信息类似与free命令类似）</strong></p><ul><li><code>3780.9 total</code>：物理内存总量</li><li><code>727.4 free</code>：已使用的内存总量</li><li><code>668.8 used</code>：空闲的内存总量（free + userd = total）</li><li><code>2384.7 buff/cache</code>：用作内核缓存的内存量</li></ul><p><strong>KiB：swap信息</strong></p><ul><li><code>2048.0 total</code>：交换分区总量</li><li><code>2.0 used</code>：已使用的交换分区总量</li><li><code>2046.0 free</code>：空闲交换分区总量</li><li><code>859.6 avail</code>：缓冲的交换区总量，内存中的内容被换出到交换区，然后又被换入到内存，但是使用过的交换区没有被覆盖，交换区的这些内容已存在于内存中的交换区的大小，相应的内存再次被换出时可不必再对交换区写入。</li></ul><h4 id="进程信息区"><a href="#进程信息区" class="headerlink" title="进程信息区"></a>进程信息区</h4><ul><li>PID:进程id</li><li>USER:进程所有者的用户名</li><li>PR:优先级</li><li>NI:nice值。负值表示高优先级，正值表示低优先级</li><li>RES:进程使用的、未被换出的物理内存的大小</li><li>%CPU:上次更新到现在的CPU时间占用百分比</li><li>%MEM:进程使用的物理内存百分比</li><li>TIME+：进程所使用的CPU时间总计，单位1/100秒</li><li>COMMAND:命令名/行</li><li>PPID:父进程id</li><li>RUSER:Real user name（看了好多，都是这样写，也不知道和user有什么区别，欢迎补充此处）</li><li>UID:进程所有者的id</li><li>VIRT:进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</li><li>GROUP:进程所有者的组名</li><li>TTY:启动进程的终端名。不是从终端启动的进程则显示为?</li><li>NI:nice值。负值表示高优先级，正值表示低优先级</li><li>P:最后使用的CPU，仅在多CPU环境下有意义</li><li>TIME:进程使用的CPU时间总计，单位秒</li><li>SWAP:进程使用的虚拟内存中被被换出的大小</li><li>CODE:可执行代码占用的物理内存大小</li><li>DATA:可执行代码以外的部分（数据段+栈）占用的物理内存大小</li><li>SHR:共享内存大小</li><li>nFLT:页面错误次数</li><li>nDRT:最后一次写入到现在，被修改过的页面数</li><li>S:进程状态（D=不可中断的睡眠状态，R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程）</li><li>WCHAN:若该进程在睡眠，则显示睡眠中的系统函数名</li><li>Flags:任务标志</li></ul><h3 id="1-12-2-PS命令"><a href="#1-12-2-PS命令" class="headerlink" title="1.12.2 PS命令"></a>1.12.2 PS命令</h3><p>进程的状态：</p><ul><li> R 运行 runnable (on run queue) ，正在运行或在运行队列中等待)。</li><li> S 中断 sleeping，休眠中, 受阻, 在等待某个条件的形成或接受到信号。</li><li> D 不可中断 uninterruptible sleep (usually IO)，收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)</li><li> Z 僵死 a defunct (”zombie”) process，进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放。</li><li> T 停止 traced or stopped ，进程收到SIGSTOP，SIGSTP，SIGTIN，SIGTOU信号后停止运行运行。</li></ul><table><thead><tr><th>命令选项</th><th>说明</th></tr></thead><tbody><tr><td>a</td><td>显示所有进程</td></tr><tr><td>-a</td><td>显示一个终端的所有进程，除了会话引线</td></tr><tr><td>-A</td><td>显示所有进程，等同于-e</td></tr><tr><td>-m</td><td>显示所有的线程</td></tr><tr><td>-o</td><td>用户自定义格式</td></tr><tr><td>c</td><td>显示进程的真实名称</td></tr><tr><td>-e</td><td>显示所有进程，等于“-A”</td></tr><tr><td>e</td><td>显示环境变量</td></tr><tr><td>f</td><td>显示程序间的关系</td></tr><tr><td>-H</td><td>显示树状结构</td></tr><tr><td>r</td><td>显示当前终端的进程</td></tr><tr><td>T</td><td>显示与此终端关联的所有进程。等同于 t (不带任何参数)</td></tr><tr><td>u</td><td>指定用户的所有进程</td></tr><tr><td>-au</td><td>显示较详细的资讯</td></tr><tr><td>-aux</td><td>显示所有包含其他使用者的行程</td></tr><tr><td>-C&lt;命令&gt;</td><td>列出指定命令的状况</td></tr><tr><td>–lines&lt;行数&gt;</td><td>每页显示的行数</td></tr><tr><td>–width&lt;字符数&gt;</td><td>每页显示的字符数</td></tr><tr><td>–help</td><td>显示帮助信息</td></tr><tr><td>–version</td><td>显示版本显示</td></tr></tbody></table><p><strong>ps命令主要用途</strong></p><p>查看进程有没有启动<br>查看进程的pid并使用kill命令杀掉<br>查看哪些进程占用的cpu高<br>查看哪些进程占用内存高<br>查看进程的状态</p><p>ps命令，有两种形式一种是Linux形式（ps -ef），一种是unix形式(ps aux)，两种效果一样，aux结果展示更直观。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment"># 查看系统中所有进程，使用BSD操作系统格式</span><span class="token function">ps</span> aux选项：a：显示一个终端的所有进程，除了会话引线u：显示进程的归属用户及内存的使用情况x：显示没有控制终端的进程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>USER：该进程是由哪个用户产生的；</li><li>PID：进程的ID号；</li><li>%CPU：该进程占用CPU资源的百分比，占用越高，进程越耗费资源；</li><li>%MEM：该进程占用物理内存的百分比，占用越高，进程越耗费资源；</li><li>VSZ：该进程占用虚拟内存的大小，单位KB；</li><li>RSS：该进程占用实际物理内存的大小，单位KB；</li><li>TTY：该进程是在哪个终端中运行的。其中tty1-tty7代表本地控制台终端，tty1-tty6是本地的字符界面终端，tty7是图形终端。pts/0-255代表虚拟终端（现在不止256个）。？表示内核启动的</li><li>STAT：进程状态。常见的状态有R运行，S睡眠，T停止状态，s包含子进程，+位于后台</li><li>START：该进程的启动时间</li><li>TIME：该进程占用CPU的运算时间，注意不是系统时间</li><li>COMMAND：产生此进程的命令名</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 按cpu使用率降序显示</span><span class="token function">ps</span> -aux --sort -pcpu<span class="token comment"># 按内存使用率降序显示</span><span class="token function">ps</span> -aux --sort -pmem<span class="token comment"># 找出消耗内存最多的前10名进程</span><span class="token function">ps</span> -aux --sort -pcpu <span class="token operator">|</span> <span class="token function">head</span> -10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>常用的是ps -aux，然后再利用一个管道符号导向到grep去查找特定的进程，然后再对特定的进程进行操作。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment"># 查看指定进程pid(sshd)</span><span class="token function">ps</span> <span class="token operator">-</span>aux <span class="token punctuation">|</span> grep sshd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实际上，我们也能经常看到<code>ps -ef | grep java</code>，那么这两者什么时候用呢？</p><p><strong>ps -ef 和ps -aux使用</strong></p><p>如果想跟踪cpu占用率和内存占用率, 用aux；如果想跟踪父进程和完整的启动命令，那么使用ef。</p><p>查找指定进程</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">ps</span> <span class="token operator">-</span>ef <span class="token punctuation">|</span> grep 进程名<span class="token operator">/</span>PID<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>ps命令将某个进程显示出来，中间的 | 是管道命令，是指ps命令与grep命令同时进行。<br>grep是查找，是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。rep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看系统中所有进程，使用Linux标准命令格式</span><span class="token function">ps</span> -le选项：-l：长格式显示。显示更加详细的信息-e：显示所有进程，和-a作用一致最常使用的就是ps -ef <span class="token operator">|</span> <span class="token function">grep</span> 进程，查看当前系统的进程状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下这条命令是检查java 进程是否存在：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> javaroot     <span class="token number">29670</span> <span class="token number">16446</span>  <span class="token number">0</span> 01:11 pts/2    00:00:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto java<span class="token function">ps</span> -ef<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMDroot         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">5</span>月20 ?       00:00:02 /usr/lib/systemd/systemd --switched-root --system --deserialize <span class="token number">22</span>root         <span class="token number">2</span>     <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">5</span>月20 ?       00:00:00 <span class="token punctuation">[</span>kthreadd<span class="token punctuation">]</span>root         <span class="token number">4</span>     <span class="token number">2</span>  <span class="token number">0</span> <span class="token number">5</span>月20 ?       00:00:00 <span class="token punctuation">[</span>kworker/0:0H<span class="token punctuation">]</span>root         <span class="token number">6</span>     <span class="token number">2</span>  <span class="token number">0</span> <span class="token number">5</span>月20 ?       00:00:01 <span class="token punctuation">[</span>ksoftirqd/0<span class="token punctuation">]</span>root         <span class="token number">7</span>     <span class="token number">2</span>  <span class="token number">0</span> <span class="token number">5</span>月20 ?       00:00:01 <span class="token punctuation">[</span>migration/0<span class="token punctuation">]</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字段含义如下：</p><ul><li>UID：用户ID（User ID）</li><li>PID：进程ID（Process ID）</li><li>PPID：父进程的进程ID（Parent Process id）</li><li>C：CPU使用的资源百分比（CPU用户计算执行优先级的因子，数值越大CPU密集运算执行优先级越低）</li><li>STIME ：启动时间</li><li>TTY：与进程关联的终端（tty）（完整的终端名称）</li><li>TIME：进程使用的总cpu时间</li><li>CMD：正在执行的命令行命令</li></ul><p><strong>实例一</strong></p><p>1.可以用 | 管道和 more 连接起来分页查看命令：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">ps</span> <span class="token operator">-</span>aux <span class="token punctuation">|</span>more<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.把所有进程显示出来，并输出到ps001.txt文件命令：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">ps</span> <span class="token operator">-</span>aux &gt; ps001<span class="token punctuation">.</span>txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.输出指定的字段命令：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">ps</span> <span class="token operator">-</span>o pid<span class="token punctuation">,</span>ppid<span class="token punctuation">,</span>pgrp<span class="token punctuation">,</span>session<span class="token punctuation">,</span>tpgid<span class="token punctuation">,</span>comm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>实例二</strong></p><p>ps -aux默认是无序的，可以通过–sort命令来排序，如：按照cpu占用来降序排序：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">ps</span> <span class="token operator">-</span>aux <span class="token operator">--</span><span class="token function">sort</span> <span class="token operator">-</span>pcpu<span class="token punctuation">|</span>less <span class="token operator">-</span>N     <span class="token comment">#按照cpu占用来排序</span><span class="token function">ps</span> <span class="token operator">-</span>aux <span class="token operator">--</span><span class="token function">sort</span> <span class="token operator">-</span>pmem<span class="token punctuation">|</span>less <span class="token operator">-</span>N     <span class="token comment">#按照内存占用来排序</span><span class="token comment"># 查看进程的pid、启动时间、运行时间</span><span class="token function">ps</span> <span class="token operator">-</span>eo pid<span class="token punctuation">,</span>lstart<span class="token punctuation">,</span>etime <span class="token punctuation">|</span> grep <span class="token punctuation">[</span> pid <span class="token punctuation">]</span><span class="token comment"># 假如我们使用top命令看到PID为3356的进程占用CPU太高，那么，就可以使用以下命令来定位是哪些线程</span><span class="token function">ps</span> <span class="token operator">-</span><span class="token function">mp</span> 3356 <span class="token operator">-</span>o THREAD<span class="token punctuation">,</span>tid<span class="token punctuation">,</span>time <span class="token punctuation">|</span> more  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用ps命令实时查看进程<br>　　ps 命令会显示你系统当前的进程状态，但是这个结果是静态的。如果我们想要使用ps命令来实时查看进程状态，并且通过CPU和内存用量来对结果进行排序，并且希望结果能够每秒刷新1次，我们可以把ps命令和watch命令结合起来使用。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">watch <span class="token operator">-</span>n 1 <span class="token string">'ps -aux --sort -pcpu,+pmem | head -6'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解释一下这个命令：该命令每秒刷新1次，ps -aux会显示所有的进程，–sort -pcpu,+pmem 会使用CPU、内存来排序，head -6会显示前6行数据，即只看前5个进程情况，通过watch命令来做到每秒更新。</p><h3 id="1-12-3-kill命令"><a href="#1-12-3-kill命令" class="headerlink" title="1.12.3 kill命令"></a>1.12.3 kill命令</h3><p>在Linux系统中，kill命令用于向运行中的进程发送信号，默认发送的信号是终止信号，会请求进程退出。kill（杀）可能会引起误解，实际上发送的信号可能与杀死进程无关。</p><p><strong>我们最常使用到的kill命令为：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">kill</span> PID<span class="token function">kill</span> -9 PID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>前者为请求目标进程退出，后者为强制杀死目标进程。</p><p><strong>1. kill PID</strong></p><p>kill命令默认发送的信号是SIGTERM。该信号会被目标进程捕获，在收到这个信号以后目标进程可以做一些有用的操作（如保存数据），然后退出。然而，许多进程并没有专门实现处理此信号的程序，此时会调用默认的信号处理函数。而在某些情况下，有特殊处理程序的进程也会出错，无法正确处理信号。总之，SIGTERM信号不能确保目标进程能够退出。</p><p><strong>SIGTERM信号的编号通常为15，可通过以下四种方式发送SIGTERM信号：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">kill</span> PID<span class="token function">kill</span> -s <span class="token environment constant">TERM</span> PID<span class="token function">kill</span> -<span class="token environment constant">TERM</span> PID<span class="token function">kill</span> -15 PID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. kill -9 PID</strong></p><p>此时发送的是SIGKILL信号。正如前文所述，SIGTERM信号不一定能够“杀死”目标进程，在这种情况下，我们就会释放大杀器，SKGKILL信号。SIGKILL信号不会被进程所“截获”，它只能由主机系统内核处理，由其负责提供可靠的控制进程执行的方法，SIGKILL会杀死进程。</p><p><strong>SIGKILL信号的编号通常为9，可通过三种方式发送SIGKILL信号：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">kill</span> -s KILL PID<span class="token function">kill</span> -KILL PID<span class="token function">kill</span> -9 PID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 其他kill信号</strong></p><p>​        kill命令可以发送的信号还有很多，其它有用的信号包括HUP、TRAP、INT、SEGV及ALRM等。</p><p>​        HUP发送SIGHUP信号，SIGHUP信号的意思为挂起。在规范上，进程应当在收到这个信号时重新加载配置，相当于重启。但在实际使用中，通常只有守护进程会按照规范实施，而普通进程则是执行退出。</p><p>​        INT发送SIGINT信号，意为中断，在终端中，只需按下CTRL+C便可以产生SIGINT信号。</p><p>​        在终端中，CTRL+Z通常映射至SIGTSTP，CTRL+\（反斜杠）映射至SIGQUIT，这可强制程序进行核心转储。</p><p><strong>kill能确保杀死进程吗？</strong></p><p>答案是否定的，某些情况下即使kill -9也无法杀死进程。</p><p><strong>1. 用户授权</strong></p><p>UNIX提供了安全机制，以防止未授权用户杀死其他进程。实际上，若进程欲向另一个进程发送信号，发送信号的进程的所有者必须与接收信号的进程的所有者相同，或者发送信号的进程的所有者是超级用户root。</p><p>例如，假设当前终端的用户是dancen，则无法kill掉用户nginx启动的进程。</p><p><strong>2. 超级进程</strong></p><p>即使root用户也无法向PID为1的进程发送信号。内核初始化的最后一步就是启动init进程。这个进程是系统的第一个进程，PID为1，又叫超级进程，也叫根进程。它负责产生其他所有用户进程。所有的进程都会被挂在这个进程下，如果这个进程退出了，那么所有的进程都被kill。如果一个子进程的父进程退了，那么这个子进程会被挂到PID 1下面，即PPID为1。</p><p><strong>3. 内核态进程</strong></p><p>当一个进程执行系统调用而陷入内核代码中执行时，该进程由用户态转为内核态，处于内核态的进程将忽略所有信号处理。如果进程在执行系统调用时无限期地阻塞，则可能无法终止该进程。</p><p><strong>4. 僵尸进程</strong></p><p>进程停止后，该进程就会从进程列表中移除。但是，有时候有些进程即使执行完了也依然留在进程列表中。这些完成了生命周期但却依然留在进程列表中的进程，我们称之为 “僵尸进程”。</p><p><strong>a. 僵尸进程的产生</strong></p><p>一个进程可能会产生很多子进程。这些子进程执行完毕后会发送一个Exit信号然后死掉。这个Exit信号需要被父进程所读取。父进程随后调用wait命令来读取子进程的退出状态，并将子进程从进程列表中移除。但若父进程未能读取到子进程的Exit信号，则这个子进程不会从进程列表中删掉。</p><p><strong>b. 找出僵尸进程</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> Z<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>c. kill僵尸进程</strong></p><p>我们可以分别通过SIGTERM信号、SIGKILL信号、SIGHUP信号来尝试kill僵尸进程。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">kill</span> PID<span class="token function">kill</span> -9 PID<span class="token function">kill</span> -HUP PID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果僵尸进程没能kill掉，则可查看僵尸进程的PPID，找到父进程，令其回收子进程；如果无效，则可直接kill掉僵尸进程的父进程，父进程死后，僵尸进程成为”孤儿进程”，过继给1号进程init，由init负责清理僵尸进程。</p><p>方法一，传递信号给父进程，命令其回收子进程的资源</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">kill</span> -CHLD <span class="token environment constant">PPID</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方法二，直接kill父进程，将此进程变成孤儿进程，交给init进程管理，由init进程回收此进程的资源</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">kill</span> -9 <span class="token environment constant">PPID</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>5. 自我保护的进程</strong></p><p>例如，在执行硬盘扩展时，需要将硬盘卸载，但在执行umount命令时，提示设备忙。</p><p><strong>a. 找出正在使用设备的进程</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># fuser -mv /mnt/volume1/</span>                     <span class="token environment constant">USER</span>        PID ACCESS COMMAND/mnt/volume1:        root     kernel <span class="token function">mount</span> /mnt/volume1                     root      <span class="token number">10516</span> f<span class="token punctuation">..</span><span class="token punctuation">..</span> AliYunDun<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>结果显示名为AliYunDun的进程占用了设备。</p><p><strong>b. kill AliYunDun进程1</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># kill 10516</span>bash: kill: <span class="token punctuation">(</span><span class="token number">10516</span><span class="token punctuation">)</span> - Operation not permitted<span class="token comment"># kill -9 10516</span>bash: kill: <span class="token punctuation">(</span><span class="token number">10516</span><span class="token punctuation">)</span> - Operation not permitted<span class="token comment"># sudo kill -9 10516</span>kill: sending signal to <span class="token number">10516</span> failed: Operation not permitted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>AliYunDun是阿里云安全中心的客户端代理，为了防止被恶意kill，具有自我保护功能，在kill该进程时，提示没有权限，并且收到了阿里云的告警。</p><p><strong>c. kill AliYunDun进程2</strong></p><p>暂时不知道AliYunDun自我保护功能的实现原理，但该进程可以通过 HUP信号kill掉。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">kill</span> -HUP <span class="token number">1051</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux服务</title>
      <link href="/2023/10/10/linux-fu-wu/"/>
      <url>/2023/10/10/linux-fu-wu/</url>
      
        <content type="html"><![CDATA[<h2 id="contOS更换yum源"><a href="#contOS更换yum源" class="headerlink" title="contOS更换yum源"></a>contOS更换yum源</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># yum install wget -y</span><span class="token comment"># 进入yum配置文件目录（固定的）</span><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># cd /etc/yum.repos.d/</span><span class="token comment"># 备份CentOS-Base.repo文件</span><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># mv CentOS-Base.repo CentOS-Base.repo.bak</span><span class="token comment"># 通过wget工具，从阿里云获取配置文件</span><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><span class="token comment"># 清空yum本地缓存</span><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># yum clean all</span><span class="token comment"># 制作aliyun缓存</span><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># yum makecache</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="一、动态主机配置协议DHCP"><a href="#一、动态主机配置协议DHCP" class="headerlink" title="一、动态主机配置协议DHCP"></a>一、动态主机配置协议DHCP</h1><h2 id="1-1-防火墙和selinux设置"><a href="#1-1-防火墙和selinux设置" class="headerlink" title="1.1 防火墙和selinux设置"></a>1.1 防火墙和selinux设置</h2><p><strong>防火墙</strong>     影响通信       默认拒绝所有      只允许 远程登录 和  DHCP客户端通信</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># systemctl stop firewalld.service</span><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># systemctl disable firewalld.service</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>selinux</strong>  美国NSA国家安全局设计    将Linux中的文件分类并进行标签，让不同的网络服务只能访问自己的文件，而拒绝访问其他文件。单个服务被攻陷时，不会造成数据全部泄露</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># vim /etc/selinux/config</span><span class="token comment"># SELINUX=enforcing</span><span class="token assign-left variable">SELINUX</span><span class="token operator">=</span>disable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查看状态</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># systemctl status firewalld.service</span>● firewalld.service - firewalld - dynamic firewall daemon   Loaded: loaded <span class="token punctuation">(</span>/usr/lib/systemd/system/firewalld.service<span class="token punctuation">;</span> disabled<span class="token punctuation">;</span> vendor preset: enabled<span class="token punctuation">)</span>   Active: inactive <span class="token punctuation">(</span>dead<span class="token punctuation">)</span>     Docs: man:firewalld<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># getenforce</span>Disabled<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2-DHCP工作原理"><a href="#1-2-DHCP工作原理" class="headerlink" title="1.2 DHCP工作原理"></a>1.2 DHCP工作原理</h2><h3 id="1-2-1-工作方式"><a href="#1-2-1-工作方式" class="headerlink" title="1.2.1 工作方式"></a>1.2.1 工作方式</h3><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/DHCP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="image-20231010125635995"></p><ul><li>Client：向网络中发送广播，通过自己的UDP协议的68号端口向网络中发送DHCP Discover包，用来寻找网络中的DHCP Server。</li><li>Server：局域网中的所有DHCP服务器都能收到该Client发送的广播包，然后DHCP Server会检查自己的IP池中(也叫做作用域)是否还有可用IP可以分发。<ul><li>如果有，直接将这个IP地址从池中拿出来，避免在发给别的客户端，并且通过自己的UDP协议的67号端口给Client发一个响应包DHCP Offer，同样采用广播，明确告诉其可以提供哪个IP给Client使用。</li></ul></li><li>Client：Client会收到局域网中的所有DHCP服务器发给自己的DHCP Offer包，默认选一个最优的DHCP Server进行IP获取(在这里就是第一个发送给他DHCP Offer的服务器算作最优)。然后继续向网络中通过UDP的68号端口发广播DHCP Resquest，明确指定DHCP Server IP地址和需要租用的IP地址告诉它要从他这里获得IP信息。自然其他DHCP Server也能收到广播，确认不从自己这里拿IP信息后，会将上步从IP池中拿出来的IP在释放到池中，以便别人使用。</li><li>Server：被确认的DHCP Server就会通过其UDP协议的67号端口发送DHCP ACK确认包，采用广播将IP、掩码、网关、DNS等信息还有IP租约一起发送给DHCP Client, Client确认IP可用后，根据IP租约开始计算使用时间。</li></ul><h3 id="1-2-2-计算机获取IP的时间点"><a href="#1-2-2-计算机获取IP的时间点" class="headerlink" title="1.2.2 计算机获取IP的时间点"></a>1.2.2 计算机获取IP的时间点</h3><ul><li>计算机开机</li><li>网卡接通服务</li><li>重启网卡服务</li></ul><h3 id="1-2-3-租约更新阶段"><a href="#1-2-3-租约更新阶段" class="headerlink" title="1.2.3 租约更新阶段"></a>1.2.3 租约更新阶段</h3><ul><li>租约完成1/2</li><li>租约完成7/8</li><li>租约到期</li></ul><h1 id="二、DHCP-部署"><a href="#二、DHCP-部署" class="headerlink" title="二、DHCP 部署"></a>二、DHCP 部署</h1><h2 id="2-1-server端配置："><a href="#2-1-server端配置：" class="headerlink" title="2.1 server端配置："></a>2.1 server端配置：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 安装dhcp</span><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># yum install dhcp -y</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="查看主配文件"><a href="#查看主配文件" class="headerlink" title="查看主配文件"></a>查看主配文件</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看主配文件</span><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># ls</span>dhclient.d  dhclient-exit-hooks.d  dhcpd6.conf  dhcpd.conf  scripts<span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># cat dhcpd.conf </span><span class="token comment">#</span><span class="token comment"># DHCP Server Configuration file.</span><span class="token comment">#   see /usr/share/doc/dhcp*/dhcpd.conf.example</span><span class="token comment">#   see dhcpd.conf(5) man page</span><span class="token comment">#</span><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># cp /usr/share/doc/dhcp*/dhcpd.conf.example /etc/dhcp/dhcpd.conf</span>cp：是否覆盖<span class="token string">"/etc/dhcp/dhcpd.conf"</span>？ y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="主配文件内容"><a href="#主配文件内容" class="headerlink" title="主配文件内容"></a>主配文件内容</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># cat dhcpd.conf </span><span class="token comment"># dhcpd.conf</span><span class="token comment">#</span><span class="token comment"># Sample configuration file for ISC dhcpd</span><span class="token comment">#</span><span class="token comment">#DNS全局选项，指定DNS服务器的地址，可以是IP，也可以是域名。</span><span class="token comment"># option definitions common to all supported networks...</span><span class="token comment"># DNS的域名</span>option domain-name <span class="token string">"example.org"</span><span class="token punctuation">;</span><span class="token comment">#具体的DNS服务器</span>option domain-name-servers ns1.example.org, ns2.example.org<span class="token punctuation">;</span><span class="token comment">#默认租约为600s</span>default-lease-time <span class="token number">600</span><span class="token punctuation">;</span><span class="token comment">#最大租约为7200s，客户机会在default-lease-time快到期时向服务器续租，如果此时客户机死机/重启，而默认租约时间到期了，服务器并不会立即回收IP地址，而是等到最大租约时间到期，客户机还没有过来续约，才会回收IP地址。</span>max-lease-time <span class="token number">7200</span><span class="token punctuation">;</span><span class="token comment">#动态DNS更新方式(none:不支持；interim:互动更新模式；ad-hoc:特殊更新模式)</span><span class="token comment"># Use this to enble / disable dynamic dns updates globally.</span><span class="token comment">#ddns-update-style none;</span><span class="token comment">#如果该DHCP服务器是本地官方DHCP就将此选项打开，避免其他DHCP服务器的干扰。</span><span class="token comment">#当一个客户端试图获得一个不是该DHCP服务器分配的IP信息，DHCP将发送一个拒绝消息，而不会等待请求超时。当请求被拒绝，客户端会重新向当前DHCP发送IP请求获得新地址。保证IP是自己发出去的</span><span class="token comment">#</span><span class="token comment"># If this DHCP server is the official DHCP server for the local</span><span class="token comment"># network, the authoritative directive should be uncommented.</span><span class="token comment">#authoritative;</span><span class="token comment"># Use this to send dhcp log messages to a different log file (you also</span><span class="token comment"># have to hack syslog.conf to complete the redirection).</span><span class="token comment"># 日志级别为local17</span>log-facility local7<span class="token punctuation">;</span><span class="token comment"># No service will be given on this subnet, but declaring it helps the </span><span class="token comment"># DHCP server to understand the network topology.</span><span class="token comment">#作用域相关设置指令</span><span class="token comment">#subnet 定义一个作用域（发送的ip地址范围）</span><span class="token comment">#netmask 定义作用域的掩码</span><span class="token comment">#range 允许发放的IP范围</span><span class="token comment">#option routers 指定网关地址</span><span class="token comment">#option domain-name-servers 指定DNS服务器地址</span><span class="token comment">#option broadcast-address 广播地址</span><span class="token comment">#</span><span class="token comment">#</span><span class="token comment">#案例:定义一个作用域 网段为10.152.187.0 掩码为255.255.255.0</span><span class="token comment">#此作用域不提供任何服务</span>subnet <span class="token number">10.152</span>.187.0 netmask <span class="token number">255.255</span>.255.0 <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment"># This is a very basic subnet declaration.</span><span class="token comment">#案例:定义一个基本的作用域</span><span class="token comment">#网段10.254.239.0 掩码255.255.255.224</span><span class="token comment">#分发范围10.254.239.10-20</span><span class="token comment">#网关为rtr-239-0-1.example.org, rtr-239-0-2.example.org</span>subnet <span class="token number">10.254</span>.239.0 netmask <span class="token number">255.255</span>.255.224 <span class="token punctuation">{</span>  range <span class="token number">10.254</span>.239.10 <span class="token number">10.254</span>.239.20<span class="token punctuation">;</span>  option routers rtr-239-0-1.example.org, rtr-239-0-2.example.org<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment"># This declaration allows BOOTP clients to get dynamic addresses,</span><span class="token comment"># which we don't really recommend.</span><span class="token comment">#案例:允许采用bootp协议的客户端动态获得地址</span><span class="token comment">#bootp DHCP的前身</span><span class="token comment">#BOOTP用于无盘工作站的局域网中，可以让无盘工作站从一个中心服务器上获得IP地址。通过BOOTP协议可以为局域网中的无盘工作站分配动态IP地址，</span><span class="token comment">#这样就不需要管理员去为每个用户去设置静态IP地址。</span>subnet <span class="token number">10.254</span>.239.32 netmask <span class="token number">255.255</span>.255.224 <span class="token punctuation">{</span>  range dynamic-bootp <span class="token number">10.254</span>.239.40 <span class="token number">10.254</span>.239.60<span class="token punctuation">;</span>  option broadcast-address <span class="token number">10.254</span>.239.31<span class="token punctuation">;</span>  option routers rtr-239-32-1.example.org<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">#案例:一个简单的作用域案例</span><span class="token comment"># A slightly different configuration for an internal subnet.</span>subnet <span class="token number">10.5</span>.5.0 netmask <span class="token number">255.255</span>.255.224 <span class="token punctuation">{</span>  range <span class="token number">10.5</span>.5.26 <span class="token number">10.5</span>.5.30<span class="token punctuation">;</span>  option domain-name-servers ns1.internal.example.org<span class="token punctuation">;</span>  option domain-name <span class="token string">"internal.example.org"</span><span class="token punctuation">;</span>  option routers <span class="token number">10.5</span>.5.1<span class="token punctuation">;</span>  option broadcast-address <span class="token number">10.5</span>.5.31<span class="token punctuation">;</span>  default-lease-time <span class="token number">600</span><span class="token punctuation">;</span>  max-lease-time <span class="token number">7200</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment"># Hosts which require special configuration options can be listed in</span><span class="token comment"># host statements.   If no address is specified, the address will be</span><span class="token comment"># allocated dynamically (if possible), but the host-specific information</span><span class="token comment"># will still come from the host declaration.</span><span class="token comment">#</span><span class="token comment">#保留地址:可以将指定的IP分发给指定的机器，根据网卡的MAC地址来做触发</span><span class="token comment">#host: 启用保留。</span><span class="token comment">#hardware:指定客户端的mac地址</span><span class="token comment">#filename:指定文件名</span><span class="token comment">#server-name:指定下一跳服务器地址</span><span class="token comment">#fixed-address: 指定保留IP地址</span><span class="token comment">#</span><span class="token comment">#</span><span class="token comment">#案例:这个案例中分发给客户端的不是IP地址信息，而是告诉客户端去找toccata.fugue.com服务器，并且下载vmunix.passacaglia文件</span><span class="token function">host</span> passacaglia <span class="token punctuation">{</span>  hardware ethernet <span class="token number">0</span>:0:c0:5d:bd:95<span class="token punctuation">;</span>  filename <span class="token string">"vmunix.passacaglia"</span><span class="token punctuation">;</span>  server-name <span class="token string">"toccata.fugue.com"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment"># Fixed IP addresses can also be specified for hosts.   These addresses</span><span class="token comment"># should not also be listed as being available for dynamic assignment.</span><span class="token comment"># Hosts for which fixed IP addresses have been specified can boot using</span><span class="token comment"># BOOTP or DHCP.   Hosts for which no fixed address is specified can only</span><span class="token comment"># be booted with DHCP, unless there is an address range on the subnet</span><span class="token comment"># to which a BOOTP client is connected which has the dynamic-bootp flag</span><span class="token comment"># set.</span><span class="token comment"># 案例:保留地址，将指定IP(fantasia.fugue.com对应的IP)分给指定客户端网卡(MAC:08:00:07:26:c0:a5)</span><span class="token function">host</span> fantasia <span class="token punctuation">{</span>  hardware ethernet 08:00:07:26:c0:a5<span class="token punctuation">;</span>  fixed-address fantasia.fugue.com<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">#超级作用域</span><span class="token comment">#超级作用域是DHCP服务中的一种管理功能，使用超级作用域，可以将多个作用域组合为单个管理实体。</span><span class="token comment"># You can declare a class of clients and then do address allocation</span><span class="token comment"># based on that.   The example below shows a case where all clients</span><span class="token comment"># in a certain class get addresses on the 10.17.224/24 subnet, and all</span><span class="token comment"># other clients get addresses on the 10.0.29/24 subnet.</span><span class="token comment">#在局域网中，可以配置策略根据各个机器的具体信息分配IP地址和其他的网络参数，客户机的具体信息：客户机能够给dhcp服务提供的信息由有两个，</span><span class="token comment">#第一个就是网卡的dhcp-client-identifier（mac地址），</span><span class="token comment">#第二个就是设备的vendor-class-identifier。</span><span class="token comment">#管理员可以根据这两个信息给不同的机器分组。</span><span class="token comment">#案例:</span><span class="token comment">#按client某种类型分组DHCP,而不是按物理接口网段</span><span class="token comment">#例子: SUNW 分配地址段10.17.224.0/24</span><span class="token comment"># 非SUNW的主机,分配地址段10.0.29.0/24</span><span class="token comment">#定义一个dhcp类:foo</span><span class="token comment">#request广播中vendor-class-identifier字段对应的值前四个字节如果是"SUNW",则视合法客户端.</span>class <span class="token string">"foo"</span> <span class="token punctuation">{</span>  match <span class="token keyword">if</span> substring <span class="token punctuation">(</span>option vendor-class-identifier, <span class="token number">0</span>, <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"SUNW"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">#定义一个超级作用域: 224-29</span>shared-network <span class="token number">224</span>-29 <span class="token punctuation">{</span><span class="token comment">#定义第一个作用域</span>  subnet <span class="token number">10.17</span>.224.0 netmask <span class="token number">255.255</span>.255.0 <span class="token punctuation">{</span>    option routers rtr-224.example.org<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token comment">#定义第二个作用域</span>  subnet <span class="token number">10.0</span>.29.0 netmask <span class="token number">255.255</span>.255.0 <span class="token punctuation">{</span>    option routers rtr-29.example.org<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token comment">#关连池,如果客户端匹配foo类，将获得该池地址</span>  pool <span class="token punctuation">{</span>    allow members of <span class="token string">"foo"</span><span class="token punctuation">;</span>    range <span class="token number">10.17</span>.224.10 <span class="token number">10.17</span>.224.250<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token comment">#关连池,如果客户端配置foo类，则拒绝获得该段地址</span>  pool <span class="token punctuation">{</span>    deny members of <span class="token string">"foo"</span><span class="token punctuation">;</span>    range <span class="token number">10.0</span>.29.10 <span class="token number">10.0</span>.29.230<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-DHCP启动"><a href="#2-2-DHCP启动" class="headerlink" title="2.2 DHCP启动"></a>2.2 DHCP启动</h2><p>启动DHCP服务：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># systemctl enable dhcpd</span>Created symlink from /etc/systemd/system/multi-user.target.wants/dhcpd.service to /usr/lib/systemd/system/dhcpd.service.<span class="token comment"># 没有有效作用域，即没有和服务器本地网段相同网段的作用域，因此无法启动</span><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># systemctl start dhcpd</span>Job <span class="token keyword">for</span> dhcpd.service failed because the control process exited with error code. See <span class="token string">"systemctl status dhcpd.service"</span> and <span class="token string">"journalctl -xe"</span> <span class="token keyword">for</span> details.<span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># vim dhcpd.conf</span><span class="token punctuation">..</span>.<span class="token comment"># 设置与本地网段相同的作用域</span>  subnet <span class="token number">192.168</span>.133.0 netmask <span class="token number">255.255</span>.255.0 <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">..</span>.<span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># systemctl start dhcpd</span><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># lsof -i :67</span>COMMAND  PID   <span class="token environment constant">USER</span>   FD   TYPE DEVICE SIZE/OFF NODE NAMEdnsmasq <span class="token number">1488</span> nobody    3u  IPv4  <span class="token number">29621</span>      0t0  UDP *:bootps dhcpd   <span class="token number">6035</span>  dhcpd    7u  IPv4  <span class="token number">72692</span>      0t0  UDP *:bootps <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-3-作用域"><a href="#2-3-作用域" class="headerlink" title="2.3 作用域"></a>2.3 作用域</h2><p>修改配置文件，设置作用域：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># vim dhcpd.conf </span><span class="token comment"># If this DHCP server is the official DHCP server for the local</span><span class="token comment"># network, the authoritative directive should be uncommented.</span>authoritative<span class="token punctuation">;</span><span class="token comment"># A slightly different configuration for an internal subnet.</span>subnet <span class="token number">192.168</span>.133.0 netmask <span class="token number">255.255</span>.255.0 <span class="token punctuation">{</span>  range <span class="token number">192.168</span>.133.153 <span class="token number">192.168</span>.133.252<span class="token punctuation">;</span>  option domain-name-servers <span class="token number">202.106</span>.0.20, <span class="token number">114.114</span>.114.114<span class="token punctuation">;</span>  option routers <span class="token number">192.168</span>.133.254<span class="token punctuation">;</span>  option broadcast-address <span class="token number">192.168</span>.11.255<span class="token punctuation">;</span>  default-lease-time <span class="token number">7200</span><span class="token punctuation">;</span>  max-lease-time <span class="token number">10800</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启dhcp服务，生效配置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># systemctl restart dhcpd</span><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># lsof -i :67</span>COMMAND  PID   <span class="token environment constant">USER</span>   FD   TYPE DEVICE SIZE/OFF NODE NAMEdnsmasq <span class="token number">1488</span> nobody    3u  IPv4  <span class="token number">29621</span>      0t0  UDP *:bootps dhcpd   <span class="token number">6292</span>  dhcpd    7u  IPv4  <span class="token number">60915</span>      0t0  UDP *:bootps <span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># lsof -i :68</span>COMMAND   PID <span class="token environment constant">USER</span>   FD   TYPE DEVICE SIZE/OFF NODE NAMEdhclient <span class="token number">4183</span> root    6u  IPv4  <span class="token number">52360</span>      0t0  UDP *:bootpc <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-4-client端"><a href="#2-4-client端" class="headerlink" title="2.4 client端"></a>2.4 client端</h2><p>查看一下当前eth0的IP地址、MAC地址，并保证其IP获得方式为:DHCP：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@test 桌面<span class="token punctuation">]</span><span class="token comment"># ifconfig eth0</span>eth0      Link encap:Ethernet  HWaddr 00:0C:29:1A:F8:BD            inet addr:172.16.44.132  Bcast:172.16.44.255  Mask:255.255.255.0          inet6 addr: fe80::20c:29ff:fe1a:f8bd/64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:86 errors:0 dropped:0 overruns:0 frame:0          TX packets:63 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000           RX bytes:15294 <span class="token punctuation">(</span><span class="token number">14.9</span> KiB<span class="token punctuation">)</span>  TX bytes:6769 <span class="token punctuation">(</span><span class="token number">6.6</span> KiB<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用dhclient命令来获得IP，查看重要输出:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@test 桌面<span class="token punctuation">]</span><span class="token comment"># dhclient -d eth0</span>Internet Systems Consortium DHCP Client <span class="token number">4.1</span>.1-P1Copyright <span class="token number">2004</span>-2010 Internet Systems Consortium.All rights reserved.For info, please visit https://www.isc.org/software/dhcp/Listening on LPF/eth0/00:0c:29:1a:f8:bdSending on   LPF/eth0/00:0c:29:1a:f8:bdSending on   Socket/fallbackDHCPDISCOVER on eth0 to <span class="token number">255.255</span>.255.255 port <span class="token number">67</span> interval <span class="token number">6</span> <span class="token punctuation">(</span>xid<span class="token operator">=</span>0x316768c3<span class="token punctuation">)</span>      发广播寻找DHCP服务器DHCPOFFER from <span class="token number">192.168</span>.11.16                                                     <span class="token number">192.168</span>.11.16DHCP服务器应答DHCPREQUEST on eth0 to <span class="token number">255.255</span>.255.255 port <span class="token number">67</span> <span class="token punctuation">(</span>xid<span class="token operator">=</span>0x316768c3<span class="token punctuation">)</span>                  client向服务器请求IP地址DHCPACK from <span class="token number">192.168</span>.11.16 <span class="token punctuation">(</span>xid<span class="token operator">=</span>0x316768c3<span class="token punctuation">)</span>                                      确认租赁关系bound to <span class="token number">192.168</span>.11.156 -- renewal <span class="token keyword">in</span> <span class="token number">2983</span> seconds.                              client分得IP:192.168.11.156注意：看到这些信息后，按CTRL+C退出。dhclient是一个DHCP协议客户端，它使用DHCP协议或者BOOTP协议或在这两个协议都不可用时使用静态地址来配置一个或多个网络接口dhclient -r 释放IP地址dhclient -d 强制dhclient作为前台进程运行。 通常情况下，DHCP客户端将在前台运行,直到配置了一个接口,此时它将恢复为在后            台运行。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>服务器日志查看验证获取信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># tailf /var/log/messages</span>Feb <span class="token number">21</span> <span class="token number">13</span>:40:44 baism dhcpd: DHCPDISCOVER from 00:0c:29:1a:f8:bd via ens33Feb <span class="token number">21</span> <span class="token number">13</span>:40:45 baism dhcpd: DHCPOFFER on <span class="token number">192.168</span>.11.156 to 00:0c:29:1a:f8:bd via ens33Feb <span class="token number">21</span> <span class="token number">13</span>:40:45 baism dhcpd: DHCPREQUEST <span class="token keyword">for</span> <span class="token number">192.168</span>.11.156 <span class="token punctuation">(</span><span class="token number">192.168</span>.11.16<span class="token punctuation">)</span> from 00:0c:29:1a:f8:bd via ens33Feb <span class="token number">21</span> <span class="token number">13</span>:40:45 baism dhcpd: DHCPACK on <span class="token number">192.168</span>.11.156 to 00:0c:29:1a:f8:bd via ens33<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在client上通过ifconfig命令再次查看eth0 IP地址，验证是否为192.168.11.156：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@test 桌面<span class="token punctuation">]</span><span class="token comment"># ifconfig eth0</span>eth0      Link encap:Ethernet  HWaddr 00:0C:29:1A:F8:BD            inet addr:192.168.11.156  Bcast:192.168.11.255  Mask:255.255.255.0          inet6 addr: fe80::20c:29ff:fe1a:f8bd/64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:97 errors:0 dropped:0 overruns:0 frame:0          TX packets:67 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000           RX bytes:17364 <span class="token punctuation">(</span><span class="token number">16.9</span> KiB<span class="token punctuation">)</span>  TX bytes:7537 <span class="token punctuation">(</span><span class="token number">7.3</span> KiB<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看网关，确定网关为192.168.11.254：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@test 桌面<span class="token punctuation">]</span><span class="token comment"># route -n</span>Kernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Iface<span class="token number">192.168</span>.11.0    <span class="token number">0.0</span>.0.0         <span class="token number">255.255</span>.255.0   U     <span class="token number">0</span>      <span class="token number">0</span>        <span class="token number">0</span> eth1<span class="token number">192.168</span>.11.0    <span class="token number">0.0</span>.0.0         <span class="token number">255.255</span>.255.0   U     <span class="token number">0</span>      <span class="token number">0</span>        <span class="token number">0</span> eth0<span class="token number">169.254</span>.0.0     <span class="token number">0.0</span>.0.0         <span class="token number">255.255</span>.0.0     U     <span class="token number">1003</span>   <span class="token number">0</span>        <span class="token number">0</span> eth1<span class="token number">0.0</span>.0.0         <span class="token number">192.168</span>.11.254  <span class="token number">0.0</span>.0.0         UG    <span class="token number">0</span>      <span class="token number">0</span>        <span class="token number">0</span> eth0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看DNS配置文件，看DNS是否为DHCP服务器发放的DNS服务器IP：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@test 桌面<span class="token punctuation">]</span><span class="token comment"># cat /etc/resolv.conf </span><span class="token punctuation">;</span> generated by /sbin/dhclient-scriptnameserver <span class="token number">202.106</span>.0.20nameserver <span class="token number">114.114</span>.114.114<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-5-查看具体租约"><a href="#2-5-查看具体租约" class="headerlink" title="2.5 查看具体租约"></a>2.5 查看具体租约</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># cat /var/lib/dhcpd/dhcpd.leases</span><span class="token comment"># The format of this file is documented in the dhcpd.leases(5) manual page.</span><span class="token comment"># This lease file was written by isc-dhcp-4.2.5</span>server-duid <span class="token string">"<span class="token entity" title="\000">\000</span><span class="token entity" title="\001">\001</span><span class="token entity" title="\000">\000</span><span class="token entity" title="\001">\001</span>,<span class="token entity" title="\267">\267</span><span class="token entity" title="\234">\234</span><span class="token entity" title="\316">\316</span><span class="token entity" title="\000">\000</span><span class="token entity" title="\014">\014</span>)<span class="token entity" title="\211">\211</span><span class="token entity" title="\270">\270</span><span class="token entity" title="\352">\352</span>"</span><span class="token punctuation">;</span>lease <span class="token number">192.168</span>.133.153 <span class="token punctuation">{</span>  starts <span class="token number">2</span> <span class="token number">2023</span>/10/14 04:21:04<span class="token punctuation">;</span><span class="token comment">#开始时间</span>  ends <span class="token number">2</span> <span class="token number">2023</span>/10/14 06:21:04<span class="token punctuation">;</span><span class="token comment">#结束时间</span>  cltt <span class="token number">2</span> <span class="token number">2023</span>/10/14 04:21:04<span class="token punctuation">;</span>  binding state active<span class="token punctuation">;</span>  next binding state <span class="token function">free</span><span class="token punctuation">;</span>  rewind binding state <span class="token function">free</span><span class="token punctuation">;</span>  hardware ethernet 00:0c:29:6d:1c:b3<span class="token punctuation">;</span>  uid <span class="token string">"<span class="token entity" title="\001">\001</span><span class="token entity" title="\000">\000</span><span class="token entity" title="\014">\014</span>)m<span class="token entity" title="\034">\034</span><span class="token entity" title="\263">\263</span>"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-6、保留IP"><a href="#2-6、保留IP" class="headerlink" title="2.6、保留IP"></a>2.6、保留IP</h2><p>​    在IP租约到期后，如果无法续订租约，client只能乖乖交出IP地址，重新获得一个其他IP使用。但是在公司有些服务器的IP地址是不能变化的，因为变了用户就无法连接到服务器了，比如公司文件服务器、打印服务器等等。那么在这种环境中我们既想使用DHCP管理公司IP，又想实现部分机器的IP永久不变，那么怎么实现呢。</p><p>​    DHCP的作者在写DHCP的时候也想到了这个问题，提出了保留IP的概念，就是将某些IP保留，然后服务器来获得IP的时候，根据其MAC地址做匹配，将对应的IP分给它即可。</p><p><strong>案例</strong>：</p><p>在配置文件/etc/dhcp/dhcpd.conf末尾添加以下内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># host print    host为指令，print是个名字</span><span class="token comment"># hardware ethernet 指定以太网网卡MAC地址</span><span class="token comment"># fixed-address 指定要绑定的IP</span><span class="token function">host</span> print <span class="token punctuation">{</span>           hardware ethernet 00:0C:29:1A:F8:C7<span class="token punctuation">;</span>  fixed-address <span class="token number">192.168</span>.11.252<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启DHCP服务：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># systemctl restart dhcpd</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>登陆测试机进行测试，释放当前IP，重新获得新的IP，查看IP地址是否正确分发：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@test 桌面<span class="token punctuation">]</span><span class="token comment"># ifconfig eth1</span>eth1      Link encap:Ethernet  HWaddr 00:0C:29:1A:F8:C7            inet addr:192.168.11.155  Bcast:192.168.11.255  Mask:255.255.255.0          inet6 addr: fe80::20c:29ff:fe1a:f8c7/64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:4071 errors:0 dropped:0 overruns:0 frame:0          TX packets:187 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000           RX bytes:433880 <span class="token punctuation">(</span><span class="token number">423.7</span> KiB<span class="token punctuation">)</span>  TX bytes:16888 <span class="token punctuation">(</span><span class="token number">16.4</span> KiB<span class="token punctuation">)</span><span class="token punctuation">[</span>root@test 桌面<span class="token punctuation">]</span><span class="token comment"># dhclient -r eth1</span><span class="token punctuation">[</span>root@test 桌面<span class="token punctuation">]</span><span class="token comment"># dhclient -d eth1</span>Internet Systems Consortium DHCP Client <span class="token number">4.1</span>.1-P1Copyright <span class="token number">2004</span>-2010 Internet Systems Consortium.All rights reserved.For info, please visit https://www.isc.org/software/dhcp/Listening on LPF/eth1/00:0c:29:1a:f8:c7Sending on   LPF/eth1/00:0c:29:1a:f8:c7Sending on   Socket/fallbackDHCPDISCOVER on eth1 to <span class="token number">255.255</span>.255.255 port <span class="token number">67</span> interval <span class="token number">4</span> <span class="token punctuation">(</span>xid<span class="token operator">=</span>0x45c162c2<span class="token punctuation">)</span>DHCPOFFER from <span class="token number">192.168</span>.11.16DHCPREQUEST on eth1 to <span class="token number">255.255</span>.255.255 port <span class="token number">67</span> <span class="token punctuation">(</span>xid<span class="token operator">=</span>0x45c162c2<span class="token punctuation">)</span>DHCPACK from <span class="token number">192.168</span>.11.16 <span class="token punctuation">(</span>xid<span class="token operator">=</span>0x45c162c2<span class="token punctuation">)</span>bound to <span class="token number">192.168</span>.11.252 -- renewal <span class="token keyword">in</span> <span class="token number">2881</span> seconds.^C<span class="token punctuation">[</span>root@test 桌面<span class="token punctuation">]</span><span class="token comment"># ifconfig eth1</span>eth1      Link encap:Ethernet  HWaddr 00:0C:29:1A:F8:C7            inet addr:192.168.11.252  Bcast:192.168.11.255  Mask:255.255.255.0          inet6 addr: fe80::20c:29ff:fe1a:f8c7/64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:4081 errors:0 dropped:0 overruns:0 frame:0          TX packets:191 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000           RX bytes:436337 <span class="token punctuation">(</span><span class="token number">426.1</span> KiB<span class="token punctuation">)</span>  TX bytes:17656 <span class="token punctuation">(</span><span class="token number">17.2</span> KiB<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-7、DHCP超级作用域"><a href="#2-7、DHCP超级作用域" class="headerlink" title="2.7、DHCP超级作用域"></a>2.7、DHCP超级作用域</h2><p>超级作用域：将两个或两个以上的作用域合并成一个作用域</p><p><strong>案例:部署一个超级作用域，作用域是192.168.11.0/24网段，192.168.12.0/24网段。</strong></p><p>编辑配置文件:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment">#  cat /etc/dhcp/dhcpd.conf</span>option domain-name-servers <span class="token number">4.2</span>.2.2, <span class="token number">4.2</span>.2.1<span class="token punctuation">;</span>default-lease-time <span class="token number">28800</span><span class="token punctuation">;</span>max-lease-time <span class="token number">43200</span><span class="token punctuation">;</span><span class="token comment">#authoritative;</span>log-facility local7<span class="token punctuation">;</span><span class="token comment">#share-network 部署一个超级作用域</span><span class="token comment">#supper 超级作用域名称，随便起，但是建议有意义。</span>shared-network supper <span class="token punctuation">{</span>    <span class="token comment">#192.168.11.0作用域</span>    subnet <span class="token number">192.168</span>.11.0 netmask <span class="token number">255.255</span>.255.0 <span class="token punctuation">{</span>        range <span class="token number">192.168</span>.11.150 <span class="token number">192.168</span>.11.150<span class="token punctuation">;</span>        option domain-name-servers <span class="token number">202.106</span>.0.20, <span class="token number">114.114</span>.114.114<span class="token punctuation">;</span>        option routers <span class="token number">192.168</span>.11.254<span class="token punctuation">;</span>        default-lease-time <span class="token number">7200</span><span class="token punctuation">;</span>        max-lease-time <span class="token number">10800</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">#192.168.12.0作用域</span>    subnet <span class="token number">192.168</span>.12.0 netmask <span class="token number">255.255</span>.255.0 <span class="token punctuation">{</span>        range <span class="token number">192.168</span>.12.150 <span class="token number">192.168</span>.12.150<span class="token punctuation">;</span>        option domain-name-servers <span class="token number">202.106</span>.0.20, <span class="token number">114.114</span>.114.114<span class="token punctuation">;</span>        option routers <span class="token number">192.168</span>.12.254<span class="token punctuation">;</span>        default-lease-time <span class="token number">7200</span><span class="token punctuation">;</span>        max-lease-time <span class="token number">10800</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：案例中为了方便验证，每个作用域只发布一个IP，否则测试无法保证能100%分到两个网段。</p><p>重启DHCP服务，生效配置文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment"># systemctl restart dhcpd</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在客户端进行验证：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 释放两网卡IP</span><span class="token punctuation">[</span>root@test 桌面<span class="token punctuation">]</span><span class="token comment"># dhclient -r eth0</span><span class="token punctuation">[</span>root@test 桌面<span class="token punctuation">]</span><span class="token comment"># dhclient -r eth1</span><span class="token comment"># 释放成功</span><span class="token punctuation">[</span>root@test 桌面<span class="token punctuation">]</span><span class="token comment"># ifconfig</span>eth0      Link encap:Ethernet  HWaddr 00:0C:29:1A:F8:BD            inet6 addr: fe80::20c:29ff:fe1a:f8bd/64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:1591 errors:0 dropped:0 overruns:0 frame:0          TX packets:162 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000           RX bytes:282324 <span class="token punctuation">(</span><span class="token number">275.7</span> KiB<span class="token punctuation">)</span>  TX bytes:30619 <span class="token punctuation">(</span><span class="token number">29.9</span> KiB<span class="token punctuation">)</span>eth1      Link encap:Ethernet  HWaddr 00:0C:29:1A:F8:C7            inet6 addr: fe80::20c:29ff:fe1a:f8c7/64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:4719 errors:0 dropped:0 overruns:0 frame:0          TX packets:216 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000           RX bytes:559954 <span class="token punctuation">(</span><span class="token number">546.8</span> KiB<span class="token punctuation">)</span>  TX bytes:19582 <span class="token punctuation">(</span><span class="token number">19.1</span> KiB<span class="token punctuation">)</span>lo        Link encap:Local Loopback            inet addr:127.0.0.1  Mask:255.0.0.0          inet6 addr: ::1/128 Scope:Host          UP LOOPBACK RUNNING  MTU:16436  Metric:1          RX packets:12 errors:0 dropped:0 overruns:0 frame:0          TX packets:12 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:0           RX bytes:720 <span class="token punctuation">(</span><span class="token number">720.0</span> b<span class="token punctuation">)</span>  TX bytes:720 <span class="token punctuation">(</span><span class="token number">720.0</span> b<span class="token punctuation">)</span><span class="token comment"># 分别获取IP地址 </span><span class="token punctuation">[</span>root@test 桌面<span class="token punctuation">]</span><span class="token comment"># dhclient -d eth0</span>Internet Systems Consortium DHCP Client <span class="token number">4.1</span>.1-P1Copyright <span class="token number">2004</span>-2010 Internet Systems Consortium.All rights reserved.For info, please visit https://www.isc.org/software/dhcp/Listening on LPF/eth0/00:0c:29:1a:f8:bdSending on   LPF/eth0/00:0c:29:1a:f8:bdSending on   Socket/fallbackDHCPDISCOVER on eth0 to <span class="token number">255.255</span>.255.255 port <span class="token number">67</span> interval <span class="token number">6</span> <span class="token punctuation">(</span>xid<span class="token operator">=</span>0x2574199a<span class="token punctuation">)</span>DHCPOFFER from <span class="token number">192.168</span>.11.16DHCPREQUEST on eth0 to <span class="token number">255.255</span>.255.255 port <span class="token number">67</span> <span class="token punctuation">(</span>xid<span class="token operator">=</span>0x2574199a<span class="token punctuation">)</span>DHCPACK from <span class="token number">192.168</span>.11.16 <span class="token punctuation">(</span>xid<span class="token operator">=</span>0x2574199a<span class="token punctuation">)</span>bound to <span class="token number">192.168</span>.11.150 -- renewal <span class="token keyword">in</span> <span class="token number">3026</span> seconds.^C<span class="token comment"># 确保都是来自我们实验中的DHCP服务器</span><span class="token punctuation">[</span>root@test 桌面<span class="token punctuation">]</span><span class="token comment"># dhclient -d eth1</span>Internet Systems Consortium DHCP Client <span class="token number">4.1</span>.1-P1Copyright <span class="token number">2004</span>-2010 Internet Systems Consortium.All rights reserved.For info, please visit https://www.isc.org/software/dhcp/Listening on LPF/eth1/00:0c:29:1a:f8:c7Sending on   LPF/eth1/00:0c:29:1a:f8:c7Sending on   Socket/fallbackDHCPDISCOVER on eth1 to <span class="token number">255.255</span>.255.255 port <span class="token number">67</span> interval <span class="token number">7</span> <span class="token punctuation">(</span>xid<span class="token operator">=</span>0x2cebde11<span class="token punctuation">)</span>DHCPOFFER from <span class="token number">192.168</span>.11.16DHCPREQUEST on eth1 to <span class="token number">255.255</span>.255.255 port <span class="token number">67</span> <span class="token punctuation">(</span>xid<span class="token operator">=</span>0x2cebde11<span class="token punctuation">)</span>DHCPACK from <span class="token number">192.168</span>.11.16 <span class="token punctuation">(</span>xid<span class="token operator">=</span>0x2cebde11<span class="token punctuation">)</span>bound to <span class="token number">192.168</span>.12.150 -- renewal <span class="token keyword">in</span> <span class="token number">3102</span> seconds.<span class="token comment"># 确保都是来自本地配置的DHCP服务器</span><span class="token comment"># 查看IP情况，发现实验成功了，分别获得到了不同网段IP</span><span class="token punctuation">[</span>root@test 桌面<span class="token punctuation">]</span><span class="token comment"># ifconfig</span>eth0      Link encap:Ethernet  HWaddr 00:0C:29:1A:F8:BD            inet addr:192.168.11.150  Bcast:192.168.11.255  Mask:255.255.255.0          inet6 addr: fe80::20c:29ff:fe1a:f8bd/64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:1613 errors:0 dropped:0 overruns:0 frame:0          TX packets:166 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000           RX bytes:287076 <span class="token punctuation">(</span><span class="token number">280.3</span> KiB<span class="token punctuation">)</span>  TX bytes:31387 <span class="token punctuation">(</span><span class="token number">30.6</span> KiB<span class="token punctuation">)</span>eth1      Link encap:Ethernet  HWaddr 00:0C:29:1A:F8:C7            inet addr:192.168.12.150  Bcast:192.168.12.255  Mask:255.255.255.0          inet6 addr: fe80::20c:29ff:fe1a:f8c7/64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:4741 errors:0 dropped:0 overruns:0 frame:0          TX packets:220 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000           RX bytes:564706 <span class="token punctuation">(</span><span class="token number">551.4</span> KiB<span class="token punctuation">)</span>  TX bytes:20350 <span class="token punctuation">(</span><span class="token number">19.8</span> KiB<span class="token punctuation">)</span>lo        Link encap:Local Loopback            inet addr:127.0.0.1  Mask:255.0.0.0          inet6 addr: ::1/128 Scope:Host          UP LOOPBACK RUNNING  MTU:16436  Metric:1          RX packets:12 errors:0 dropped:0 overruns:0 frame:0          TX packets:12 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:0           RX bytes:720 <span class="token punctuation">(</span><span class="token number">720.0</span> b<span class="token punctuation">)</span>  TX bytes:720 <span class="token punctuation">(</span><span class="token number">720.0</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-8、补充"><a href="#2-8、补充" class="headerlink" title="2.8、补充"></a>2.8、补充</h2><h3 id="2-8-1-如果客户端获得不到-IP会怎么办"><a href="#2-8-1-如果客户端获得不到-IP会怎么办" class="headerlink" title="2.8.1 如果客户端获得不到 IP会怎么办"></a>2.8.1 如果客户端获得不到 IP会怎么办</h3><p>当客户端获得不到IP地址，会得到一个169.254开头的临时IP，此IP不能和其他网段通信，但是Client会继续向网络中发DHCP广播，继续坚持不懈申请IP。</p><h3 id="2-8-2-DHCP会面临单机故障，如何解决"><a href="#2-8-2-DHCP会面临单机故障，如何解决" class="headerlink" title="2.8.2 DHCP会面临单机故障，如何解决"></a>2.8.2 DHCP会面临单机故障，如何解决</h3><p>两台设备互相分发对方网段一段IP，将作用域采用8/2原则，彼此互相冗余，当一台服务器出现问题，不至于整个网段故障。</p><h3 id="2-8-3-抓包验证方法"><a href="#2-8-3-抓包验证方法" class="headerlink" title="2.8.3 抓包验证方法"></a>2.8.3 抓包验证方法</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost dhcp<span class="token punctuation">]</span><span class="token comment">#  tcpdump -nn -vvv -s 1500 -i ens33 host 192.168.11.16 and udp port 67 or udp port 68</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-8-4-如何发放计算机名称"><a href="#2-8-4-如何发放计算机名称" class="headerlink" title="2.8.4 如何发放计算机名称"></a>2.8.4 如何发放计算机名称</h3><p>发放计算机名称只能在保留中完成，要求Client的计算机名配置文件中将对应字段删除。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">option domain-name-servers <span class="token number">4.2</span>.2.2, <span class="token number">4.2</span>.2.1<span class="token punctuation">;</span>default-lease-time <span class="token number">28800</span><span class="token punctuation">;</span>max-lease-time <span class="token number">43200</span><span class="token punctuation">;</span>authoritative<span class="token punctuation">;</span>log-facility local7<span class="token punctuation">;</span>subnet <span class="token number">192.168</span>.11.0 netmask <span class="token number">255.255</span>.255.0 <span class="token punctuation">{</span>  range <span class="token number">192.168</span>.11.153 <span class="token number">192.168</span>.11.252<span class="token punctuation">;</span>  option domain-name-servers <span class="token number">202.106</span>.0.20, <span class="token number">114.114</span>.114.114<span class="token punctuation">;</span>  option routers <span class="token number">192.168</span>.11.254<span class="token punctuation">;</span>  option broadcast-address <span class="token number">192.168</span>.11.255<span class="token punctuation">;</span>  default-lease-time <span class="token number">7200</span><span class="token punctuation">;</span>  max-lease-time <span class="token number">10800</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">host</span> print <span class="token punctuation">{</span>  <span class="token comment">#指定计算机名称</span>  option host-name <span class="token string">"test.hello.com"</span><span class="token punctuation">;</span>  hardware ethernet 00:0c:29:af:f1:84<span class="token punctuation">;</span>  fixed-address <span class="token number">192.168</span>.11.252<span class="token punctuation">;</span><span class="token punctuation">}</span>注意：请把/etc/hostname 中的计算机名称清除      /etc/sysconfig/network中的hostname字段清除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、DNS部署"><a href="#三、DNS部署" class="headerlink" title="三、DNS部署"></a>三、DNS部署</h1><h2 id="3-1-DNS安装"><a href="#3-1-DNS安装" class="headerlink" title="3.1 DNS安装"></a>3.1 DNS安装</h2><p>DNS服务是由bind程序提供的，所以要实现DNS服务就需要安装bind程序包：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># yum install bind bind-chroot -y</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>bind  DNS主程序包 </p><p>bind-chroot DNS安全包，改变默认DNS根目录，将DNS运行在监牢模式 </p><p>说明:chroot监牢模式 监牢是一个软件机制，其功能是使得某个程序无法访问规定区域之外的资源，同样也为了增强安全性（LCTT 译注：chroot “监牢”，所谓“监牢”就是指通过chroot机制来更改某个进程所能看到的根目录，即将某进程限制在指定目录中，保证该进程只能对该目录及其子目录的文件进行操作，从而保证整个服务器的安全）。Bind Chroot DNS 服务器的默认“监牢”为 /var/named/chroot。</p><h2 id="3-2-DNS启动"><a href="#3-2-DNS启动" class="headerlink" title="3.2 DNS启动"></a>3.2 DNS启动</h2><p>DNS的守护进程叫做named,DNS是以named用户身份来运行，named用户在安装包的时候会在系统中自动创建。</p><p>方法一：不使用chroot模式启动DNS </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 开启开机启动</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># systemctl enable named</span>Created symlink from /etc/systemd/system/multi-user.target.wants/named.service to /usr/lib/systemd/system/named.service.<span class="token comment"># 启动DNS服务</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># systemctl start named</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法二: 使用chroot模式DNS </p><p>将对应的文件移动到chroot根目录</p><p>主配文件的转移</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># cp /etc/named.conf /var/named/chroot/etc/</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># chgrp named /var/named/chroot/etc/named.conf</span><span class="token comment"># 检查主配置文件是否有效</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># named-checkconf /var/named/chroot/etc/named.conf</span><span class="token comment"># 上述代码等同于</span><span class="token punctuation">[</span>root@localhost etc<span class="token punctuation">]</span><span class="token comment"># cp -p /etc/named.conf /var/named/chroot/etc/</span>cp：是否覆盖<span class="token string">"/var/named/chroot/etc/named.conf"</span>？ y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>区域数据库文件的配置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># cd /var/named/</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># cp -r data /var/named/chroot/var/named/</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># cp -r dynamic /var/named/chroot/var/named/</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># cp named.* /var/named/chroot/var/named/</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># cd /var/named/chroot/var/named/</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># chown -R named.named *</span><span class="token comment"># 上述代码等同于</span><span class="token punctuation">[</span>root@localhost etc<span class="token punctuation">]</span><span class="token comment"># cp -p /var/named/named.* /var/named/chroot/var/named/</span>cp：是否覆盖<span class="token string">"/var/named/chroot/var/named/named.ca"</span>？ ycp：是否覆盖<span class="token string">"/var/named/chroot/var/named/named.ca.rpmsave"</span>？ ycp：是否覆盖<span class="token string">"/var/named/chroot/var/named/named.empty"</span>？ ycp：是否覆盖<span class="token string">"/var/named/chroot/var/named/named.empty.rpmsave"</span>？ ycp：是否覆盖<span class="token string">"/var/named/chroot/var/named/named.localhost"</span>？ ycp：是否覆盖<span class="token string">"/var/named/chroot/var/named/named.localhost.rpmsave"</span>？ ycp：是否覆盖<span class="token string">"/var/named/chroot/var/named/named.loopback"</span>？ ycp：是否覆盖<span class="token string">"/var/named/chroot/var/named/named.loopback.rpmsave"</span>？ y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动DNS服务<br>开机启动</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># systemctl start named-chroot</span>Job <span class="token keyword">for</span> named-chroot.service failed because the control process exited with error code. See <span class="token string">"systemctl status named-chroot.service"</span> and <span class="token string">"journalctl -xe"</span> <span class="token keyword">for</span> details.启动服务<span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># systemctl start named-chroot</span>Job <span class="token keyword">for</span> named-chroot.service failed because the control process exited with error code. See <span class="token string">"systemctl status named-chroot.service"</span> and <span class="token string">"journalctl -xe"</span> <span class="token keyword">for</span> details.<span class="token comment">## 问题：配置文件出错</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改配置文件之后，重新启动：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># systemctl start named-chroot</span>验证启动<span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># lsof -i :53</span>COMMAND  PID   <span class="token environment constant">USER</span>   FD   TYPE DEVICE SIZE/OFF NODE NAMEdnsmasq <span class="token number">1525</span> nobody    5u  IPv4  <span class="token number">27359</span>      0t0  UDP bogon:domain named   <span class="token number">2877</span>  named   21u  IPv4  <span class="token number">44717</span>      0t0  TCP localhost:domain <span class="token punctuation">(</span>LISTEN<span class="token punctuation">)</span>named   <span class="token number">2877</span>  named   22u  IPv4  <span class="token number">44719</span>      0t0  TCP bogon:domain <span class="token punctuation">(</span>LISTEN<span class="token punctuation">)</span>named   <span class="token number">2877</span>  named   23u  IPv4  <span class="token number">44721</span>      0t0  TCP bogon:domain <span class="token punctuation">(</span>LISTEN<span class="token punctuation">)</span>named   <span class="token number">2877</span>  named  512u  IPv4  <span class="token number">44715</span>      0t0  UDP localhost:domain named   <span class="token number">2877</span>  named  513u  IPv4  <span class="token number">44715</span>      0t0  UDP localhost:domain named   <span class="token number">2877</span>  named  514u  IPv4  <span class="token number">44715</span>      0t0  UDP localhost:domain named   <span class="token number">2877</span>  named  515u  IPv4  <span class="token number">44715</span>      0t0  UDP localhost:domain named   <span class="token number">2877</span>  named  516u  IPv4  <span class="token number">44718</span>      0t0  UDP bogon:domain named   <span class="token number">2877</span>  named  517u  IPv4  <span class="token number">44718</span>      0t0  UDP bogon:domain named   <span class="token number">2877</span>  named  518u  IPv4  <span class="token number">44718</span>      0t0  UDP bogon:domain named   <span class="token number">2877</span>  named  519u  IPv4  <span class="token number">44718</span>      0t0  UDP bogon:domain named   <span class="token number">2877</span>  named  520u  IPv4  <span class="token number">44720</span>      0t0  UDP bogon:domain named   <span class="token number">2877</span>  named  521u  IPv4  <span class="token number">44720</span>      0t0  UDP bogon:domain named   <span class="token number">2877</span>  named  522u  IPv4  <span class="token number">44720</span>      0t0  UDP bogon:domain named   <span class="token number">2877</span>  named  523u  IPv4  <span class="token number">44720</span>      0t0  UDP bogon:domain<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-3-DNS配置文件"><a href="#3-3-DNS配置文件" class="headerlink" title="3.3 DNS配置文件"></a>3.3 DNS配置文件</h2><p>默认情况下，如果不安装bind-chroot这个包，配置文件的路径如下：</p><p>配置文件:/etc/named.conf</p><p>区域数据库文件:/var/named/</p><p>由于我们安装了bind-chroot这个用于改变默认DNS配置文件的路径的包，所以相对应的配置文件的路径也发生了变化。</p><p>变化如下：</p><p>配置文件:/var/named/chroot/etc/named.conf</p><p>区域数据库文件:/var/named/chroot/var/named/</p><p>a、主配文件详解</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//// named.conf//// Provided by Red Hat <span class="token builtin class-name">bind</span> package to configure the ISC BIND named<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> DNS// server as a caching only nameserver <span class="token punctuation">(</span>as a localhost DNS resolver only<span class="token punctuation">)</span>.//// See /usr/share/doc/bind*/sample/ <span class="token keyword">for</span> example named configuration files.//options<span class="token punctuation">{</span>    <span class="token comment">#IPv4监听端口为53，只允许本机连接</span>    listen-on port <span class="token number">53</span>    <span class="token punctuation">{</span> <span class="token number">127.0</span>.0.1<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">#IPv6监听端口为53，只允许本机连接</span>    listen-on-v6 port <span class="token number">53</span>    <span class="token punctuation">{</span> ::1<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">#定义工作目录</span>    directory         <span class="token string">"/var/named"</span><span class="token punctuation">;</span>     <span class="token comment">#CACHE文件路径,指定服务器在收到rndc dump命令时，转储数据到文件的路径。默认cache_dump.db</span>    dump-file         <span class="token string">"data/cache_dump.db"</span><span class="token punctuation">;</span>    <span class="token comment">#静态文件路径,指定服务器在收到rndc stats命令时，追加统计数据的文件路径。默认named.stats</span>    statistics-file     <span class="token string">"data/named_stats.txt"</span><span class="token punctuation">;</span>    <span class="token comment">#内存静态文件路径,服务器在退出时，将内存统计写到文件的路径。默认named.mem_stats</span>    memstatistics-file     <span class="token string">"data/named_mem_stats.txt"</span><span class="token punctuation">;</span>        <span class="token comment">#在收到rndc secroots指令后，服务器转储安全根的目的文件的路径名。默认named.secroots</span>    secroots-file        <span class="token string">"data/named.secroots"</span><span class="token punctuation">;</span>    <span class="token comment"># 指定服务器在通过rndc recursing命令指定转储当前递归请求到的文件路径。默认named.recursing</span>    recursing-file        <span class="token string">"data/named.recursing"</span><span class="token punctuation">;</span>        <span class="token comment">#指定允许哪些主机可以进行普通的DNS查询,可以是关键字:any/localhost/none,也可以是IPV4,IPV6地址</span>    allow-query        <span class="token punctuation">{</span> localhost<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">#指定允许哪些主机可以对缓存的访问</span>    allow-query-cache    <span class="token punctuation">{</span> localhost<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    /*     - If you are building an AUTHORITATIVE DNS server, <span class="token keyword">do</span> NOT <span class="token builtin class-name">enable</span> recursion.    假如你建立的是一个权威DNS你不需要开启递归     - If you are building a RECURSIVE <span class="token punctuation">(</span>caching<span class="token punctuation">)</span> DNS server, you need to <span class="token builtin class-name">enable</span> recursion.     假如你建立的是一个递归DNS,你需要开启递归服务     - If your recursive DNS server has a public IP address, you MUST <span class="token builtin class-name">enable</span> access control to limit queries to your legitimate users. Failing to <span class="token keyword">do</span> so will     如果你的递归DNS是具有公网IP，你必须要设置访问控制来限制对合法用户的查询.       cause your server to become part of large scale DNS amplification     否则你的DNS会被大规模的攻击       attacks. Implementing BCP38 within your network would greatly    在您的网络中实现BCP38将非常重要减少此类攻击面       reduce such attack surface      */    <span class="token comment">#开启递归</span>    recursion <span class="token function">yes</span><span class="token punctuation">;</span>    <span class="token comment">#开启DNSSEC在权威或者递归服务器之间信任服务</span>    dnssec-enable <span class="token function">yes</span><span class="token punctuation">;</span>    <span class="token comment">#开启DNSSEC验证在递归服务器</span>    dnssec-validation <span class="token function">yes</span><span class="token punctuation">;</span>    <span class="token comment">#指定目录，其中保存着跟踪被管理DNSSEC密钥文件。默认为工作目录。</span>    managed-keys-directory <span class="token string">"/var/named/dynamic"</span><span class="token punctuation">;</span>        <span class="token comment">#PID文件路径</span>    pid-file <span class="token string">"/run/named/named.pid"</span><span class="token punctuation">;</span>    <span class="token comment">#session-keyfile文件路径</span>    session-keyfile <span class="token string">"/run/named/session.key"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>logging <span class="token punctuation">{</span><span class="token comment">#开启DNS日志记录</span>        channel default_debug <span class="token punctuation">{</span>                <span class="token function">file</span> <span class="token string">"data/named.run"</span><span class="token punctuation">;</span>                severity dynamic<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>       <span class="token comment">#定义一个根域</span>zone <span class="token string">"."</span> IN <span class="token punctuation">{</span>        <span class="token comment">#域类型为hint,还有master slave forward等类型</span>            <span class="token builtin class-name">type</span> hint<span class="token punctuation">;</span>        <span class="token comment">#区域数据库文件路径</span>            <span class="token function">file</span> <span class="token string">"/var/named/named.ca"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">#包含两个子配置文件</span>    include <span class="token string">"/etc/named.rfc1912.zones"</span><span class="token punctuation">;</span>    include <span class="token string">"/etc/named.root.key"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>b、区域数据库文件详解</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">正向解析<span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># cat /var/named/named.localhost </span><span class="token punctuation">;</span>缓存时间<span class="token variable">$TTL</span> 1D<span class="token punctuation">;</span>@表示相应的域名@    IN SOA        @ rname.invalid. <span class="token punctuation">(</span><span class="token punctuation">;</span>解析的域名   类型 授权域    授权域名服务器   管理员邮箱                    <span class="token number">0</span>    <span class="token punctuation">;</span> serial           序列号,每次更新该文件系列号都应该变大                    1D    <span class="token punctuation">;</span> refresh 刷新时间,即规定从域名服务器多长时间查询一个主服务器，以保证从服务器的数据是最新的                    1H    <span class="token punctuation">;</span> retry   重试时间,即当从服务试图在主服务器上查询更时，而连接失败了，则这个值规定了从服务多长时间后再试                     1W    <span class="token punctuation">;</span> expire     过期时间,从服务器在向主服务更新失败后多长时间后清除对应的记录                    3H <span class="token punctuation">)</span>    <span class="token punctuation">;</span> minimum    这个数据用来规定缓存服务器不能与主服务联系上后多长时间清除相应的记录    NS   @    <span class="token punctuation">;</span>NS 名称服务器，表示这个主机为域名服务器    A    <span class="token number">127.0</span>.0.1<span class="token punctuation">;</span>主机头  A记录   IP    AAAA    ::1<span class="token punctuation">;</span>   AAAA 解析为IPV6地址<span class="token comment">#反向解析</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># cat named.loopback </span><span class="token variable">$TTL</span> 1D@    IN SOA    @ rname.invalid. <span class="token punctuation">(</span>                    <span class="token number">0</span>    <span class="token punctuation">;</span> serial                    1D    <span class="token punctuation">;</span> refresh                    1H    <span class="token punctuation">;</span> retry                    1W    <span class="token punctuation">;</span> expire                    3H <span class="token punctuation">)</span>    <span class="token punctuation">;</span> minimum    NS    @    PTR    localhost<span class="token punctuation">;</span>IP 反向指针     主机名<span class="token punctuation">;</span>PTR 反向指针 反解<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-4-正向解析部署"><a href="#3-4-正向解析部署" class="headerlink" title="3.4 正向解析部署"></a>3.4 正向解析部署</h2><p><strong>www 解析为A记录 IP地址为 192.168.11.88</strong></p><p><strong>news 做别名解析CNAME 解析为 www</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>）主配置文件<span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># cat /var/named/chroot/etc/named.conf </span>options <span class="token punctuation">{</span>    listen-on port <span class="token number">53</span> <span class="token punctuation">{</span> any<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    directory     <span class="token string">"/var/named"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>//定义根域//用于DNS向根递归查询zone <span class="token string">"."</span> IN <span class="token punctuation">{</span>    <span class="token builtin class-name">type</span> hint<span class="token punctuation">;</span>    //保存了DNS根级服务器的地址    <span class="token function">file</span> <span class="token string">"named.ca"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>//定义一个主域//注意每行都要<span class="token punctuation">;</span>结尾zone <span class="token string">"zutuanxue.com"</span> IN <span class="token punctuation">{</span>//类型为master    <span class="token builtin class-name">type</span> master<span class="token punctuation">;</span>//区域数据库文件名称    <span class="token function">file</span> <span class="token string">"zutuanxue.com.zone"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token number">2</span>）区域数据库文件<span class="token punctuation">[</span>root@localhost named<span class="token punctuation">]</span><span class="token comment"># cat zutuanxue.com.zone </span><span class="token variable">$TTL</span> 1Dzutuanxue.com.    IN SOA    ns1.zutuanxue.com. rname.invalid. <span class="token punctuation">(</span>                    <span class="token number">0</span>    <span class="token punctuation">;</span> serial                    1D    <span class="token punctuation">;</span> refresh                    1H    <span class="token punctuation">;</span> retry                    1W    <span class="token punctuation">;</span> expire                    3H <span class="token punctuation">)</span>    <span class="token punctuation">;</span> minimum<span class="token punctuation">;</span>zutuanxue.com.  需要做解析的域名<span class="token punctuation">;</span>ns1.zutuanxue.com.  为zutuanxue.com.做解析的DNS    这里我们既是DNS也同时为自己域名做了解析    NS    ns1.zutuanxue.com.<span class="token punctuation">;</span>A         域名机械为IP<span class="token punctuation">;</span>PTR        IP解析为域名<span class="token punctuation">;</span>MX        邮件标记<span class="token punctuation">;</span>CNAME        别名ns1    A    <span class="token number">192.168</span>.11.16www    A    <span class="token number">192.168</span>.11.88news  CNAME    www<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>测试方法</strong></p><p>域名解析linux系统为大家提供了三个命令，看大家喜欢用哪个都可以。</p><p>a、host采用非交互式解析，</p><p>b、nslookup可以采用交互或非交互式解析</p><p>c、dig显示详细的解析流程</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">测试注意：请将你的测试客户端机器的DNS指向你自己的DNS服务器的IP地址。本例中我使用DNS服务器给自己当测试端，我修改了自己的DNS服务器地址<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cat /etc/resolv.conf </span><span class="token comment"># Generated by NetworkManager</span>nameserver <span class="token number">192.168</span>.11.16<span class="token comment">#host命令</span><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># host news.zutuanxue.com</span>news.zutuanxue.com is an <span class="token builtin class-name">alias</span> <span class="token keyword">for</span> www.zutuanxue.com.www.zutuanxue.com has address <span class="token number">192.168</span>.11.88<span class="token comment">#nslookup 命令---交互式解析</span><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># nslookup</span><span class="token operator">&gt;</span> news.zutuanxue.comServer:        <span class="token number">192.168</span>.11.16Address:    <span class="token number">192.168</span>.11.16<span class="token comment">#53</span>news.zutuanxue.com    canonical name <span class="token operator">=</span> www.zutuanxue.com.Name:    www.zutuanxue.comAddress: <span class="token number">192.168</span>.11.88<span class="token operator">&gt;</span> <span class="token builtin class-name">exit</span><span class="token comment">#nslookup 命令---非交互式解析</span><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># nslookup news.zutuanxue.com</span>Server:        <span class="token number">192.168</span>.11.16Address:    <span class="token number">192.168</span>.11.16<span class="token comment">#53</span>news.zutuanxue.com    canonical name <span class="token operator">=</span> www.zutuanxue.com.Name:    www.zutuanxue.comAddress: <span class="token number">192.168</span>.11.88<span class="token comment">#dig命令</span><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># dig news.zutuanxue.com</span><span class="token punctuation">;</span> <span class="token operator">&lt;&lt;</span><span class="token operator">&gt;&gt;</span> DiG <span class="token number">9.9</span>.4-RedHat-9.9.4-73.el7_6 <span class="token operator">&lt;&lt;</span><span class="token operator">&gt;&gt;</span> news.zutuanxue.com<span class="token punctuation">;</span><span class="token punctuation">;</span> global options: +cmd<span class="token punctuation">;</span><span class="token punctuation">;</span> Got answer:<span class="token punctuation">;</span><span class="token punctuation">;</span> -<span class="token operator">&gt;&gt;</span>HEADER<span class="token operator">&lt;&lt;-</span> opcode: QUERY, status: NOERROR, id: <span class="token number">28487</span><span class="token punctuation">;</span><span class="token punctuation">;</span> flags: qr aa rd ra<span class="token punctuation">;</span> QUERY: <span class="token number">1</span>, ANSWER: <span class="token number">2</span>, AUTHORITY: <span class="token number">1</span>, ADDITIONAL: <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">;</span> OPT PSEUDOSECTION:<span class="token punctuation">;</span> EDNS: version: <span class="token number">0</span>, flags:<span class="token punctuation">;</span> udp: <span class="token number">4096</span><span class="token punctuation">;</span><span class="token punctuation">;</span> QUESTION SECTION:<span class="token punctuation">;</span>news.zutuanxue.com.        IN    A<span class="token punctuation">;</span><span class="token punctuation">;</span> ANSWER SECTION:news.zutuanxue.com.    <span class="token number">86400</span>    IN    CNAME    www.zutuanxue.com.www.zutuanxue.com.    <span class="token number">86400</span>    IN    A    <span class="token number">192.168</span>.11.88<span class="token punctuation">;</span><span class="token punctuation">;</span> AUTHORITY SECTION:zutuanxue.com.        <span class="token number">86400</span>    IN    NS    www.zutuanxue.com.<span class="token punctuation">;</span><span class="token punctuation">;</span> Query time: <span class="token number">0</span> msec<span class="token punctuation">;</span><span class="token punctuation">;</span> SERVER: <span class="token number">192.168</span>.11.16<span class="token comment">#53(192.168.11.16)</span><span class="token punctuation">;</span><span class="token punctuation">;</span> WHEN: 一 <span class="token number">2</span>月 <span class="token number">25</span> <span class="token number">10</span>:52:19 CST <span class="token number">2019</span><span class="token punctuation">;</span><span class="token punctuation">;</span> MSG SIZE  rcvd: <span class="token number">93</span>技巧：在dig解析中，后面跟上+trace来显示详细解析流程<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># dig www.zutuanxue.com +trace</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-5-反向解析部署"><a href="#3-5-反向解析部署" class="headerlink" title="3.5 反向解析部署"></a>3.5 反向解析部署</h2><p>主配置文件添加反向解析zone：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cat /var/named/chroot/etc/named.conf </span>options <span class="token punctuation">{</span>    listen-on port <span class="token number">53</span> <span class="token punctuation">{</span> any<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    directory     <span class="token string">"/var/named"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>//定义根域//用于DNS向根递归查询zone <span class="token string">"."</span> IN <span class="token punctuation">{</span>    <span class="token builtin class-name">type</span> hint<span class="token punctuation">;</span>    //保存了DNS根级服务器的地址    <span class="token function">file</span> <span class="token string">"named.ca"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>//定义一个主域//注意每行都要<span class="token punctuation">;</span>结尾zone <span class="token string">"zutuanxue.com"</span> IN <span class="token punctuation">{</span>//类型为master    <span class="token builtin class-name">type</span> master<span class="token punctuation">;</span>//区域数据库文件名称    <span class="token function">file</span> <span class="token string">"zutuanxue.com.zone"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>//定义一个反向解析//此处需要倒写网段zone <span class="token string">"11.168.192.in-addr.arpa"</span> IN <span class="token punctuation">{</span>    <span class="token builtin class-name">type</span> master<span class="token punctuation">;</span>    <span class="token function">file</span> <span class="token string">"192.168.11.arpa"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>区域数据库文件设置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost named<span class="token punctuation">]</span><span class="token comment"># cat 192.168.11.arpa </span><span class="token variable">$TTL</span> 1D<span class="token number">11.168</span>.192.in-addr.arpa.    IN SOA    ns1.zutuanxue.com. rname.invalid. <span class="token punctuation">(</span>                    <span class="token number">0</span>    <span class="token punctuation">;</span> serial                    1D    <span class="token punctuation">;</span> refresh                    1H    <span class="token punctuation">;</span> retry                    1W    <span class="token punctuation">;</span> expire                    3H <span class="token punctuation">)</span>    <span class="token punctuation">;</span> minimum    NS    ns1.zutuanxue.com.<span class="token number">88</span>    PTR    www.zutuanxue.com.注意：文件的所有者和所有者组都是named<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用nslookup测试：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># nslookup 192.168.11.88</span>Server:        <span class="token number">192.168</span>.11.16Address:    <span class="token number">192.168</span>.11.16<span class="token comment">#53</span><span class="token number">88.11</span>.168.192.in-addr.arpa    name <span class="token operator">=</span> www.zutuanxue.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-6-DNS服务器冗余"><a href="#3-6-DNS服务器冗余" class="headerlink" title="3.6 DNS服务器冗余"></a>3.6 DNS服务器冗余</h2><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%97%E4%BD%99.png" alt="image-20231016114615754"></p><p>​        DNS服务器在网络中为全世界的服务器提供了域名解析服务，扮演着至关重要的角色。网络中的某台DNS一旦宕机，就会造成部分域名无法解析，用户无法顺利访问到对应的服务器。但是我们学习的过程中也发现了，我们的DNS部署在单台服务器上，如果出现单点故障，我们应该如何应对呢？我们可以通过部署多台相同解析的DNS来解决单点故障，就算一台DNS服务器出现问题，也不会影响解析服务。怎么部署呢？如何保障多台之间的解析一致？这就是我们要讨论的问题了。我们来学习辅助DNS吧！</p><p>​        辅助DNS是从主DNS拉取区域数据库文件的的，当主DNS解析的域名对应的区域数据库文件发生变化，辅助就会去找主DNS拉取新的区域数据库文件，保证和主的解析一致，而且是自动的不需要人为干预的，确保了主从DNS的区域数据库文件的一致性。</p><p><strong>教学案例:按照图例,为主DNS(192.168.11.16）部署一台辅助DNS(192.168.11.116)，实现数据同步。</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">辅助DNS设置a、软件包安装<span class="token punctuation">[</span>root@slave ~<span class="token punctuation">]</span><span class="token comment"># dnf -y install bind bind-chroot</span>b、设置主配文件<span class="token punctuation">[</span>root@slave etc<span class="token punctuation">]</span><span class="token comment"># cat /var/named/chroot/etc/named.conf</span>options <span class="token punctuation">{</span>    listen-on port <span class="token number">53</span> <span class="token punctuation">{</span> any<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    directory     <span class="token string">"/var/named"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>//定义根域//用于DNS向根递归查询zone <span class="token string">"."</span> IN <span class="token punctuation">{</span>    <span class="token builtin class-name">type</span> hint<span class="token punctuation">;</span>    //保存了DNS根级服务器的地址    <span class="token function">file</span> <span class="token string">"named.ca"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>//定义一个主域//注意每行都要<span class="token punctuation">;</span>结尾zone <span class="token string">"zutuanxue.com"</span> IN <span class="token punctuation">{</span>//类型为slave  代表辅助    <span class="token builtin class-name">type</span> slave<span class="token punctuation">;</span>//区域数据库文件名称    <span class="token function">file</span> <span class="token string">"zutuanxue.com.zone"</span><span class="token punctuation">;</span>//设置主DNS IP,向该IP去同步数据    masters <span class="token punctuation">{</span> <span class="token number">192.168</span>.11.16<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>//定义一个反向解析//此处需要倒写网段zone <span class="token string">"11.168.192.in-addr.arpa"</span> IN <span class="token punctuation">{</span>//类型写slave  代表辅助    <span class="token builtin class-name">type</span> slave<span class="token punctuation">;</span>    <span class="token function">file</span> <span class="token string">"192.168.11.arpa"</span><span class="token punctuation">;</span>//设置主DNS IP,向该IP去同步数据    masters <span class="token punctuation">{</span> <span class="token number">192.168</span>.11.16<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>修改权限<span class="token punctuation">[</span>root@slave etc<span class="token punctuation">]</span><span class="token comment"># chgrp named named.conf </span>c、启动服务<span class="token punctuation">[</span>root@slave chroot<span class="token punctuation">]</span><span class="token comment"># systemctl enable named-chroot.service </span>Created symlink from /etc/systemd/system/multi-user.target.wants/named-chroot.service to /usr/lib/systemd/system/named-chroot.service.<span class="token punctuation">[</span>root@slave chroot<span class="token punctuation">]</span><span class="token comment"># systemctl start named-chroot</span>d、验证<span class="token punctuation">[</span>root@slave ~<span class="token punctuation">]</span><span class="token comment"># ls /var/named/chroot/var/named/</span><span class="token number">192.168</span>.11.arpa  zutuanxue.com.zone  <span class="token function">chroot</span>  data  dynamic  named.ca  named.empty  named.localhost  named.loopback  slaves发现192.168.11.arpa  zutuanxue.com.zone 这两个数据库文件已经同步过来了，解析一下看看吧！设置客户端的DNS IP为192.168.11.116，我的测试机就是这台slave机器，所以设置为192.168.11.116即可<span class="token punctuation">[</span>root@slave ~<span class="token punctuation">]</span><span class="token comment"># cat /etc/resolv.conf </span>nameserver <span class="token number">192.168</span>.11.116使用nslookup验证一下<span class="token punctuation">[</span>root@slave ~<span class="token punctuation">]</span><span class="token comment"># nslookup news.zutuanxue.com</span>Server:        <span class="token number">192.168</span>.11.116Address:    <span class="token number">192.168</span>.11.116<span class="token comment">#53</span>news.zutuanxue.com    canonical name <span class="token operator">=</span> www.zutuanxue.com.Name:    www.zutuanxue.comAddress: <span class="token number">192.168</span>.11.88<span class="token punctuation">[</span>root@slave ~<span class="token punctuation">]</span><span class="token comment"># nslookup 192.168.11.88</span>Server:        <span class="token number">192.168</span>.11.116Address:    <span class="token number">192.168</span>.11.116<span class="token comment">#53</span><span class="token number">88.11</span>.168.192.in-addr.arpa    name <span class="token operator">=</span> www.11.168.192.in-addr.arpa.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-7-智能DNS"><a href="#3-7-智能DNS" class="headerlink" title="3.7 智能DNS"></a>3.7 智能DNS</h2><p>在我们访问WEB的时候，发现有的网站打开的速度非常快，有的网站打开的非常慢，这是为什么呢？原因就是很多公司为了提升用户的体验，自己的网站使用了CDN内容加速服务，让你直接在你本地城市的服务器上拿数据并展示给你看。什么是CDN我们暂且理解为本地缓存服务器就好，那么你是怎么准确知道你本地的缓存服务器的呢！因为很多CDN公司的DNS使用了智能解析服务，根据你的源IP判断你属于哪个城市，让后再把本地的缓存服务器解析给你，你就会直接去找该服务器拿数据了。</p><p>智能解析原理</p><p>在DNS中植入全世界的IP库以及IP对应的地域，当用户来请求解析时，DNS会根据其源IP来定位他属于哪个区域，然后去找这个区域的view视图查询对应的域名的区域数据库文件做解析。从而使得不同地域的用户解析不同。</p><p><strong>教学案例:部署一台DNS智能解析服务器，对zutuanxue.com域名做智能解析：</strong></p><p><strong>上海的用户解析IP为 1.1.1.1</strong></p><p><strong>北京的用户解析IP为 2.2.2.2</strong></p><p><strong>其他用户解析为 3.3.3.3</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">智能解析a、设置主配文件定义IP库，DNS根据IP库判断源IP属于哪个区域根据地域定义视图，将该区域的客户端的解析请求都由该视图中的zone来解析<span class="token punctuation">[</span>root@master named<span class="token punctuation">]</span><span class="token comment"># cat /var/named/chroot/etc/named.conf</span>options <span class="token punctuation">{</span>    directory     <span class="token string">"/var/named"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>//定义IP库acl shanghai <span class="token punctuation">{</span> <span class="token number">192.168</span>.11.50<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>acl beijing <span class="token punctuation">{</span> <span class="token number">192.168</span>.11.100<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>//定义视图，通过IP匹配后，通过不同的区域数据库文件进行解析view <span class="token function">sh</span> <span class="token punctuation">{</span>match-clients <span class="token punctuation">{</span> shanghai<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>zone <span class="token string">"zutuanxue.com"</span> IN <span class="token punctuation">{</span>    <span class="token builtin class-name">type</span> master<span class="token punctuation">;</span>    <span class="token function">file</span> <span class="token string">"zutuanxue.com.zone.sh"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>view bj <span class="token punctuation">{</span>match-clients <span class="token punctuation">{</span> beijing<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>zone <span class="token string">"zutuanxue.com"</span> IN <span class="token punctuation">{</span>        <span class="token builtin class-name">type</span> master<span class="token punctuation">;</span>        <span class="token function">file</span> <span class="token string">"zutuanxue.com.zone.bj"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>view other <span class="token punctuation">{</span>match-clients <span class="token punctuation">{</span> any<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  zone <span class="token string">"zutuanxue.com"</span> IN <span class="token punctuation">{</span>        <span class="token builtin class-name">type</span> master<span class="token punctuation">;</span>        <span class="token function">file</span> <span class="token string">"zutuanxue.com.zone.any"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>b、根据主配文件设置不同的区域数据库文件<span class="token punctuation">[</span>root@master named<span class="token punctuation">]</span><span class="token comment"># cd /var/named/chroot/var/named</span><span class="token punctuation">[</span>root@master named<span class="token punctuation">]</span><span class="token comment"># cp zutuanxue.com.zone zutuanxue.com.zone.bj</span><span class="token punctuation">[</span>root@master named<span class="token punctuation">]</span><span class="token comment"># cp zutuanxue.com.zone zutuanxue.com.zone.sh</span><span class="token punctuation">[</span>root@master named<span class="token punctuation">]</span><span class="token comment"># cp zutuanxue.com.zone zutuanxue.com.zone.any</span><span class="token punctuation">[</span>root@master named<span class="token punctuation">]</span><span class="token comment"># chgrp named  zutuanxue.com.zone.*</span><span class="token punctuation">[</span>root@master named<span class="token punctuation">]</span><span class="token comment"># cat /var/named/chroot/var/named/zutuanxue.com.zone.sh </span><span class="token variable">$TTL</span> 1D@    IN SOA    zutuanxue.com. rname.invalid. <span class="token punctuation">(</span>                    <span class="token number">0</span>    <span class="token punctuation">;</span> serial                    1D    <span class="token punctuation">;</span> refresh                    1H    <span class="token punctuation">;</span> retry                    1W    <span class="token punctuation">;</span> expire                    3H <span class="token punctuation">)</span>    <span class="token punctuation">;</span> minimum    NS    www.zutuanxue.com.www    A    <span class="token number">1.1</span>.1.1<span class="token punctuation">[</span>root@master named<span class="token punctuation">]</span><span class="token comment"># cat /var/named/chroot/var/named/zutuanxue.com.zone.bj</span><span class="token variable">$TTL</span> 1D@    IN SOA    zutuanxue.com. rname.invalid. <span class="token punctuation">(</span>                    <span class="token number">0</span>    <span class="token punctuation">;</span> serial                    1D    <span class="token punctuation">;</span> refresh                    1H    <span class="token punctuation">;</span> retry                    1W    <span class="token punctuation">;</span> expire                    3H <span class="token punctuation">)</span>    <span class="token punctuation">;</span> minimum    NS    www.zutuanxue.com.www    A    <span class="token number">2.2</span>.2.2<span class="token punctuation">[</span>root@master named<span class="token punctuation">]</span><span class="token comment"># cat /var/named/chroot/var/named/zutuanxue.com.zone.any </span><span class="token variable">$TTL</span> 1D@    IN SOA    zutuanxue.com. rname.invalid. <span class="token punctuation">(</span>                    <span class="token number">0</span>    <span class="token punctuation">;</span> serial                    1D    <span class="token punctuation">;</span> refresh                    1H    <span class="token punctuation">;</span> retry                    1W    <span class="token punctuation">;</span> expire                    3H <span class="token punctuation">)</span>    <span class="token punctuation">;</span> minimum    NS    www.zutuanxue.com.www    A    <span class="token number">3.3</span>.3.3c、测试依次修改主配的IP库中的IP为本机，观看解析情况<span class="token punctuation">[</span>root@master named<span class="token punctuation">]</span><span class="token comment"># nslookup www.zutuanxue.com</span>Server:        <span class="token number">192.168</span>.11.16Address:    <span class="token number">192.168</span>.11.16<span class="token comment">#53</span>Name:    www.zutuanxue.comAddress: <span class="token number">1.1</span>.1.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RS21论文笔记</title>
      <link href="/2023/09/28/psi/rs21-lun-wen-bi-ji/"/>
      <url>/2023/09/28/psi/rs21-lun-wen-bi-ji/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> PSI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PSI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git基本命令</title>
      <link href="/2023/09/25/git-ji-ben-ming-ling/"/>
      <url>/2023/09/25/git-ji-ben-ming-ling/</url>
      
        <content type="html"><![CDATA[<h3 id="一、基本的linux命令"><a href="#一、基本的linux命令" class="headerlink" title="一、基本的linux命令"></a>一、基本的linux命令</h3><p><code>cd</code> 进入某个目录</p><p><code>pwd</code> 显示当前目录路径</p><p><code>ls(ll)</code> 列出当前目录的文件 <code>ll</code>就是<code>ls -l</code>，列出详细信息</p><p><code>touch</code> 新建一个文件</p><p><code>rm</code> 删除要给文件，加上<code>-rf</code>，就是强制删除目录</p><p><code>mkdir</code> 新建一个目录</p><p><code>mv</code> 移动文件，或者是更改文件名称</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">`</span><span class="token function">mv</span> index.html ./aa<span class="token variable">`</span></span>，这就是将<span class="token variable"><span class="token variable">`</span>index.html<span class="token variable">`</span></span>移动到<span class="token variable"><span class="token variable">`</span>./aa<span class="token variable">`</span></span>目录下。<span class="token variable"><span class="token variable">`</span><span class="token function">mv</span> index.html ./aa/bb.html<span class="token variable">`</span></span>，这是就是将<span class="token variable"><span class="token variable">`</span>index.html<span class="token variable">`</span></span>移动到<span class="token variable"><span class="token variable">`</span>./aa<span class="token variable">`</span></span>目录下并改名为`bb.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>reset</code> 重新初始化终端/清屏</p><p><code>clear</code> 清屏</p><p><code>history</code> 查看命令历史</p><p><code>help</code> 帮助</p><p><code>#</code> 代表注释</p><p><code>cat</code> 显示文件内容</p><h3 id="二、git配置"><a href="#二、git配置" class="headerlink" title="二、git配置"></a>二、git配置</h3><p><code>git config -l</code> 查看当前git环境详细配置</p><h4 id="2-1、查看系统config"><a href="#2-1、查看系统config" class="headerlink" title="2.1、查看系统config"></a>2.1、查看系统config</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config --system --list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置文件在<code>git安装目录/etc/gitconfig</code></p><h4 id="2-2、查看当前用户配置"><a href="#2-2、查看当前用户配置" class="headerlink" title="2.2、查看当前用户配置"></a>2.2、查看当前用户配置</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config --global --list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置文件在<code>~/.gitconfig</code></p><h4 id="2-3、查看当前仓库配置信息"><a href="#2-3、查看当前仓库配置信息" class="headerlink" title="2.3、查看当前仓库配置信息"></a>2.3、查看当前仓库配置信息</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config --local --list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置文件在<code>当前项目的/.git/config</code></p><h4 id="2-4、修改git配置"><a href="#2-4、修改git配置" class="headerlink" title="2.4、修改git配置"></a>2.4、修改git配置</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token punctuation">[</span>--local<span class="token punctuation">]</span><span class="token punctuation">[</span>--global<span class="token punctuation">]</span><span class="token punctuation">[</span>--system<span class="token punctuation">]</span> section.key value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>git config --local user.name huhuhu</code> 设置当前项目的用户名</p><p><code>git config --global core.quotepath false</code> 配置当前用户的编码项，可以解决中文编码问题</p><p><code>git config --local core.ignorecase false</code> 配置当前项目不忽略文件大小写，git默认忽略文件名的大小写，这点值得注意</p><h3 id="三、git基本知识"><a href="#三、git基本知识" class="headerlink" title="三、git基本知识"></a>三、git基本知识</h3><pre class="line-numbers language-none"><code class="language-none">使用远程仓库时候会有多个协议可以选择，使用https不仅仅速度慢，而且每次push都要输入口令。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-1、git关键字解释"><a href="#3-1、git关键字解释" class="headerlink" title="3.1、git关键字解释"></a>3.1、git关键字解释</h4><hr><p><code>HEAD</code> 当前版本的指针，当切换本地版本的时候会快速指向指定版本文件</p><p><code>master</code> git为我们创建主分支</p><p><code>origin</code> 远程仓库的名称</p><h4 id="3-2、git文件的四种状态"><a href="#3-2、git文件的四种状态" class="headerlink" title="3.2、git文件的四种状态"></a>3.2、git文件的四种状态</h4><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/git%E6%96%87%E4%BB%B6%E5%9B%9B%E7%A7%8D%E7%8A%B6%E6%80%81.png" alt="image-20230925102448054"></p><ul><li>Untracked：未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</li><li>Unmodify：文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</li><li>Modified：文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改</li><li>Staged：暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</li></ul><h3 id="四、git常用命令"><a href="#四、git常用命令" class="headerlink" title="四、git常用命令"></a>四、git常用命令</h3><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.png" alt="image-20230925102541185"></p><h4 id="4-1、init-amp-amp-clone"><a href="#4-1、init-amp-amp-clone" class="headerlink" title="4.1、init &amp;&amp; clone"></a>4.1、init &amp;&amp; clone</h4><p><code>git init</code> 在当前目录新建一个仓库</p><p><code>git init [project-name]</code> 在一个目录下新建本地仓库</p><p><code>git clone [url]</code> 克隆一个远程仓库</p><h4 id="4-2、diff"><a href="#4-2、diff" class="headerlink" title="4.2、diff"></a>4.2、diff</h4><hr><p><code>git diff HEAD -- .</code> 查看最新本地版本库和工作区所有文件的区别</p><p><code>git diff HEAD -- [file-name]</code> 查看最新本地版本库和工作区文件的却别</p><p><code>git diff HEAD^ -- [file-name]</code> 查看本地上一个版本和工作区文件的却别</p><p><code>git diff [local branch] origin/[remote branch]</code> 比较本地分支和远程分支的区别</p><h4 id="4-3、status"><a href="#4-3、status" class="headerlink" title="4.3、status"></a>4.3、status</h4><hr><p><code>git status [file-name]</code> 查看指定文件状态</p><p><code>git status</code> 查看所有文件状态</p><h4 id="4-4、add"><a href="#4-4、add" class="headerlink" title="4.4、add"></a>4.4、add</h4><hr><p><code>git add [file-name1] [file-name2] ...</code> 从工作区添加指定文件到暂存区</p><p><code>git add .</code> 将工作区的被修改的文件和新增的文件提交到暂存区，不包括被删除的文件</p><p><code>git add -u .</code> u指update，将工作区的被修改的文件和被删除的文件提交到暂存区，不包括新增的文件</p><p><code>git add -A .</code> A指all，将工作区被修改、被删除、新增的文件都提交到暂存区</p><h4 id="4-5、commit"><a href="#4-5、commit" class="headerlink" title="4.5、commit"></a>4.5、commit</h4><hr><ul><li><code>git commit -m [massage]</code> 将暂存区所有文件添加到本地仓库</li><li><code>git commit [file-name-1] [file-name-2] -m [massage]</code> 将暂存区指定文件添加到本地仓库</li><li><code>git commit -am [massage]</code> 将工作区的内容直接加入本地仓库</li><li><code>git commit --amend</code> 快速将当前文件修改合并到最新的commit，不会产生新的commit。<ul><li>在提交commit后发现还有部分文件修改忘记提交了可以是用该命令加<code>-m</code>是指直接在后面写上版本的注释，不加<code>-m</code>的话会用一个vim打开文件让你写入massage，有未追踪的文件将会失败，需要add加入暂存区。</li></ul></li></ul><hr><h4 id="4-6、clean"><a href="#4-6、clean" class="headerlink" title="4.6、clean"></a>4.6、clean</h4><ul><li><code>git clean -df</code> 加<code>-d</code>是指包含目录，加<code>-f</code>是指强制，删除所有未跟踪的文件</li></ul><hr><h4 id="4-7、log"><a href="#4-7、log" class="headerlink" title="4.7、log"></a>4.7、log</h4><ul><li><p><code>git log</code> 显示所有commit日志</p></li><li><p><code>git log --pretty=oneline</code> 将日志缩写为单行显示</p></li><li><p><code>git log --graph --pretty=oneline --abbrev-commit</code> 查看分支合并情况</p></li><li><p><code>git log --oneline --decorate --graph --all</code> 查看分叉历史，包括：提交历史、各个分支的指向以及项目的分支分叉情况。</p></li><li><p><code>git log -3</code> 查看最新3条commit日志数据</p></li></ul><hr><h4 id="4-8、reflog"><a href="#4-8、reflog" class="headerlink" title="4.8、reflog"></a>4.8、reflog</h4><p><code>git reflog</code> 显示操作本地版本库的命令，包括commit和reset等，在回退版本以后又后悔找不到commit id了可以使用此命令查看历史</p><hr><h5 id="4-9、push"><a href="#4-9、push" class="headerlink" title="4.9、push"></a>4.9、push</h5><ul><li><p><code>git push</code> 将文件添加到远程仓库</p></li><li><p><code>git push -f</code> 强制提交，当我们本地reset到旧的版本时，然后普通push会被拦截，因为此是本地HEAD指向比远程库还要旧</p></li><li><p><code>git push origin [branch-name]</code> 推送当前本地分支到指定远程分支</p></li></ul><hr><h4 id="4-10、rm"><a href="#4-10、rm" class="headerlink" title="4.10、rm"></a>4.10、rm</h4><p><code>git rm --cached [file-name]</code> 删除暂存区的文件</p><p><code>git rm -rf .</code> 不但删除所有暂存区的文件，还删除所有工作区的物理文件</p><hr><h4 id="4-11、checkout"><a href="#4-11、checkout" class="headerlink" title="4.11、checkout"></a>4.11、checkout</h4><pre class="line-numbers language-none"><code class="language-none">git checkout -- [file-name]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>最好加<code>--</code>，没有的话就把它当作切换分支看待，切换到另一个分支了，如果没有这个分支也会把它当作文件执行。</li><li>用暂存区的文件覆盖掉工作区的文件</li><li>如果暂存区没有可更新的就会用commit的文件更新工作区的文件</li></ul><p><code>git checkout [branch]</code> 切换分支</p><p><code>git checkout -b [new-branch-name]</code> 创建并切换分支</p><hr><h4 id="4-12、reset"><a href="#4-12、reset" class="headerlink" title="4.12、reset"></a>4.12、reset</h4><p><strong>当对整个版本进行操作</strong></p><pre class="line-numbers language-none"><code class="language-none">git reset --{soft|(mixed)|hard} HEAD<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>--soft</code> 其中可选参数soft表示单纯的切换HEAD指向的commit-id</li><li><code>--mixed</code> 默认值mixed参数表示先执行上面一步，然后再将commit-id里面的内容更新到暂存区</li><li><code>--hard</code> hard表示先执行上面两步，然后再将暂存区内容同步到工作区</li></ul><p><code>git reset --hard HEAD^^</code> 用上两个版本里的所有文件撤回到暂工作区</p><p><code>git reset --hard [commit id]</code> 用指定版本的所有文件撤回到工作区</p><p><strong>当对当个文件进行操作</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> reset HEAD <span class="token punctuation">[</span>file-name<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>对单个文件操作时候只能用mixed参数，而且还是可省略</li><li>对单个文件操作时候HEAD指向不会变</li><li>将commit中指定的文件同步到暂存区中</li></ul><p><code>git reset [commit-id] [file-name]</code> 将指定commit-id中的文件替换掉暂存区的文件</p><p><strong>切换分支的比较</strong></p><p><code>git reset [branch]</code> 切换分支，但这里的切换分支和上面的<code>git checkout [branch]</code>切换分支不同，下图说明：</p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/git%E5%88%86%E6%94%AF%E5%88%87%E6%8D%A2.png" alt="image-20230925102630453"></p><h4 id="4-13、revert"><a href="#4-13、revert" class="headerlink" title="4.13、revert"></a>4.13、revert</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> revert -n <span class="token punctuation">[</span>commit-id<span class="token punctuation">]</span><span class="token function">git</span> revert -n HEAD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>撤回版本的比较</strong></p><ul><li>reset 切换版本是会删除丢弃最新的版本的，HEAD会直接跳到指定版本，但是还是可以通过reflog找回。</li></ul><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/git%E6%92%A4%E5%9B%9E%E7%89%88%E6%9C%AC%E6%AF%94%E8%BE%83.png" alt="image-20230925102718544"></p><ul><li>revert 会将指定的bug版本视为bug版，会将当前版本中的bug版的代码删除，生成新的commit覆盖掉当前commit，但是commit-id是不会变的。</li></ul><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/git%E7%9A%84revert%E5%91%BD%E4%BB%A4.png" alt="image-20230925102926761"></p><h4 id="4-14、branch"><a href="#4-14、branch" class="headerlink" title="4.14、branch"></a>4.14、branch</h4><p><code>git branch [branch-name]</code> 创建分支</p><p><code>git branch</code> 查看当前分支</p><p><code>git branch -a</code> 查看本地和远程的所有分支</p><p><code>git branch -r</code> 查看远程所有分支</p><p><code>git branch -d [branch-name]</code> 删除一个分支</p><p><code>git branch -D [branch-name]</code> 强制删除一个没有合并的分支</p><p><code>git branch --set-upstream-to=origin/[branch-name] [branch-name]</code> 把本地分支和远程分支进行连接</p><hr><h4 id="4-15、merge"><a href="#4-15、merge" class="headerlink" title="4.15、merge"></a>4.15、merge</h4><p><code>git merge</code> 合并本地<code>origin/[branch-name]</code>和<code>HEAD-&gt;[branch-name]</code>的代码，并同步到工作空间</p><p><code>git merge [branch-name]</code> 用于合并指定分支到当前分支</p><p><code>git merge --quit</code> 退出当前分支合并，当合并后冲突很多，要撤回合并分支就可以用这个命令</p><p><code>git merge --no-ff -m [massage] [branch-name]</code> 不使用Fast forward合并分支，这样会创建新的commit，所以需要massage。这样被合并的分支HEAD指向是会变的。</p><ul><li>如果使用了Fast forward方式合并分支，那么删除次要分支的时候历史分支记录也会被删除，这样就无法追寻分支合拼信息了。</li></ul><hr><h4 id="4-16、switch"><a href="#4-16、switch" class="headerlink" title="4.16、switch"></a>4.16、switch</h4><p><code>git switch -c [branch-name]</code> 创建新分支并切换到该分支</p><p><code>git switch [branch-name]</code> 切换到已有分支</p><hr><h4 id="4-17、stash"><a href="#4-17、stash" class="headerlink" title="4.17、stash"></a>4.17、stash</h4><p><code>git stash</code> 隐藏当前工作的修改</p><ul><li>如果不隐藏自己修改的半成品代码，就会发生切换到别的分支后，将然后自己的半成品代码带入其他分支，这样就发生很多不必要的麻烦。</li></ul><p><code>git stash save message</code> 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。</p><p><code>git stash list</code> 查看隐藏的工作信息列表</p><p><code>git stash drop</code> 删除隐藏的工作信息</p><p><code>git stash pop</code> 恢复隐藏的工作信息，同时删除隐藏的工作信息</p><p><code>git stash apply [stash@{0}]</code> 恢复指定的隐藏工作信息，但是不会删除隐藏的工作信息</p><hr><h4 id="4-18、cherry-pick"><a href="#4-18、cherry-pick" class="headerlink" title="4.18、cherry-pick"></a>4.18、cherry-pick</h4><p><code>git cherry-pick [commit-id]</code> 这个是复制一次commit提交，然后在当前分支上重新提交一遍；也就是将指定commit的合并到当前分支；</p><ul><li>这种适用于在其他分支上修复了bug，但是这个bug在当前分支上依然存在，所以可以复制这个commit的过程，不必重写代码。</li></ul><h4 id="4-19、remote"><a href="#4-19、remote" class="headerlink" title="4.19、remote"></a>4.19、remote</h4><p><code>git remote add origin url</code> 关联远程仓库</p><p><code>git remote</code> 查看本地添加了哪些远程分支地址</p><p><code>git remote -v</code> 查看本地添加了哪些远程分支地址更详细信息</p><p><code>git remote remove origin</code> 删除本地指定的远程地址</p><hr><h4 id="4-20、fetch"><a href="#4-20、fetch" class="headerlink" title="4.20、fetch"></a>4.20、fetch</h4><pre class="line-numbers language-none"><code class="language-none">git fetch` 拉取远程分支最新的commit到本地仓库的`origin/[branch-name]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h4 id="4-21、pull"><a href="#4-21、pull" class="headerlink" title="4.21、pull"></a>4.21、pull</h4><p><code>git pull</code> 从远程仓库拉取代码到工作空间</p><p><strong>pull 和 fetch的关系</strong></p><ul><li><code>git pull</code> == <code>git fetch</code> + <code>git merge</code></li></ul><hr><h4 id="4-22、tag"><a href="#4-22、tag" class="headerlink" title="4.22、tag"></a>4.22、tag</h4><p><code>git tag</code> 查看所有标签</p><p><code>git tag [version]</code> 给当前最新的commit打上标签</p><p><code>git tag [version] [commit-id]</code> 给指定的commit-id打上标签</p><p><code>git tag -a [version] -m [massage] [commit-id]</code> 给指定的commit-id打上标签并附上说明文字</p><p><code>git tag -d [version]</code> 删除标签</p><hr><h4 id="4-23、show"><a href="#4-23、show" class="headerlink" title="4.23、show"></a>4.23、show</h4><p><code>git show [tag-name]</code> 查看标签的详细信息</p><hr><h4 id="4-24、rebase"><a href="#4-24、rebase" class="headerlink" title="4.24、rebase"></a>4.24、rebase</h4><p><code>git rebase -i HEAD~2</code> 合并前两个历史提交，会弹出vim修改信息，修改第二行的pick为s，或者为squash，squash为合并的意识，然后保存退出编辑，会打开第二个vim编辑，合并并修改commit内容，保存退出会产生一个新的commit id，这样就合并了两个commit</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Hexo</title>
      <link href="/2023/09/24/hello-world/"/>
      <url>/2023/09/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="头部设置"><a href="#头部设置" class="headerlink" title="头部设置"></a>头部设置</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">---title: typora-vue-theme主题介绍date: <span class="token number">2018</span>-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: <span class="token boolean">true</span>hide: <span class="token boolean">false</span>cover: <span class="token boolean">true</span>coverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: <span class="token boolean">false</span>mathjax: <span class="token boolean">false</span>summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="友链格式"><a href="#友链格式" class="headerlink" title="友链格式"></a>友链格式</h3><pre class="line-numbers language-none"><code class="language-none">- [![标题](https://example.com/logo.png)](https://example.com/ "标题")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/1.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker-compose教程</title>
      <link href="/2022/05/29/ctf-xue-xi/yi-ji-chu-zhi-shi/docker/docker-compose-jiao-cheng/"/>
      <url>/2022/05/29/ctf-xue-xi/yi-ji-chu-zhi-shi/docker/docker-compose-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-compose教程"><a href="#Docker-compose教程" class="headerlink" title="Docker-compose教程"></a>Docker-compose教程</h1><h2 id="1-Compose介绍"><a href="#1-Compose介绍" class="headerlink" title="1.Compose介绍"></a>1.Compose介绍</h2><p>​        DockerCompose是一个用来定义和运行复杂应用的Docker工具。一个使用Docker容器的应用，通常由多个容器组成。使用Docker Compose不再需要使用shell脚本来启动容器。<br>​        Compose 通过一个配置文件来管理多个Docker容器，在配置文件中，所有的容器通过services来定义，然后使用docker-compose脚本来启动，停止和重启应用，和应用中的服务以及所有依赖服务的容器，非常适合组合使用多个容器进行开发的场景。</p><h2 id="2-Compose和Docker兼容性"><a href="#2-Compose和Docker兼容性" class="headerlink" title="2.Compose和Docker兼容性"></a>2.Compose和Docker兼容性</h2><table><thead><tr><th align="center">compose文件格式版本</th><th align="center">docker版本</th></tr></thead><tbody><tr><td align="center">3.4</td><td align="center">17.09.0+</td></tr><tr><td align="center">3.3</td><td align="center">17.06.0+</td></tr><tr><td align="center">3.2</td><td align="center">17.04.0+</td></tr><tr><td align="center">3.1</td><td align="center">1.13.1+</td></tr><tr><td align="center">3.0</td><td align="center">1.13.0+</td></tr><tr><td align="center">2.3</td><td align="center">17.06.0+</td></tr><tr><td align="center">2.2</td><td align="center">1.13.0+</td></tr><tr><td align="center">2.1</td><td align="center">1.12.0+</td></tr><tr><td align="center">2.0</td><td align="center">1.10.0+</td></tr><tr><td align="center">1.0</td><td align="center">1.9.1.+</td></tr></tbody></table><p><strong>Docker版本变化说明</strong>：</p><p>​        Docker从1.13.x版本开始，版本分为企业版EE和社区版CE，版本号也改为按照时间线来发布，比如17.03就是2017年3月。</p><p>​        Docker的linux发行版的软件仓库从以前的<code>https://apt.dockerproject.org</code>和<code>https://[yum](https://so.csdn.net/so/search?q=yum&amp;spm=1001.2101.3001.7020).dockerproject.org</code>变更为目前的<code>https://download.docker.com</code>, 软件包名字改为docker-ce和docker-ee。</p><h2 id="3-安装docker"><a href="#3-安装docker" class="headerlink" title="3.安装docker"></a>3.安装docker</h2><p>​        Docker的社区版（Docker Community Edition）叫做docker-ce。老版本的Docker包叫做docker或者docker-engine，如果安装了老版本的docker得先卸载然后再安装新版本的docker。docker的发展非常迅速，apt源的更新往往比较滞后。所以docker官网推荐的安装方式都是下载docker安装脚本安装。 </p><p>卸载老旧的版本（若未安装过可省略此步）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt-get</span> remove <span class="token function">docker</span> docker-engine docker.io<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装最新的docker：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">curl</span> -fsSL get.docker.com -o get-docker.sh$ <span class="token function">sudo</span> <span class="token function">sh</span> get-docker.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>shell会提示你输入sudo的密码，然后开始执行最新的docker过程 ，或者</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">curl</span> -sSL https://get.docker.com/ <span class="token operator">|</span> <span class="token function">sh</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>确认Docker成功最新的docker：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">docker</span> run hello-world<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-安装docker-compose"><a href="#4-安装docker-compose" class="headerlink" title="4.安装docker-compose"></a>4.安装docker-compose</h2><p>两种最新的docker安装方式</p><h3 id="1-从github上下载docker-compose二进制文件安装"><a href="#1-从github上下载docker-compose二进制文件安装" class="headerlink" title="1.从github上下载docker-compose二进制文件安装"></a>1.从github上下载docker-compose二进制文件安装</h3><ul><li>下载最新版的docker-compose文件 </li></ul><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">sudo</span> <span class="token attr-value">curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 若是github访问太慢，可以用daocloud下载</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">sudo</span> <span class="token attr-value">curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>添加可执行权限</li></ul><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">sudo</span> <span class="token attr-value">chmod +x /usr/local/bin/docker-compose</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>测试安装结果</li></ul><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">$</span> <span class="token attr-value">docker-compose --version</span><span class="token attr-name">docker-compose</span> <span class="token attr-value">version 1.16.1, build 1719ceb</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-pip安装"><a href="#2-pip安装" class="headerlink" title="2.pip安装"></a>2.pip安装</h3><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">sudo</span> <span class="token attr-value">pip install docker-compose</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="5-docker-compose文件结构和示例"><a href="#5-docker-compose文件结构和示例" class="headerlink" title="5.docker-compose文件结构和示例"></a>5.docker-compose文件结构和示例</h2><h3 id="docker-compose文件结构"><a href="#docker-compose文件结构" class="headerlink" title="docker-compose文件结构"></a>docker-compose文件结构</h3><p>docker-compose.yml:</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">version</span><span class="token punctuation">:</span> <span class="token attr-value">"3"</span><span class="token attr-name">services</span><span class="token punctuation">:</span>  <span class="token attr-name">  redis</span><span class="token punctuation">:</span><span class="token attr-name">    image</span><span class="token punctuation">:</span> <span class="token attr-value">redis:alpine</span><span class="token attr-name">    ports</span><span class="token punctuation">:</span><span class="token attr-name">      -</span> <span class="token attr-value">"6379"</span><span class="token attr-name">    networks</span><span class="token punctuation">:</span><span class="token attr-name">      -</span> <span class="token attr-value">frontend</span><span class="token attr-name">    deploy</span><span class="token punctuation">:</span><span class="token attr-name">      replicas</span><span class="token punctuation">:</span> <span class="token attr-value">2</span><span class="token attr-name">      update_config</span><span class="token punctuation">:</span><span class="token attr-name">        parallelism</span><span class="token punctuation">:</span> <span class="token attr-value">2</span><span class="token attr-name">        delay</span><span class="token punctuation">:</span> <span class="token attr-value">10s</span><span class="token attr-name">      restart_policy</span><span class="token punctuation">:</span><span class="token attr-name">        condition</span><span class="token punctuation">:</span> <span class="token attr-value">on-failure</span>  <span class="token attr-name">  db</span><span class="token punctuation">:</span><span class="token attr-name">    image</span><span class="token punctuation">:</span> <span class="token attr-value">postgres:9.4</span><span class="token attr-name">    volumes</span><span class="token punctuation">:</span><span class="token attr-name">      -</span> <span class="token attr-value">db-data:/var/lib/postgresql/data</span><span class="token attr-name">    networks</span><span class="token punctuation">:</span><span class="token attr-name">      -</span> <span class="token attr-value">backend</span><span class="token attr-name">    deploy</span><span class="token punctuation">:</span><span class="token attr-name">      placement</span><span class="token punctuation">:</span><span class="token attr-name">        constraints</span><span class="token punctuation">:</span> <span class="token attr-value">[node.role == manager]</span><span class="token attr-name"> vote</span><span class="token punctuation">:</span><span class="token attr-name">    image</span><span class="token punctuation">:</span> <span class="token attr-value">dockersamples/examplevotingapp_vote:before</span><span class="token attr-name">    ports</span><span class="token punctuation">:</span><span class="token attr-name">      -</span> <span class="token attr-value">5000:80</span><span class="token attr-name">    networks</span><span class="token punctuation">:</span><span class="token attr-name">      -</span> <span class="token attr-value">frontend</span><span class="token attr-name">    depends_on</span><span class="token punctuation">:</span><span class="token attr-name">      -</span> <span class="token attr-value">redis</span><span class="token attr-name">    deploy</span><span class="token punctuation">:</span><span class="token attr-name">      replicas</span><span class="token punctuation">:</span> <span class="token attr-value">2</span><span class="token attr-name">      update_config</span><span class="token punctuation">:</span><span class="token attr-name">        parallelism</span><span class="token punctuation">:</span> <span class="token attr-value">2</span><span class="token attr-name">      restart_policy</span><span class="token punctuation">:</span><span class="token attr-name">        condition</span><span class="token punctuation">:</span> <span class="token attr-value">on-failure</span><span class="token attr-name">  result</span><span class="token punctuation">:</span><span class="token attr-name">    image</span><span class="token punctuation">:</span> <span class="token attr-value">dockersamples/examplevotingapp_result:before</span><span class="token attr-name">    ports</span><span class="token punctuation">:</span><span class="token attr-name">      -</span> <span class="token attr-value">5001:80</span><span class="token attr-name">    networks</span><span class="token punctuation">:</span><span class="token attr-name">      -</span> <span class="token attr-value">backend</span><span class="token attr-name">    depends_on</span><span class="token punctuation">:</span><span class="token attr-name">      -</span> <span class="token attr-value">db</span><span class="token attr-name">    deploy</span><span class="token punctuation">:</span><span class="token attr-name">      replicas</span><span class="token punctuation">:</span> <span class="token attr-value">1</span><span class="token attr-name">      update_config</span><span class="token punctuation">:</span><span class="token attr-name">        parallelism</span><span class="token punctuation">:</span> <span class="token attr-value">2</span><span class="token attr-name">        delay</span><span class="token punctuation">:</span> <span class="token attr-value">10s</span><span class="token attr-name">      restart_policy</span><span class="token punctuation">:</span><span class="token attr-name">        condition</span><span class="token punctuation">:</span> <span class="token attr-value">on-failure</span><span class="token attr-name">  worker</span><span class="token punctuation">:</span><span class="token attr-name">    image</span><span class="token punctuation">:</span> <span class="token attr-value">dockersamples/examplevotingapp_worker</span><span class="token attr-name">    networks</span><span class="token punctuation">:</span><span class="token attr-name">      -</span> <span class="token attr-value">frontend</span><span class="token attr-name">      -</span> <span class="token attr-value">backend</span><span class="token attr-name">    deploy</span><span class="token punctuation">:</span><span class="token attr-name">      mode</span><span class="token punctuation">:</span> <span class="token attr-value">replicated</span><span class="token attr-name">      replicas</span><span class="token punctuation">:</span> <span class="token attr-value">1</span><span class="token attr-name">      labels</span><span class="token punctuation">:</span> <span class="token attr-value">[APP=VOTING]</span><span class="token attr-name">      restart_policy</span><span class="token punctuation">:</span><span class="token attr-name">        condition</span><span class="token punctuation">:</span> <span class="token attr-value">on-failure</span><span class="token attr-name">        delay</span><span class="token punctuation">:</span> <span class="token attr-value">10s</span><span class="token attr-name">        max_attempts</span><span class="token punctuation">:</span> <span class="token attr-value">3</span><span class="token attr-name">        window</span><span class="token punctuation">:</span> <span class="token attr-value">120s</span><span class="token attr-name">      placement</span><span class="token punctuation">:</span><span class="token attr-name">        constraints</span><span class="token punctuation">:</span> <span class="token attr-value">[node.role == manager]</span><span class="token attr-name">  visualizer</span><span class="token punctuation">:</span><span class="token attr-name">    image</span><span class="token punctuation">:</span> <span class="token attr-value">dockersamples/visualizer:stable</span><span class="token attr-name">    ports</span><span class="token punctuation">:</span><span class="token attr-name">      -</span> <span class="token attr-value">"8080:8080"</span><span class="token attr-name">    stop_grace_period</span><span class="token punctuation">:</span> <span class="token attr-value">1m30s</span><span class="token attr-name">    volumes</span><span class="token punctuation">:</span><span class="token attr-name">      -</span> <span class="token attr-value">"/var/run/docker.sock:/var/run/docker.sock"</span><span class="token attr-name">    deploy</span><span class="token punctuation">:</span><span class="token attr-name">      placement</span><span class="token punctuation">:</span><span class="token attr-name">        constraints</span><span class="token punctuation">:</span> <span class="token attr-value">[node.role == manager]</span><span class="token attr-name">networks</span><span class="token punctuation">:</span><span class="token attr-name">  frontend</span><span class="token punctuation">:</span><span class="token attr-name">  backend</span><span class="token punctuation">:</span>  <span class="token attr-name">volumes</span><span class="token punctuation">:</span><span class="token attr-name">  db-data</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="docker-compose使用示例"><a href="#docker-compose使用示例" class="headerlink" title="docker-compose使用示例"></a>docker-compose使用示例</h3><p>通过docker-compose构建一个在docker中运行的基于python flask框架的web应用。</p><blockquote><p><strong>注意：</strong>确保你已经安装了Docker Engine和Docker Compose。 您不需要安装Python或Redis，因为这两个都是由Docker镜像提供的。</p></blockquote><p><strong>Step 1: 定义python应用</strong></p><ul><li>1 .创建工程目录</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mkdir</span> compose_test$ <span class="token builtin class-name">cd</span> compose_test$ <span class="token function">mkdir</span> src      <span class="token comment"># 源码文件夹</span>$ <span class="token function">mkdir</span> <span class="token function">docker</span>  <span class="token comment"># docker配置文件夹</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>目录结构如下： </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">└── compose_test    ├── <span class="token function">docker</span>    │   └── docker-compose.yml    ├── Dockerfile    └── src        ├── app.py        └── requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>2 .在compose_test/src/目录下创建python flask应用 compose_test/src/app.py文件。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask<span class="token keyword">from</span> redis <span class="token keyword">import</span> Redisapp <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>redis <span class="token operator">=</span> Redis<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">'redis'</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">6379</span><span class="token punctuation">)</span><span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>route</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> redis<span class="token punctuation">.</span>incr<span class="token punctuation">(</span><span class="token string">'hits'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token string">'Hello World! I have been seen {} times.\n'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    app<span class="token punctuation">.</span>run<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">"0.0.0.0"</span><span class="token punctuation">,</span> debug<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>3 .创建python 需求文件 compose_test/src/requirements.txt</li></ul><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">flaskredis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>Step 2: 创建容器的Dockerfile文件</strong></p><p>一个容器一个Dockerfile文件，在compose_test/目录中创建Dockerfile文件：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">FROM</span> <span class="token attr-value">python:3.7</span><span class="token attr-name">COPY</span> <span class="token attr-value">src/ /opt/src</span><span class="token attr-name">WORKDIR</span> <span class="token attr-value">/opt/src</span><span class="token attr-name">RUN</span> <span class="token attr-value">pip install -r requirements.txt</span><span class="token attr-name">CMD</span> <span class="token attr-value">["python", "app.py"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Dockerfile文件告诉docker了如下信息：</p><p>从Python 3.7的镜像开始构建一个容器镜像。 </p><p>复制src（即compose_test/src）目录到容器中的/opt/src目录。 </p><p>将容器的工作目录设置为/opt/src（通过docker exec -it your_docker_container_id bash 进入容器后的默认目录）。<br>安装Python依赖关系。<br>将容器的默认命令设置为python app.py。</p><p><strong>Step 3: 定义docker-compose脚本</strong></p><p>在compose_test/docker/目录下创建docker-compose.yml文件，并在里面定义服务，内容如下：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">version</span><span class="token punctuation">:</span> <span class="token attr-value">'3'</span><span class="token attr-name">services</span><span class="token punctuation">:</span><span class="token attr-name">  web</span><span class="token punctuation">:</span><span class="token attr-name">    build</span><span class="token punctuation">:</span> <span class="token attr-value">../</span><span class="token attr-name">    ports</span><span class="token punctuation">:</span><span class="token attr-name">     -</span> <span class="token attr-value">"5000:5000"</span><span class="token attr-name">  redis</span><span class="token punctuation">:</span><span class="token attr-name">    image</span><span class="token punctuation">:</span> <span class="token attr-value">redis:3.0.7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个compose文件定义了两个服务，即定义了web和redis两个容器。<br><strong>web容器：</strong> </p><ul><li>使用当前<code>docker-compose.yml</code>文件所在目录的上级目录（compose_test/Dockerfile）中的Dockerfile构建映像。 </li><li>将容器上的暴露端口5000映射到主机上的端口5000。 我们使用Flask Web服务器的默认端口5000。 </li></ul><p><strong>redis容器：</strong> </p><ul><li>redis服务使用从Docker Hub提取的官方redis镜像3.0.7版本。</li></ul><p><strong>Step 4: 使用Compose构建并运行您的应用程序</strong></p><p>在<code>compose_test/docker/</code>目录下执行<code>docker-compose.yml</code>文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker-compose</span> up<span class="token comment"># 若是要后台运行： $ docker-compose up -d</span><span class="token comment"># 若不使用默认的docker-compose.yml 文件名：</span>$ <span class="token function">docker-compose</span> -f server.yml up -d <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在浏览器中输入<code>http://0.0.0.0:5000/</code>查看运行的应用程序。</p><p><strong>Step 5: 编辑compose文件以添加文件绑定挂载</strong></p><p>​        上面的代码是在构建时静态复制到容器中的，即通过Dockerfile文件中的COPY src /opt/src命令实现物理主机中的源码复制到容器中，这样在后续物理主机src目录中代码的更改不会反应到容器中。<br>​        可以通过volumes 关键字实现物理主机目录挂载到容器中的功能（同时删除Dockerfile中的COPY指令，不需要创建镜像时将代码打包进镜像，而是通过volums动态挂载，容器和物理host共享数据卷）：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">version</span><span class="token punctuation">:</span> <span class="token attr-value">'3'</span><span class="token attr-name">services</span><span class="token punctuation">:</span><span class="token attr-name">  web</span><span class="token punctuation">:</span><span class="token attr-name">    build</span><span class="token punctuation">:</span> <span class="token attr-value">../</span><span class="token attr-name">    ports</span><span class="token punctuation">:</span><span class="token attr-name">     -</span> <span class="token attr-value">"5000:5000"</span><span class="token attr-name">    volumes</span><span class="token punctuation">:</span><span class="token attr-name">     -</span> <span class="token attr-value">../src:/opt/src</span><span class="token attr-name">  redis</span><span class="token punctuation">:</span><span class="token attr-name">    image</span><span class="token punctuation">:</span> <span class="token attr-value">"redis:3.0.7"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过volumes（卷）将主机上的项目目录（compose_test/src）挂载到容器中的/opt/src目录，允许您即时修改代码，而无需重新构建镜像。</p><p><strong>Step 6: 重新构建和运行应用程序</strong></p><p>使用更新的compose文件构建应用程序，然后运行它。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">docker-compose</span> up -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="6-compose常用服务配置参考"><a href="#6-compose常用服务配置参考" class="headerlink" title="6.compose常用服务配置参考"></a>6.compose常用服务配置参考</h2><p>​        Compose文件是一个定义服务，网络和卷的YAML文件。 Compose文件的默认文件名为docker-compose.yml。</p><blockquote><p>提示：您可以对此文件使用.yml或.yaml扩展名。 他们都工作。</p></blockquote><p>​        与docker运行一样，默认情况下，Dockerfile中指定的选项（例如，CMD，EXPOSE，VOLUME，ENV）都被遵守，你不需要在docker-compose.yml中再次指定它们。</p><p>​        同时你可以使用类似Bash的$ {VARIABLE} 语法在配置值中使用环境变量，有关详细信息，请参阅<a href="https://docs.docker.com/compose/compose-file/#variable-substitution">变量替换</a>。</p><p>​        本节包含版本3中服务定义支持的所有配置选项。</p><h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>​        build 可以指定包含构建上下文的路径：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">version</span><span class="token punctuation">:</span> <span class="token attr-value">'2'</span><span class="token attr-name">services</span><span class="token punctuation">:</span><span class="token attr-name">  webapp</span><span class="token punctuation">:</span><span class="token attr-name">    build</span><span class="token punctuation">:</span> <span class="token attr-value">./dir</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>或者，作为一个对象，该对象具有上下文路径和指定的Dockerfile文件以及args参数值：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">version</span><span class="token punctuation">:</span> <span class="token attr-value">'2'</span><span class="token attr-name">services</span><span class="token punctuation">:</span><span class="token attr-name">  webapp</span><span class="token punctuation">:</span><span class="token attr-name">    build</span><span class="token punctuation">:</span><span class="token attr-name">      context</span><span class="token punctuation">:</span> <span class="token attr-value">./dir</span><span class="token attr-name">      dockerfile</span><span class="token punctuation">:</span> <span class="token attr-value">Dockerfile-alternate</span><span class="token attr-name">      args</span><span class="token punctuation">:</span><span class="token attr-name">        buildno</span><span class="token punctuation">:</span> <span class="token attr-value">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>webapp服务将会通过./dir目录下的Dockerfile-alternate文件构建容器镜像。 </p><p>如果你同时指定image和build，则compose会通过build指定的目录构建容器镜像，而构建的镜像名为image中指定的镜像名和标签。</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">build</span><span class="token punctuation">:</span> <span class="token attr-value">./dir</span><span class="token attr-name">image</span><span class="token punctuation">:</span> <span class="token attr-value">webapp:tag</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这将由./dir构建的名为webapp和标记为tag的镜像。</p><p><strong>context</strong></p><p>​        包含Dockerfile文件的目录路径，或者是git仓库的URL。<br>​        当提供的值是相对路径时，它被解释为相对于当前compose文件的位置。 该目录也是发送到Docker守护程序构建镜像的上下文。</p><p><strong>dockerfile</strong></p><p>​        备用Docker文件。Compose将使用备用文件来构建。 还必须指定构建路径。</p><p><strong>args</strong></p><p>​        添加构建镜像的参数，环境变量只能在构建过程中访问。<br>​        首先，在Dockerfile中指定要使用的参数：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">ARG</span> <span class="token attr-value">buildno</span><span class="token attr-name">ARG</span> <span class="token attr-value">password</span><span class="token attr-name">RUN</span> <span class="token attr-value">echo "Build number: $buildno"</span><span class="token attr-name">RUN</span> <span class="token attr-value">script-requiring-password.sh "$password"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        然后在args键下指定参数。 你可以传递映射或列表：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">build</span><span class="token punctuation">:</span><span class="token attr-name">  context</span><span class="token punctuation">:</span> <span class="token attr-value">.</span><span class="token attr-name">  args</span><span class="token punctuation">:</span><span class="token attr-name">    buildno</span><span class="token punctuation">:</span> <span class="token attr-value">1</span><span class="token attr-name">    password</span><span class="token punctuation">:</span> <span class="token attr-value">secret</span><span class="token attr-name">build</span><span class="token punctuation">:</span><span class="token attr-name">  context</span><span class="token punctuation">:</span> <span class="token attr-value">.</span><span class="token attr-name">  args</span><span class="token punctuation">:</span><span class="token attr-name">    -</span> <span class="token attr-value">buildno=1</span><span class="token attr-name">    -</span> <span class="token attr-value">password=secret</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：YAML布尔值（true，false，yes，no，on，off）必须用引号括起来，以便解析器将它们解释为字符串。</p></blockquote><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>​        指定启动容器的镜像，可以是镜像仓库/标签或者镜像id（或者id的前一部分）</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">image</span><span class="token punctuation">:</span> <span class="token attr-value">redis</span><span class="token attr-name">image</span><span class="token punctuation">:</span> <span class="token attr-value">ubuntu:14.04</span><span class="token attr-name">image</span><span class="token punctuation">:</span> <span class="token attr-value">tutum/influxdb</span><span class="token attr-name">image</span><span class="token punctuation">:</span> <span class="token attr-value">example-registry.com:4000/postgresql</span><span class="token attr-name">image</span><span class="token punctuation">:</span> <span class="token attr-value">a4bc65fd</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        如果镜像不存在，Compose将尝试从官方镜像仓库将其pull下来，如果你还指定了build，在这种情况下，它将使用指定的build选项构建它，并使用image指定的名字和标记对其进行标记。</p><h3 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h3><p>​        指定一个自定义容器名称，而不是生成的默认名称。</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">container_name</span><span class="token punctuation">:</span> <span class="token attr-value">my-web-container</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于Docker容器名称必须是唯一的，因此如果指定了自定义名称，则无法将服务扩展到多个容器。</p><h3 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h3><p>​        卷挂载路径设置。可以设置宿主机路径 （HOST:CONTAINER） 或加上访问模式 （HOST:CONTAINER:ro）,挂载数据卷的默认权限是读写（rw），可以通过ro指定为只读。<br>​        用户可以在主机上挂载相对路径，该路径将相对于当前正在使用的Compose配置文件的目录进行扩展。 相对路径应始终以 . 或者 .. 开始。</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">volumes</span><span class="token punctuation">:</span><span class="token comment">  # 只需指定一个路径，让引擎创建一个卷</span><span class="token attr-name">  -</span> <span class="token attr-value">/var/lib/mysql</span><span class="token comment">  # 指定绝对路径映射</span><span class="token attr-name">  -</span> <span class="token attr-value">/opt/data:/var/lib/mysql</span><span class="token comment">  # 相对于当前compose文件的相对路径</span><span class="token attr-name">  -</span> <span class="token attr-value">./cache:/tmp/cache</span><span class="token comment">  # 用户家目录相对路径</span><span class="token attr-name">  -</span> <span class="token attr-value">~/configs:/etc/configs/:ro</span><span class="token comment">  # 命名卷</span><span class="token attr-name">  -</span> <span class="token attr-value">datavolume:/var/lib/mysql</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，如果要跨多个服务并重用挂载卷，请在顶级volumes关键字中命名挂在卷，但是并不强制，如下的示例亦有重用挂载卷的功能，但是不提倡。</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">version</span><span class="token punctuation">:</span> <span class="token attr-value">"3"</span><span class="token attr-name">services</span><span class="token punctuation">:</span><span class="token attr-name">  web1</span><span class="token punctuation">:</span><span class="token attr-name">    build</span><span class="token punctuation">:</span> <span class="token attr-value">./web/</span><span class="token attr-name">    volumes</span><span class="token punctuation">:</span><span class="token attr-name">      -</span> <span class="token attr-value">../code:/opt/web/code</span><span class="token attr-name">  web2</span><span class="token punctuation">:</span><span class="token attr-name">    build</span><span class="token punctuation">:</span> <span class="token attr-value">./web/</span><span class="token attr-name">    volumes</span><span class="token punctuation">:</span><span class="token attr-name">      -</span> <span class="token attr-value">../code:/opt/web/code</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：通过顶级volumes定义一个挂载卷，并从每个服务的卷列表中引用它， 这会替换早期版本的Compose文件格式中volumes_from。</p></blockquote><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">version</span><span class="token punctuation">:</span> <span class="token attr-value">"3"</span><span class="token attr-name">services</span><span class="token punctuation">:</span><span class="token attr-name">  db</span><span class="token punctuation">:</span><span class="token attr-name">    image</span><span class="token punctuation">:</span> <span class="token attr-value">db</span><span class="token attr-name">    volumes</span><span class="token punctuation">:</span><span class="token attr-name">      -</span> <span class="token attr-value">data-volume:/var/lib/db</span><span class="token attr-name">  backup</span><span class="token punctuation">:</span><span class="token attr-name">    image</span><span class="token punctuation">:</span> <span class="token attr-value">backup-service</span><span class="token attr-name">    volumes</span><span class="token punctuation">:</span><span class="token attr-name">      -</span> <span class="token attr-value">data-volume:/var/lib/backup/data</span><span class="token attr-name">volumes</span><span class="token punctuation">:</span><span class="token attr-name">  data-volume</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="command"><a href="#command" class="headerlink" title="command"></a>command</h3><p>覆盖容器启动后默认执行的命令。</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">command</span><span class="token punctuation">:</span> <span class="token attr-value">bundle exec thin -p 3000</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该命令也可以是一个类似于dockerfile的列表：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">command</span><span class="token punctuation">:</span> <span class="token attr-value">["bundle", "exec", "thin", "-p", "3000"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="links"><a href="#links" class="headerlink" title="links"></a>links</h3><p>链接到另一个服务中的容器。 请指定服务名称和链接别名（SERVICE：ALIAS），或者仅指定服务名称。</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">web</span><span class="token punctuation">:</span><span class="token attr-name">  links</span><span class="token punctuation">:</span><span class="token attr-name">   -</span> <span class="token attr-value">db</span><span class="token attr-name">   -</span> <span class="token attr-value">db:database</span><span class="token attr-name">   -</span> <span class="token attr-value">redis</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在当前的web服务的容器中可以通过链接的db服务的别名database访问db容器中的数据库应用，如果没有指定别名，则可直接使用服务名访问。</p><p>链接不需要启用服务进行通信 - 默认情况下，任何服务都可以以该服务的名称到达任何其他服务。 （实际是通过设置/etc/hosts的域名解析，从而实现容器间的通信。故可以像在应用中使用localhost一样使用服务的别名链接其他容器的服务，前提是多个服务容器在一个网络中可路由联通）</p><p>links也可以起到和depends_on相似的功能，即定义服务之间的依赖关系，从而确定服务启动的顺序。</p><h3 id="external-links"><a href="#external-links" class="headerlink" title="external_links"></a>external_links</h3><p>链接到docker-compose.yml 外部的容器，甚至并非 Compose 管理的容器。参数格式跟 links 类似。</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">external_links</span><span class="token punctuation">:</span><span class="token attr-name"> -</span> <span class="token attr-value">redis_1</span><span class="token attr-name"> -</span> <span class="token attr-value">project_db_1:mysql</span><span class="token attr-name"> -</span> <span class="token attr-value">project_db_1:postgresql</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h3><p>暴露端口，但不映射到宿主机，只被连接的服务访问。<br>仅可以指定内部端口为参数</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">expose</span><span class="token punctuation">:</span><span class="token attr-name"> -</span> <span class="token attr-value">"3000"</span><span class="token attr-name"> -</span> <span class="token attr-value">"8000"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h3><p>暴露端口信息。<br>常用的简单格式：使用宿主：容器 （HOST:CONTAINER）格式或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p><blockquote><p>注意：当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 你可能会得到错误得结果，因为 YAML 将会解析 xx:yy 这种数字格式为 60 进制。所以建议采用字符串格式。</p></blockquote><p>简单的短格式：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">ports</span><span class="token punctuation">:</span><span class="token attr-name"> -</span> <span class="token attr-value">"3000"</span><span class="token attr-name"> -</span> <span class="token attr-value">"3000-3005"</span><span class="token attr-name"> -</span> <span class="token attr-value">"8000:8000"</span><span class="token attr-name"> -</span> <span class="token attr-value">"9090-9091:8080-8081"</span><span class="token attr-name"> -</span> <span class="token attr-value">"49100:22"</span><span class="token attr-name"> -</span> <span class="token attr-value">"127.0.0.1:8001:8001"</span><span class="token attr-name"> -</span> <span class="token attr-value">"127.0.0.1:5000-5010:5000-5010"</span><span class="token attr-name"> -</span> <span class="token attr-value">"6060:6060/udp"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在v3.2中ports的长格式的语法允许配置不能用短格式表示的附加字段。<br>长格式：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">ports</span><span class="token punctuation">:</span><span class="token attr-name">  -</span> <span class="token attr-value">target: 80</span><span class="token attr-name">    published</span><span class="token punctuation">:</span> <span class="token attr-value">8080</span><span class="token attr-name">    protocol</span><span class="token punctuation">:</span> <span class="token attr-value">tcp</span><span class="token attr-name">    mode</span><span class="token punctuation">:</span> <span class="token attr-value">host</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>target：容器内的端口 </li><li>published：物理主机的端口 </li><li>protocol：端口协议（tcp或udp） </li><li>mode：host 和ingress 两总模式，host用于在每个节点上发布主机端口，ingress 用于被负载平衡的swarm模式端口。</li></ul><h3 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h3><p>no是默认的重启策略，在任何情况下都不会重启容器。 指定为always时，容器总是重新启动。 如果退出代码指示出现故障错误，则on-failure将重新启动容器。</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">restart</span><span class="token punctuation">:</span> <span class="token attr-value">"no"</span><span class="token attr-name">restart</span><span class="token punctuation">:</span> <span class="token attr-value">always</span><span class="token attr-name">restart</span><span class="token punctuation">:</span> <span class="token attr-value">on-failure</span><span class="token attr-name">restart</span><span class="token punctuation">:</span> <span class="token attr-value">unless-stopped</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h3><p>添加环境变量。 你可以使用数组或字典两种形式。 任何布尔值; true，false，yes，no需要用引号括起来，以确保它们不被YML解析器转换为True或False。<br>只给定名称的变量会自动获取它在 Compose 主机上的值，可以用来防止泄露不必要的数据。</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">environment</span><span class="token punctuation">:</span><span class="token attr-name">  RACK_ENV</span><span class="token punctuation">:</span> <span class="token attr-value">development</span><span class="token attr-name">  SHOW</span><span class="token punctuation">:</span> <span class="token attr-value">'true'</span><span class="token attr-name">  SESSION_SECRET</span><span class="token punctuation">:</span><span class="token attr-name">environment</span><span class="token punctuation">:</span><span class="token attr-name">  -</span> <span class="token attr-value">RACK_ENV=development</span><span class="token attr-name">  -</span> <span class="token attr-value">SHOW=true</span><span class="token attr-name">  -</span> <span class="token attr-value">SESSION_SECRET</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：如果你的服务指定了build选项，那么在构建过程中通过environment定义的环境变量将不会起作用。 将使用build的args子选项来定义构建时的环境变量。</p></blockquote><h3 id="pid"><a href="#pid" class="headerlink" title="pid"></a>pid</h3><p>将PID模式设置为主机PID模式。 这就打开了容器与主机操作系统之间的共享PID地址空间。 使用此标志启动的容器将能够访问和操作裸机的命名空间中的其他容器，反之亦然。即打开该选项的容器可以相互通过进程 ID 来访问和操作。</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">pid</span><span class="token punctuation">:</span> <span class="token attr-value">"host"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h3><p>配置 DNS 服务器。可以是一个值，也可以是一个列表。</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">dns</span><span class="token punctuation">:</span> <span class="token attr-value">8.8.8.8</span><span class="token attr-name">dns</span><span class="token punctuation">:</span><span class="token attr-name">  -</span> <span class="token attr-value">8.8.8.8</span><span class="token attr-name">  -</span> <span class="token attr-value">9.9.9.9</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker镜像</title>
      <link href="/2022/04/05/ctf-xue-xi/yi-ji-chu-zhi-shi/docker/docker-jing-xiang/"/>
      <url>/2022/04/05/ctf-xue-xi/yi-ji-chu-zhi-shi/docker/docker-jing-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Docker镜像"><a href="#一、Docker镜像" class="headerlink" title="一、Docker镜像"></a>一、Docker镜像</h1><h2 id="1-1-镜像-UnionFS（联合文件系统）"><a href="#1-1-镜像-UnionFS（联合文件系统）" class="headerlink" title="1.1 镜像 / UnionFS（联合文件系统）"></a>1.1 镜像 / UnionFS（联合文件系统）</h2><p>​        Union文件系统（UnionFS）是一种<strong>分层、轻量级并且高性能的文件系统</strong>，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。<strong>Union 文件系统是 Docker 镜像的基础。</strong>镜像可以通过分层来进行继承. 基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><p><strong>特性：</strong><br>        一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E9%95%9C%E5%83%8F%E5%9B%BE%E8%A7%A3.png" alt="image-20220405100219244" style="zoom:80%;"><p>总结:<br>        镜像就像洋葱圈 ,就像莲花卷 ,一层套一层 ,对外只显示一个文件系统。而且, 这种分层镜像还可以复用</p><h2 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h2><p>​        <strong>Dcoker镜像都是只读的 , 当启动容器时, 一个新的可写层被加载到镜像的顶部，这一层被称为”容器层”, “容器层”执行的都称为”镜像层”</strong></p><h2 id="1-3-Docker镜像加载原理："><a href="#1-3-Docker镜像加载原理：" class="headerlink" title="1.3 Docker镜像加载原理："></a>1.3 Docker镜像加载原理：</h2><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件构成文件系统UnionFS。</p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220405100330153.png" alt="image-20220405100330153"></p><p>​        <strong>bootfs(boot file system)</strong> 主要包含<strong>bootloader和kernel</strong>，<strong>bootloader主要作用是引导加载kernel</strong>, Linux刚启动时会加载bootfs文件系统，<strong>Docker镜像的最底层是bootfs</strong>。<br>​        这一层与典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p><p>​        <strong>rootfs (root file system)</strong> ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。<strong>rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</strong></p><p>平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才220M？</p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220405100348059.png" alt="image-20220405100348059"></p><p>​        对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，<strong>因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。</strong>由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此<strong>不同的发行版可以公用bootfs。</strong></p><h2 id="1-4-Docker镜像Commit操作"><a href="#1-4-Docker镜像Commit操作" class="headerlink" title="1.4 Docker镜像Commit操作"></a>1.4 Docker镜像Commit操作</h2><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 提交容器副本实质成为一个新的镜像</span><span class="token attr-name">docker</span> <span class="token attr-value">commit -m="提交的描述信息" -a="作者"容器ID 要创建的目标镜像名:[标签名]</span><span class="token attr-name">eg</span><span class="token punctuation">:</span> <span class="token attr-value">同时docker运行tomcat案例</span><span class="token comment"># 1.  创建交互式界面 ( 相当于前台启动)</span><span class="token attr-name">docker</span> <span class="token attr-value">run -it -p 8888:8080 tomcat   # 端口映射将8888作为docker的入口,映射到tomcat镜像的8080(图1,图2)</span><span class="token attr-name">docker</span> <span class="token attr-value">run -it -P  tomcat  #自动端口映射(通过 docker ps查看端口, 图3)</span><span class="token comment"># 后台启动(不会占用当前页面)</span><span class="token attr-name">docker</span> <span class="token attr-value">run -d -p 8888:8080 tomcat </span><span class="token comment"># 2. 进入tomcat (如果前置启动,另开一个窗口 ,后置启动则直接进入)</span><span class="token comment"># 查看运行容器ID</span><span class="token attr-name">docker</span> <span class="token attr-value">ps  </span><span class="token comment"># 进入根目录</span><span class="token attr-name">docker</span> <span class="token attr-value">exec -it 容器ID /bin/bash</span><span class="token attr-name">/usr/local/tomcat#</span> <span class="token attr-value">rm -rf webapps/docs/ </span><span class="token comment"># 删除后访问tomcat ,可以看到访问主页下的文档出现404(图4)</span><span class="token comment"># 3. 提交容器副本实使之为一个新的镜像</span><span class="token comment"># 查看运行容器ID</span><span class="token attr-name">docker</span> <span class="token attr-value">ps  </span><span class="token comment"># 提交容器</span><span class="token attr-name">docker</span> <span class="token attr-value">commit -m="del tomcat docs" -a="timepaus" 容器ID tomcat:v1.2</span><span class="token comment"># 查看镜像(图5)</span><span class="token attr-name">docker</span> <span class="token attr-value">images</span><span class="token comment"># 4.同时启动新镜像并和原来的对比</span><span class="token comment"># 可以看到我们自己提交的新镜像也没有文档()</span><span class="token comment"># 但是我们重新下载的tomcat是有的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二、Docker容器数据卷"><a href="#二、Docker容器数据卷" class="headerlink" title="二、Docker容器数据卷"></a>二、Docker容器数据卷</h1><blockquote><p>类似Redis中的rdb文件和aof文件<br>用于容器的持久化和荣期间的继承与共享数据</p></blockquote><h2 id="2-1-容器内添加数据卷"><a href="#2-1-容器内添加数据卷" class="headerlink" title="2.1 容器内添加数据卷"></a>2.1 容器内添加数据卷</h2><h3 id="2-1-直接命令添加"><a href="#2-1-直接命令添加" class="headerlink" title="2.1 直接命令添加"></a>2.1 直接命令添加</h3><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 通过-v命令直接添加 (需要在根目录下创建 containerData  )</span><span class="token comment"># 创建后修改容器内containerData 会同步到hostData ,反之亦是如此</span><span class="token attr-name">docker</span> <span class="token attr-value">run -it -v /hostData:/containerData  镜像名/ID</span><span class="token comment"># 创建只读权限的文件 , 容器内只能读取这个文件, 但是不能修改. ro: readonly</span><span class="token attr-name">docker</span> <span class="token attr-value">run -it -v /宿主机绝路路径目录:/容器内目录:ro 镜像名</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-Docker添加"><a href="#2-2-Docker添加" class="headerlink" title="2.2 Docker添加"></a>2.2 Docker添加</h3><p>DockerFile的简单理解</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 1. 宿主机根目录下创建mydocker文件夹并进入</span><span class="token comment"># 2. 在mydocker文件想创建DockerFile文件并编辑,内容如下(图1)</span><span class="token comment"># volume test</span><span class="token attr-name">FROM</span> <span class="token attr-value">centos</span><span class="token attr-name">VOLUME</span> <span class="token attr-value">["/dataVolumeContainer1","/dataVolumeContainer2"]</span><span class="token attr-name">CMD</span> <span class="token attr-value">echo "finished,--------success1"</span><span class="token attr-name">CMD</span> <span class="token attr-value">/bin/bash</span><span class="token comment"># 说明：</span><span class="token comment"># 出于可移植和分享的考虑，用-v 主机目录:容器目录这种方法不能够直接在Dockerfile中实现。</span><span class="token comment"># 由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样的特定目录。</span><span class="token comment"># 3. 使用docker build命令创建一个镜像, 并挂载指定宿主机指定文件</span><span class="token attr-name">docker</span> <span class="token attr-value">build -f /mydocker/DockerFile -t 定义的新镜像名称</span><span class="token comment"># 4. 查看镜像</span><span class="token attr-name">docker</span> <span class="token attr-value">images</span><span class="token comment"># 5.运行新镜像</span><span class="token attr-name">docker</span> <span class="token attr-value">run -it 定义的新镜像ID /bin/bash</span><span class="token comment"># 6.通过镜像运行后生成的容器ID查看 (图2), 对应的主机映射的数据卷地址</span><span class="token attr-name">docker</span> <span class="token attr-value">ps</span><span class="token attr-name">docker</span> <span class="token attr-value">inspect 容器ID</span><span class="token comment"># 7.测试添加卷和主机是否互通有无</span><span class="token comment"># 在容器中创建文件, 看看主机中是否创建对应的文件</span><span class="token comment"># 注意: </span><span class="token comment"># Docker挂载主机目录(第3步)Docker访问出现cannot open directory .: Permission denied</span><span class="token comment"># 解决办法：在挂载目录后多加一个--privileged=true参数即可</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220405093955419.png" alt="image-20220405093955419"></p><p>查看运行的容器id相关信息 <code>docker inspect 容器ID</code></p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220405094021940.png" alt="image-2022040509402194"></p><h3 id="2-3-数据卷容器"><a href="#2-3-数据卷容器" class="headerlink" title="2.3 数据卷容器"></a>2.3 数据卷容器</h3><blockquote><p>命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，<br>挂载数据卷的容器，称之为数据卷容器</p></blockquote><p>实现步骤：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 1. 以上一步所建镜像为模板 ,首先启动一个父容器dc01 ,在创建容器的数据卷文夹中创建一个文件(图1)</span><span class="token attr-name">docker</span> <span class="token attr-value">run -it --name dc01 zzyy/centos</span><span class="token attr-name">touch</span> <span class="token attr-value">dc01_add.txt</span><span class="token comment"># 2. 创建子容器dc02,dc03继承自dc01 , 在创建容器的数据卷文夹中创建一个文件(图2)</span><span class="token attr-name">docker</span> <span class="token attr-value">run -it --name dc02 --volumes-from dc01 zzyy/centos</span><span class="token attr-name">touch</span> <span class="token attr-value">dc02_add.txt</span><span class="token attr-name">docker</span> <span class="token attr-value">run -it --name dc03 --volumes-from dc01 zzyy/centos</span><span class="token attr-name">touch</span> <span class="token attr-value">dc01=3_add.txt</span><span class="token comment"># 3. 回到dc01可以看到所有数据都被共享了(图3)</span><span class="token comment"># 4. 删除dc01, dc02修改后dc03是否可访问,可以 (图4)</span><span class="token comment"># 5. 删除dc02dc03是否可以访问, 可以(图5)</span><span class="token comment"># 6. 新建dc04继承dc03是否可以访问, 可以(图6)</span>结论<span class="token attr-name">容器之间配置信息的传递,</span> <span class="token attr-value">数据卷的生命周期一直持续到没有容器使用它为止</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220405094205126.png" alt="image-20220405094205126" style="zoom:90%;"><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220405094226717.png" alt="image-20220405094226717" style="zoom:80%;"><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220405094255171.png" alt="image-20220405094255171"></p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220405094310186.png" alt="image-20220405094310186" style="zoom:80%;"><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220405094324262.png" alt="image-20220405094324262" style="zoom:80%;"><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220405094343774.png" alt="image-20220405094343774" style="zoom:80%;"><h1 id="三、DockerFile解析"><a href="#三、DockerFile解析" class="headerlink" title="三、DockerFile解析"></a>三、DockerFile解析</h1><blockquote><p>Dockerfile是用来构建Docker镜像文件 ,是有一系列命令和参数构成的脚本</p></blockquote><h2 id="3-1-构建步骤"><a href="#3-1-构建步骤" class="headerlink" title="3.1 构建步骤"></a>3.1 构建步骤</h2><ul><li>编写Dockerfile文件</li><li>docker build</li><li>docker run</li></ul><h3 id="3-1-1-格式"><a href="#3-1-1-格式" class="headerlink" title="3.1.1 格式"></a>3.1.1 格式</h3><p>以centos的文件为例</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">FROM scratchADD centos-8-container.tar.xz /LABEL org.label-schema.schema-version<span class="token operator">=</span><span class="token string">"1.0"</span> <span class="token punctuation">\</span>    org.label-schema.name<span class="token operator">=</span><span class="token string">"CentOS Base Image"</span> <span class="token punctuation">\</span>    org.label-schema.vendor<span class="token operator">=</span><span class="token string">"CentOS"</span> <span class="token punctuation">\</span>    org.label-schema.license<span class="token operator">=</span><span class="token string">"GPLv2"</span> <span class="token punctuation">\</span>    org.label-schema.build-date<span class="token operator">=</span><span class="token string">"20190927"</span>CMD <span class="token punctuation">[</span><span class="token string">"/bin/bash"</span><span class="token punctuation">]</span><span class="token number">12345678910</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-2-语法"><a href="#3-1-2-语法" class="headerlink" title="3.1.2 语法"></a>3.1.2 语法</h3><ul><li><p>每条保留字指令都必须为答谢字母且后面至少跟一个参数</p></li><li><p>指令从上到下, 顺序执行</p></li><li><p>#表示注释</p></li><li><p>每条指令都会创建一个一个新的镜像层, 并提交</p></li></ul><h3 id="3-1-3-Docker执行DockerFile的大致流程"><a href="#3-1-3-Docker执行DockerFile的大致流程" class="headerlink" title="3.1.3 Docker执行DockerFile的大致流程"></a>3.1.3 Docker执行DockerFile的大致流程</h3><ol><li>docker从基础镜像运行一个容器</li><li>执行一条指令并对容器做出修改</li><li>执行类似docker commit 的操作提交一个新的镜像层</li><li>docker 再基于刚提交的镜像运行一个新容器</li><li>执行dockerfile 中的下一条执行, 直至所有指令都完成</li></ol><p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段，</p><ul><li>Dockerfile是软件的原材料</li><li>Docker镜像是软件的交付品</li><li>Docker容器则可以认为是软件的运行态。</li></ul><p>Dockerfile面向开发，Docker镜像成为交付标准，<br>Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。</p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220405094632169.png" alt="image-20220405094632169" style="zoom:80%;"><blockquote><p>1 Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;<br>2 Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时，会真正开始提供服务;<br>3 Docker容器，容器是直接提供服务的</p></blockquote><h2 id="3-2-DockerFile保留字指令"><a href="#3-2-DockerFile保留字指令" class="headerlink" title="3.2 DockerFile保留字指令"></a>3.2 DockerFile保留字指令</h2><p><a href="https://github.com/docker-library/tomcat/blob/8348a86101660e76224afcc57c4c9fae4dc76de8/9.0/jdk8/openjdk/Dockerfile">查看tomcat的DockerFile文件 ,更好理解保留字</a></p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220405094831612.png" alt="image-20220405094831612"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">FROM openjdk:8-jdkENV CATALINA_HOME /usr/local/tomcatENV <span class="token environment constant">PATH</span> <span class="token variable">$CATALINA_HOME</span>/bin:<span class="token environment constant">$PATH</span>RUN <span class="token function">mkdir</span> -p <span class="token string">"<span class="token variable">$CATALINA_HOME</span>"</span>WORKDIR <span class="token variable">$CATALINA_HOME</span><span class="token comment"># let "Tomcat Native" live somewhere isolated</span>ENV TOMCAT_NATIVE_LIBDIR <span class="token variable">$CATALINA_HOME</span>/native-jni-libENV LD_LIBRARY_PATH <span class="token variable">${LD_LIBRARY_PATH<span class="token operator">:+</span>$LD_LIBRARY_PATH<span class="token operator">:</span>}</span><span class="token variable">$TOMCAT_NATIVE_LIBDIR</span><span class="token comment"># see https://www.apache.org/dist/tomcat/tomcat-$TOMCAT_MAJOR/KEYS</span><span class="token comment"># see also "update.sh" (https://github.com/docker-library/tomcat/blob/master/update.sh)</span>ENV GPG_KEYS 05AB33110949707C93A279E3D3EFE6B686867BA6 07E48665A34DCAFAE522E5E6266191C37C037D42 47309207D818FFD8DCD3F83F1931D684307A10A5 541FBE7D8F78B25E055DDEE13C370389288584E7 61B832AC2F1C5A90F0F9B00A1C506407564C17A3 79F7026C690BAA50B92CD8B66A3AD3F4F22C4FED 9BA44C2621385CB966EBA586F72C284D731FABEE A27677289986DB50844682F8ACB77FC2E86E29AC A9C5DF4D22E99998D9875A5110C01C5A2F6059E7 DCFD35E0BF8CA7344752DE8B6FB21E8933C60243 F3A04C595DB5B6A5F1ECA43E3B7BBB100D811BBE F7DA48BB64BCB84ECBA7EE6935CD23C10D498E23ENV TOMCAT_MAJOR <span class="token number">9</span>ENV TOMCAT_VERSION <span class="token number">9.0</span>.27ENV TOMCAT_SHA512 408d30bf56d59941149b397e5e725a5f9baf225807397a4b7a3be79f7d211e6d878d34bf00776746a54cc7d067f168db24c367e5c7390bb7329b3bca428726ccRUN <span class="token builtin class-name">set</span> -eux<span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token punctuation">\</span><span class="token assign-left variable">savedAptMark</span><span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span>apt-mark showmanual<span class="token variable">)</span></span>"</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token function">apt-get</span> update<span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token function">apt-get</span> <span class="token function">install</span> -y --no-install-recommends <span class="token punctuation">\</span>gnupg dirmngr <span class="token punctuation">\</span><span class="token function">wget</span> ca-certificates <span class="token punctuation">\</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token punctuation">\</span><span class="token function-name function">ddist</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">\</span><span class="token builtin class-name">local</span> <span class="token assign-left variable">f</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$1</span>"</span><span class="token punctuation">;</span> <span class="token builtin class-name">shift</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token builtin class-name">local</span> <span class="token assign-left variable">distFile</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$1</span>"</span><span class="token punctuation">;</span> <span class="token builtin class-name">shift</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token builtin class-name">local</span> <span class="token assign-left variable">success</span><span class="token operator">=</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token builtin class-name">local</span> <span class="token assign-left variable">distUrl</span><span class="token operator">=</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token keyword">for</span> <span class="token for-or-select variable">distUrl</span> <span class="token keyword">in</span> <span class="token punctuation">\</span><span class="token comment"># https://issues.apache.org/jira/browse/INFRA-8753?focusedCommentId=14735394#comment-14735394</span><span class="token string">'https://www.apache.org/dyn/closer.cgi?action=download&amp;filename='</span> <span class="token punctuation">\</span><span class="token comment"># if the version is outdated (or we're grabbing the .asc file), we might have to pull from the dist/archive :/</span>https://www-us.apache.org/dist/ <span class="token punctuation">\</span>https://www.apache.org/dist/ <span class="token punctuation">\</span>https://archive.apache.org/dist/ <span class="token punctuation">\</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token punctuation">\</span><span class="token keyword">if</span> <span class="token function">wget</span> -O <span class="token string">"<span class="token variable">$f</span>"</span> <span class="token string">"<span class="token variable">$distUrl</span><span class="token variable">$distFile</span>"</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">[</span> -s <span class="token string">"<span class="token variable">$f</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token punctuation">\</span><span class="token assign-left variable">success</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token builtin class-name">break</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token keyword">fi</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token keyword">done</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token punctuation">[</span> -n <span class="token string">"<span class="token variable">$success</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token punctuation">\</span>ddist <span class="token string">'tomcat.tar.gz'</span> <span class="token string">"tomcat/tomcat-<span class="token variable">$TOMCAT_MAJOR</span>/v<span class="token variable">$TOMCAT_VERSION</span>/bin/apache-tomcat-<span class="token variable">$TOMCAT_VERSION</span>.tar.gz"</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$TOMCAT_SHA512</span> *tomcat.tar.gz"</span> <span class="token operator">|</span> sha512sum --strict --check -<span class="token punctuation">;</span> <span class="token punctuation">\</span>ddist <span class="token string">'tomcat.tar.gz.asc'</span> <span class="token string">"tomcat/tomcat-<span class="token variable">$TOMCAT_MAJOR</span>/v<span class="token variable">$TOMCAT_VERSION</span>/bin/apache-tomcat-<span class="token variable">$TOMCAT_VERSION</span>.tar.gz.asc"</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token builtin class-name">export</span> <span class="token assign-left variable">GNUPGHOME</span><span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span>mktemp -d<span class="token variable">)</span></span>"</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token keyword">for</span> <span class="token for-or-select variable">key</span> <span class="token keyword">in</span> <span class="token variable">$GPG_KEYS</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token punctuation">\</span>gpg --batch --keyserver ha.pool.sks-keyservers.net --recv-keys <span class="token string">"<span class="token variable">$key</span>"</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token keyword">done</span><span class="token punctuation">;</span> <span class="token punctuation">\</span>gpg --batch --verify tomcat.tar.gz.asc tomcat.tar.gz<span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token function">tar</span> -xf tomcat.tar.gz --strip-components<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token function">rm</span> bin/*.bat<span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token function">rm</span> tomcat.tar.gz*<span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token builtin class-name">command</span> -v gpgconf <span class="token operator">&amp;&amp;</span> gpgconf --kill all <span class="token operator">||</span> <span class="token builtin class-name">:</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token function">rm</span> -rf <span class="token string">"<span class="token variable">$GNUPGHOME</span>"</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token punctuation">\</span><span class="token assign-left variable">nativeBuildDir</span><span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span>mktemp -d<span class="token variable">)</span></span>"</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token function">tar</span> -xf bin/tomcat-native.tar.gz -C <span class="token string">"<span class="token variable">$nativeBuildDir</span>"</span> --strip-components<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token function">apt-get</span> <span class="token function">install</span> -y --no-install-recommends <span class="token punctuation">\</span>dpkg-dev <span class="token punctuation">\</span>gcc <span class="token punctuation">\</span>libapr1-dev <span class="token punctuation">\</span>libssl-dev <span class="token punctuation">\</span><span class="token function">make</span> <span class="token punctuation">\</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token punctuation">(</span> <span class="token punctuation">\</span><span class="token builtin class-name">export</span> <span class="token assign-left variable">CATALINA_HOME</span><span class="token operator">=</span><span class="token string">"<span class="token environment constant">$PWD</span>"</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token builtin class-name">cd</span> <span class="token string">"<span class="token variable">$nativeBuildDir</span>/native"</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token assign-left variable">gnuArch</span><span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span>dpkg-architecture --query DEB_BUILD_GNU_TYPE<span class="token variable">)</span></span>"</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token assign-left variable">aprConfig</span><span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">command</span> -v apr-1-config<span class="token variable">)</span></span>"</span><span class="token punctuation">;</span> <span class="token punctuation">\</span>./configure <span class="token punctuation">\</span>--build<span class="token operator">=</span><span class="token string">"<span class="token variable">$gnuArch</span>"</span> <span class="token punctuation">\</span>--libdir<span class="token operator">=</span><span class="token string">"<span class="token variable">$TOMCAT_NATIVE_LIBDIR</span>"</span> <span class="token punctuation">\</span>--prefix<span class="token operator">=</span><span class="token string">"<span class="token variable">$CATALINA_HOME</span>"</span> <span class="token punctuation">\</span>--with-apr<span class="token operator">=</span><span class="token string">"<span class="token variable">$aprConfig</span>"</span> <span class="token punctuation">\</span>--with-java-home<span class="token operator">=</span><span class="token string">"<span class="token variable">$JAVA_HOME</span>"</span> <span class="token punctuation">\</span>--with-ssl<span class="token operator">=</span>yes<span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token function">make</span> -j <span class="token string">"<span class="token variable"><span class="token variable">$(</span>nproc<span class="token variable">)</span></span>"</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token function">make</span> <span class="token function">install</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token function">rm</span> -rf <span class="token string">"<span class="token variable">$nativeBuildDir</span>"</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token function">rm</span> bin/tomcat-native.tar.gz<span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token punctuation">\</span><span class="token comment"># reset apt-mark's "manual" list so that "purge --auto-remove" will remove all build dependencies</span>apt-mark auto <span class="token string">'.*'</span> <span class="token operator">&gt;</span> /dev/null<span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$savedAptMark</span>"</span> <span class="token punctuation">]</span> <span class="token operator">||</span> apt-mark manual <span class="token variable">$savedAptMark</span> <span class="token operator">&gt;</span> /dev/null<span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token function">find</span> <span class="token string">"<span class="token variable">$TOMCAT_NATIVE_LIBDIR</span>"</span> -type f -executable -exec ldd <span class="token string">'{}'</span> <span class="token string">';'</span> <span class="token punctuation">\</span><span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'/=&gt;/ { print $(NF-1) }'</span> <span class="token punctuation">\</span><span class="token operator">|</span> <span class="token function">sort</span> -u <span class="token punctuation">\</span><span class="token operator">|</span> <span class="token function">xargs</span> -r dpkg-query --search <span class="token punctuation">\</span><span class="token operator">|</span> <span class="token function">cut</span> -d: -f1 <span class="token punctuation">\</span><span class="token operator">|</span> <span class="token function">sort</span> -u <span class="token punctuation">\</span><span class="token operator">|</span> <span class="token function">xargs</span> -r apt-mark manual <span class="token punctuation">\</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token function">apt-get</span> purge -y --auto-remove -o APT::AutoRemove::RecommendsImportant<span class="token operator">=</span>false<span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token function">rm</span> -rf /var/lib/apt/lists/*<span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token punctuation">\</span><span class="token comment"># sh removes env vars it doesn't support (ones with periods)</span><span class="token comment"># https://github.com/docker-library/tomcat/issues/77</span><span class="token function">find</span> ./bin/ -name <span class="token string">'*.sh'</span> -exec <span class="token function">sed</span> -ri <span class="token string">'s|^#!/bin/sh$|#!/usr/bin/env bash|'</span> <span class="token string">'{}'</span> +<span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token punctuation">\</span><span class="token comment"># fix permissions (especially for running as non-root)</span><span class="token comment"># https://github.com/docker-library/tomcat/issues/35</span><span class="token function">chmod</span> -R +rX <span class="token builtin class-name">.</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token function">chmod</span> <span class="token number">777</span> logs temp work<span class="token comment"># verify Tomcat Native is working properly</span>RUN <span class="token builtin class-name">set</span> -e <span class="token punctuation">\</span><span class="token operator">&amp;&amp;</span> <span class="token assign-left variable">nativeLines</span><span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span>catalina.sh configtest <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span><span class="token variable">)</span></span>"</span> <span class="token punctuation">\</span><span class="token operator">&amp;&amp;</span> <span class="token assign-left variable">nativeLines</span><span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$nativeLines</span>"</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'Apache Tomcat Native'</span><span class="token variable">)</span></span>"</span> <span class="token punctuation">\</span><span class="token operator">&amp;&amp;</span> <span class="token assign-left variable">nativeLines</span><span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$nativeLines</span>"</span> <span class="token operator">|</span> <span class="token function">sort</span> -u<span class="token variable">)</span></span>"</span> <span class="token punctuation">\</span><span class="token operator">&amp;&amp;</span> <span class="token keyword">if</span> <span class="token operator">!</span> <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$nativeLines</span>"</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'INFO: Loaded APR based Apache Tomcat Native library'</span> <span class="token operator">&gt;</span><span class="token file-descriptor important">&amp;2</span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token punctuation">\</span><span class="token builtin class-name">echo</span> <span class="token operator">&gt;</span><span class="token file-descriptor important">&amp;2</span> <span class="token string">"<span class="token variable">$nativeLines</span>"</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token builtin class-name">exit</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token keyword">fi</span>EXPOSE <span class="token number">8080</span>CMD <span class="token punctuation">[</span><span class="token string">"catalina.sh"</span>, <span class="token string">"run"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-1-保留字整合案例"><a href="#3-2-1-保留字整合案例" class="headerlink" title="3.2.1 保留字整合案例"></a>3.2.1 保留字整合案例</h3><h4 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h4><blockquote><p>我们安装的centos精简版是没有vim和ifconfig命令的支持的<br>我们可以通过编写Dockerfile令其支持这些功能</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 1.搜索centos镜像并下载</span><span class="token function">docker</span> search centos<span class="token function">docker</span> pull centos<span class="token comment"># 2.编写创建一个文件( /mydoker/dockerfile_centos ),编写Dockerfile ,内容如下</span>--------------------------------------------------------------------FROM centosMAINTAINER timepause<span class="token operator">&lt;</span>qq_43371556@csdn.net<span class="token operator">&gt;</span>ENV MYPATH /usr/localWORKDIR <span class="token variable">$MYPATH</span>RUN yum -y <span class="token function">install</span> <span class="token function">vim</span>RUN yum -y <span class="token function">install</span> net-toolsEXPOSE <span class="token number">80</span>CMD <span class="token builtin class-name">echo</span> <span class="token variable">$MYPATH</span>CMD <span class="token builtin class-name">echo</span> <span class="token string">"install vim and ifconfig commond plug-in components success"</span>CMD /bin/bash-----------------------------------------------------------------------<span class="token comment"># 3. 编译运行centos( 注意最后的空格和点号)</span><span class="token function">docker</span> build -f /mydoker/dockerfile_centos -t mycentos:1.3 <span class="token builtin class-name">.</span><span class="token comment"># 4. 测试功能</span><span class="token comment"># 查看是否新增镜像</span><span class="token function">docker</span> <span class="token function">ps</span><span class="token comment"># 运行新镜像 </span><span class="token function">docker</span> run -it mycentos:1.3<span class="token comment"># 在容器中使用vim 与if config命令</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="自定义tomcat9"><a href="#自定义tomcat9" class="headerlink" title="自定义tomcat9"></a>自定义tomcat9</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 1. 创建存放生成镜像文件的目录</span><span class="token function">mkdir</span> -p /myuse/mydocker/tomcat9<span class="token comment"># 2.创建相关文件(c.txt用于测试)</span><span class="token function">touch</span> c.txt <span class="token comment"># 3.上传tomcat和jdk(一定要注意版本, 根据版本修改Dockerfile文件)</span><span class="token comment">#. 4.创建并编辑Dockerfile(需要提前下载centos)</span><span class="token function">vim</span> Dockerfile---------------------Dockerfile-------------------------------FROM         centosMAINTAINER    chy<span class="token operator">&lt;</span>chy@qq.com<span class="token operator">&gt;</span><span class="token comment">#把宿主机当前上下文的c.txt拷贝到容器/usr/local/路径下</span>COPY c.txt /usr/local/cincontainer.txt<span class="token comment">#把java与tomcat添加到容器中</span>ADD jdk-8u11-linux-x64.tar.gz /usr/local/ADD apache-tomcat-9.0.27.tar.gz /usr/local/<span class="token comment">#安装vim编辑器</span>RUN yum -y <span class="token function">install</span> <span class="token function">vim</span><span class="token comment">#设置工作访问时候的WORKDIR路径，登录落脚点</span>ENV MYPATH /usr/localWORKDIR <span class="token variable">$MYPATH</span><span class="token comment">#配置java与tomcat环境变量</span>ENV JAVA_HOME /usr/local/jdk1.8.0_11ENV CLASSPATH <span class="token variable">$JAVA_HOME</span>/lib/dt.jar:<span class="token variable">$JAVA_HOME</span>/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.27ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.27ENV <span class="token environment constant">PATH</span> <span class="token environment constant">$PATH</span><span class="token builtin class-name">:</span><span class="token variable">$JAVA_HOME</span>/bin:<span class="token variable">$CATALINA_HOME</span>/lib:<span class="token variable">$CATALINA_HOME</span>/bin<span class="token comment">#容器运行时监听的端口</span>EXPOSE  <span class="token number">8080</span><span class="token comment">#启动时运行tomcat</span><span class="token comment"># ENTRYPOINT ["/usr/local/apache-tomcat-9.0.8/bin/startup.sh" ]</span><span class="token comment"># CMD ["/usr/local/apache-tomcat-9.0.8/bin/catalina.sh","run"]</span>CMD /usr/local/apache-tomcat-9.0.27/bin/startup.sh <span class="token operator">&amp;&amp;</span> <span class="token function">tail</span> -F /usr/local/apache-tomcat-9.0.27/bin/logs/catalina.out---------------------Dockerfile-------------------------------<span class="token comment"># 5.构建镜像(在存放这些文件的目录下)</span><span class="token comment"># 如果Dockerfile文件名称就是Dockerfile,可以省略参数 -f /Dockerfile所在位置的书写</span><span class="token function">docker</span> build -t mytomcat9 <span class="token builtin class-name">.</span><span class="token comment"># 6.查看镜像并运行镜像</span><span class="token function">docker</span> images<span class="token comment"># 运行镜像 (后台启动)</span><span class="token function">docker</span> run -d -p <span class="token number">8080</span>:8080 --name myt9 -v /myuse/mydocker/tomcat9/test:/usr/local/apache-tomcat-9.0.27/webapps/test -v /myuse/mydocker/tomcat9/tomcat9logs/:/usr/local/apache-tomcat-9.0.27/logs --privileged<span class="token operator">=</span>true  mytomcat9<span class="token comment"># 注意这里配置了容器卷的映射,宿主机的test文件夹映射到tomcat的webapps目录下的test文件,且二者可以互通有无. </span><span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it 容器ID /bin/bash <span class="token comment">#进入容器根目录 ,可以访问相关页面</span><span class="token comment"># 7. 访问成功后, 添加jsp文件与web.xml文件( a.jsp用于访问测试 ,web.xml用于令jsp页面可以编译)</span><span class="token function">vim</span> a.jspmkidr WEB-INF<span class="token function">vim</span> /WEB-INF/web.xml------------------------------------------a.jsp---------------------------<span class="token operator">&lt;</span>%@ page <span class="token assign-left variable">language</span><span class="token operator">=</span><span class="token string">"java"</span> <span class="token assign-left variable">contentType</span><span class="token operator">=</span><span class="token string">"text/html; charset=UTF-8"</span> <span class="token assign-left variable">pageEncoding</span><span class="token operator">=</span><span class="token string">"UTF-8"</span>%<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html PUBLIC <span class="token string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="token string">"http://www.w3.org/TR/html4/loose.dtd"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>html<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>head<span class="token operator">&gt;</span>    <span class="token operator">&lt;</span>meta http-equiv<span class="token operator">=</span><span class="token string">"Content-Type"</span> <span class="token assign-left variable">content</span><span class="token operator">=</span><span class="token string">"text/html; charset=UTF-8"</span><span class="token operator">&gt;</span>    <span class="token operator">&lt;</span>title<span class="token operator">&gt;</span>Insert title here<span class="token operator">&lt;</span>/title<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>/head<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>body<span class="token operator">&gt;</span>    -----------welcome------------    <span class="token operator">&lt;=</span><span class="token string">"i am in docker tomcat self "</span>%<span class="token operator">&gt;</span>    <span class="token operator">&lt;</span>br<span class="token operator">&gt;</span>    <span class="token operator">&lt;</span>br<span class="token operator">&gt;</span>    <span class="token operator">&lt;</span>% System.out.println<span class="token punctuation">(</span><span class="token string">"=============docker tomcat self"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>%<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>/body<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/html<span class="token operator">&gt;</span>------------------------------------------a.jsp---------------------------------------------------------------------web.xml-----------------------------------<span class="token operator">&lt;</span>?xml <span class="token assign-left variable">version</span><span class="token operator">=</span><span class="token string">"1.0"</span> <span class="token assign-left variable">encoding</span><span class="token operator">=</span><span class="token string">"UTF-8"</span>?<span class="token operator">&gt;</span><span class="token operator">&lt;</span>web-app <span class="token assign-left variable">xmlns</span><span class="token operator">=</span><span class="token string">"http://xmlns.jcp.org/xml/ns/javaee"</span>  xmlns:xsi<span class="token operator">=</span><span class="token string">"http://www.w3.org/2001/XMLSchema-instance"</span>  xsi:schemaLocation<span class="token operator">=</span><span class="token string">"http://xmlns.jcp.org/xml/ns/javaee                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span>  <span class="token assign-left variable">version</span><span class="token operator">=</span><span class="token string">"4.0"</span>  metadata-complete<span class="token operator">=</span><span class="token string">"true"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>/web-app<span class="token operator">&gt;</span>------------------------------------------web.xml-----------------------------------<span class="token comment"># 8. 重启服务, 访问a.jsp</span><span class="token comment"># 查看当前容器id</span><span class="token function">docker</span> <span class="token function">ps</span> <span class="token punctuation">(</span>查看当前容器ID<span class="token punctuation">)</span><span class="token function">docker</span> <span class="token function">ps</span> -a <span class="token punctuation">(</span>查看所有运行过的容器ID<span class="token punctuation">)</span><span class="token comment"># 重启服务</span><span class="token function">docker</span> restart 容器ID<span class="token comment"># 访问a.jsp页面</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四、Docker安装软件"><a href="#四、Docker安装软件" class="headerlink" title="四、Docker安装软件"></a>四、Docker安装软件</h1><h2 id="4-1-MySQL"><a href="#4-1-MySQL" class="headerlink" title="4.1 MySQL"></a>4.1 MySQL</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 1. 以安装mysql5.6为例(不知道什么原因5.7下不来)</span><span class="token function">docker</span> pull mysql:5.6<span class="token comment"># 2. 运行镜像,启动容器(端口3306,root用户密码:root,运行镜像:mysql5.6)</span><span class="token function">docker</span> run -p <span class="token number">3306</span>:3306 --name mysql -v /datebase/mysql/conf:/etc/mysql/conf.d -v /datebase/mysql/logs:/logs -v /datebase/mysql/data:/var/lib/mysql -e <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span>root -d mysql:5.6<span class="token comment"># 3. 进入msql内部测试登陆</span><span class="token function">docker</span> <span class="token function">ps</span><span class="token comment">## 进入mysql的当前目录下</span><span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it MySQL运行成功后的容器ID/name     /bin/bash<span class="token comment">## 输入账号密码</span>mysql -u 账号 -p<span class="token punctuation">(</span>然后根据提示输入密码<span class="token punctuation">)</span><span class="token comment"># 4.连接数据库的图形化界面</span><span class="token comment">## Mysql 解决连接客户端时出现1251 client does not support ...问题</span>ALTER <span class="token environment constant">USER</span>  <span class="token string">'root'</span>@<span class="token string">'%'</span> IDENTIFIED WITH mysql_native_password BY <span class="token string">'mysql密码'</span><span class="token punctuation">;</span>ALTER <span class="token environment constant">USER</span>  <span class="token string">'root'</span>@<span class="token string">'localhost'</span> IDENTIFIED WITH mysql_native_password BY <span class="token string">'mysql密码'</span><span class="token punctuation">;</span><span class="token comment"># 5. 备份数据库数据,之后我们可以通过直接读取这个sql文件恢复数据</span><span class="token function">docker</span> <span class="token builtin class-name">exec</span> myql服务容器ID <span class="token function">sh</span> -c <span class="token string">' exec mysqldump --all-databases -uroot -p"root" '</span> <span class="token operator">&gt;</span> /datebase/all-databases.sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-2-Redis"><a href="#4-2-Redis" class="headerlink" title="4.2 Redis"></a>4.2 Redis</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 1.下载最新版redis镜像</span><span class="token function">docker</span> pull redis<span class="token comment"># 2.运行镜像(redis端口2333, -d后的redis不加参数默认为redis:latest)</span><span class="token comment"># 注意本地数据卷与容器内数据卷目录的对应</span><span class="token function">docker</span> run -p <span class="token number">2333</span>:6379 -v /myuse/myredis/data:/data -v /myuse/myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf  -d redis redis-server /usr/local/etc/redis/redis.conf --appendonly <span class="token function">yes</span><span class="token comment"># 以带密码的方式启动, 密码设置为root</span><span class="token function">docker</span> run -p <span class="token number">2333</span>:6379 -v /myuse/myredis/data:/data -v /myuse/myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf  -d redis redis-server /usr/local/etc/redis/redis.conf --appendonly <span class="token function">yes</span>  --requirepass <span class="token string">"root"</span><span class="token comment"># 或者不适用上面的容器卷, 使用docker 默认配置, 并设置自动重启</span><span class="token function">docker</span> run --name redis -p <span class="token number">6379</span>:6379 -d --restart<span class="token operator">=</span>always redis:latest redis-server --appendonly <span class="token function">yes</span> --requirepass <span class="token string">"root"</span><span class="token comment"># 3.上传redis.conf到本地数据卷所在目录</span>本地数据卷坐在目录 <span class="token builtin class-name">:</span> /myuse/myredis/conf文件地址<span class="token punctuation">(</span>太大了 ,这里放不下<span class="token punctuation">)</span> <span class="token builtin class-name">:</span> https://download.csdn.net/download/qq_43371556/11889084<span class="token comment"># 4. 运行redis的cil----shell命令行</span><span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it 运行着Rediis服务的容器ID redis-cli<span class="token comment"># 远程连接 docker redis</span><span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it redis_s redis-cli -h <span class="token number">192.168</span>.1.100 -p <span class="token number">6379</span> -a your_password //如果有密码 使用 -a参数<span class="token number">12345678910111213141516171819</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-3-RabbitMQ"><a href="#4-3-RabbitMQ" class="headerlink" title="4.3 RabbitMQ"></a>4.3 RabbitMQ</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 1.下载镜像</span><span class="token function">docker</span> pull rabbitmq:3.7.7-management<span class="token comment"># 2.运行镜像</span><span class="token function">docker</span> run -d --name rabbitmq3.7.7 -p <span class="token number">5672</span>:5672 -p <span class="token number">15672</span>:15672 -v <span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">pwd</span><span class="token variable">`</span></span>/data:/var/lib/rabbitmq --hostname myRabbit -e <span class="token assign-left variable">RABBITMQ_DEFAULT_VHOST</span><span class="token operator">=</span>/ -e <span class="token assign-left variable">RABBITMQ_DEFAULT_USER</span><span class="token operator">=</span>admin -e <span class="token assign-left variable">RABBITMQ_DEFAULT_PASS</span><span class="token operator">=</span>admin df80af9ca0c9-d 后台运行容器；--name 指定容器名；-p 指定服务运行的端口（5672：应用访问端口；15672：控制台Web端口号）；-v 映射目录或文件；--hostname  主机名（RabbitMQ的一个重要注意事项是它根据所谓的 “节点名称” 存储数据，默认为主机名）；-e 指定环境变量；（RABBITMQ_DEFAULT_VHOST：默认虚拟机名；RABBITMQ_DEFAULT_USER：默认的用户名；RABBITMQ_DEFAULT_PASS：默认用户名的密码）<span class="token comment"># 3.访问 (如下图)</span>http://ip:15672账号 :admin密码: admin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-4-MongoDB"><a href="#4-4-MongoDB" class="headerlink" title="4.4 MongoDB"></a>4.4 MongoDB</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 1.查看docker+MongoDB版本(图1)</span><span class="token function">docker</span> search<span class="token comment"># 2.下载最新的MongoDB</span><span class="token function">docker</span> pull mongo<span class="token comment"># 3.将镜像运行成容器</span><span class="token function">docker</span> run -itd --name mongo -p <span class="token number">27017</span>:27017 mongo --auth<span class="token comment">## 参数说明：</span>-p <span class="token number">27017</span>:27017 ：映射容器服务的 <span class="token number">27017</span> 端口到宿主机的 <span class="token number">27017</span> 端口。外部可以直接通过 宿主机 ip:27017 访问到 mongo 的服务。--auth：需要密码才能访问容器服务。<span class="token comment"># 4.使用以下命令添加用户和设置密码，并且尝试连接。</span>$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it mongo mongo admin<span class="token comment"># 创建一个名为 admin，密码为 123456 的用户。</span><span class="token operator">&gt;</span>  db.createUser<span class="token punctuation">(</span><span class="token punctuation">{</span> user:<span class="token string">'admin'</span>,pwd:<span class="token string">'123456'</span>,roles:<span class="token punctuation">[</span> <span class="token punctuation">{</span> role:<span class="token string">'userAdminAnyDatabase'</span>, db: <span class="token string">'admin'</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># 尝试使用上面创建的用户信息进行连接。</span><span class="token operator">&gt;</span> db.auth<span class="token punctuation">(</span><span class="token string">'admin'</span>, <span class="token string">'123456'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-5-安装vsftpd-Nignx-图片服务器"><a href="#4-5-安装vsftpd-Nignx-图片服务器" class="headerlink" title="4.5 安装vsftpd+Nignx(图片服务器)"></a>4.5 安装vsftpd+Nignx(图片服务器)</h2><h3 id="4-5-1-环境搭建"><a href="#4-5-1-环境搭建" class="headerlink" title="4.5.1 环境搭建"></a>4.5.1 环境搭建</h3><blockquote><p>通过搭建Nginx和vfstpd 实现文件服务器</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 1. 安装docker-compose . 实现对相关软件的配置</span><span class="token function">curl</span> -L https://get.daocloud.io/docker/compose/releases/download/1.25.4/docker-compose-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -s<span class="token variable">`</span></span>-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -m<span class="token variable">`</span></span> <span class="token operator">&gt;</span> /usr/local/bin/docker-compose<span class="token function">chmod</span> +x /usr/local/bin/docker-compose<span class="token comment"># 2. 编写docker-compose.yml 配置文件</span><span class="token comment">## 需要需要修改的地方的是: </span><span class="token comment">## /data/ftp:/home/vsftpd/ftpuser(20行), /data/ftp 是ftp中图片存放的地址</span><span class="token comment">## /data/ftp:/home/images(11行) , /data/ftp 是Nginx来对应ftp中图片存放的地址</span><span class="token comment">## FTP_USER,FTP_PASS 代表ftp用户的账号和密码, 需要在Linux中提前添加用户 </span><span class="token comment">## 添加用户命令 a. useradd ftpuser,b. passwd ftpuser 然后输入自定义密码  </span><span class="token comment">## ~/pic/nginx/conf/nginx.conf(9行), 注意! 需要提前准备Nginx的配置文件nginx.conf, ~ 代表home目录</span><span class="token comment">## PASV_ADDRESS: 192.168.40.21, PASV_ADDRESS后面填写的是ftp服务器的ip</span>----------------docker-compose.yml---------------------version: <span class="token string">'2'</span>services:  nginx-image:    image: nginx:1.15.8    ports:      - <span class="token string">"80:80"</span>    volumes:      - ~/pic/nginx/html:/usr/share/nginx/html      - ~/pic/nginx/conf/nginx.conf:/etc/nginx/nginx.conf      - ~/pic/nginx/logs:/var/log/nginx      - /data/ftp:/home/images    restart: always  vsftpd:    image: fauria/vsftpd    ports:      - <span class="token string">"20:20"</span>      - <span class="token string">"21:21"</span>      - <span class="token string">"21100-21110:21100-21110"</span>    volumes:      - /data/ftp:/home/vsftpd/ftpuser    environment:      FTP_USER: ftpuser      FTP_PASS: 1q2w3e4r      PASV_ADDRESS: <span class="token number">192.168</span>.40.21      PASV_MIN_PORT: <span class="token number">21100</span>      PASV_MAX_PORT: <span class="token number">21110</span>      LOCAL_UMASK: 022    restart: always-------------------------------------<span class="token comment"># 3. 分享上面需要nginx.conf文件放在下面了</span><span class="token function">vim</span> /home/pic/nginx/conf/nginx.conf<span class="token comment"># 4. docker-compose执行, 需要在docker-compose.yml所在的目录下执行</span><span class="token function">docker-compose</span> up -d<span class="token comment"># 5. docker ps(查看容器是否执行, 下图1)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>上面第三步所需的nginx.conf配置文件</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># root   /data/ftp/, /data/ftp/代表的是我们上面配置的ftp图片存放的地址, 只需要修改这一处</span>location / <span class="token punctuation">{</span> root   /data/ftp/<span class="token punctuation">;</span>i <span class="token punctuation">..</span><span class="token punctuation">..</span>. <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>完整配置文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#user  nobody;</span>worker_processes  <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">#error_log  logs/error.log;</span><span class="token comment">#error_log  logs/error.log  notice;</span><span class="token comment">#error_log  logs/error.log  info;</span><span class="token comment">#pid        logs/nginx.pid;</span>events <span class="token punctuation">{</span>    worker_connections  <span class="token number">1024</span><span class="token punctuation">;</span><span class="token punctuation">}</span>http <span class="token punctuation">{</span>    include       mime.types<span class="token punctuation">;</span>    default_type  application/octet-stream<span class="token punctuation">;</span>    <span class="token comment">#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span>    <span class="token comment">#                  '$status $body_bytes_sent "$http_referer" '</span>    <span class="token comment">#                  '"$http_user_agent" "$http_x_forwarded_for"';</span>    <span class="token comment">#access_log  logs/access.log  main;</span>    sendfile        on<span class="token punctuation">;</span>    <span class="token comment">#tcp_nopush     on;</span>    <span class="token comment">#keepalive_timeout  0;</span>    keepalive_timeout  <span class="token number">65</span><span class="token punctuation">;</span>    <span class="token comment">#gzip  on;</span>    server <span class="token punctuation">{</span>        listen       <span class="token number">80</span><span class="token punctuation">;</span>        server_name  localhost<span class="token punctuation">;</span>        <span class="token comment">#charset koi8-r;</span>        <span class="token comment">#access_log  logs/host.access.log  main;</span>        location / <span class="token punctuation">{</span>            root   /data/ftp/<span class="token punctuation">;</span> <span class="token comment"># /data/ftp/代表的是我们上面配置的ftp图片存放的地址, 只需要修改这一处</span>            index  index.html index.htm<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">#error_page  404              /404.html;</span>        <span class="token comment"># redirect server error pages to the static page /50x.html</span>        <span class="token comment">#</span>        error_page   <span class="token number">500</span> <span class="token number">502</span> <span class="token number">503</span> <span class="token number">504</span>  /50x.html<span class="token punctuation">;</span>        location <span class="token operator">=</span> /50x.html <span class="token punctuation">{</span>            root   html<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-5-2-代码测试"><a href="#4-5-2-代码测试" class="headerlink" title="4.5.2 代码测试"></a>4.5.2 代码测试</h3><ol><li>添加依赖</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--文件上传与下载--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>commons-net<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-net<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.slf4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>slf4j-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.7.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>工具类代码</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>clife<span class="token punctuation">.</span>common<span class="token punctuation">.</span>utils</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>net<span class="token punctuation">.</span>ftp<span class="token punctuation">.</span></span>FTP<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>net<span class="token punctuation">.</span>ftp<span class="token punctuation">.</span></span><span class="token class-name">FTPClient</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>net<span class="token punctuation">.</span>ftp<span class="token punctuation">.</span></span><span class="token class-name">FTPFile</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>net<span class="token punctuation">.</span>ftp<span class="token punctuation">.</span></span><span class="token class-name">FTPReply</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span></span><span class="token class-name">Logger</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span></span><span class="token class-name">LoggerFactory</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Value</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token comment">/** * ftp上传下载工具类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FtpUtil</span> <span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token keyword">static</span>   <span class="token class-name">String</span> hostname<span class="token operator">=</span><span class="token string">"192.168.40.21"</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span>   <span class="token keyword">int</span> port<span class="token operator">=</span><span class="token number">21</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span>   <span class="token class-name">String</span> ftpusername<span class="token operator">=</span><span class="token string">"ftpuser"</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span>   <span class="token class-name">String</span> ftppassword<span class="token operator">=</span><span class="token string">"ftpuser"</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span>   <span class="token class-name">String</span> basePath<span class="token operator">=</span><span class="token string">"/data/ftp"</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span>   <span class="token class-name">String</span> filePath<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">;</span><span class="token comment">//日志打印</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">FtpUtil</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/** * 文件上传封装方法 * @param sourceFileName 本地文件绝对地址,目录+文件名, eg:D:\\1.jpg * @param targetFileName 上传到ftp服务器/data/ftp/目录下的文件名 * @return * @throws FileNotFoundException */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">ftpUploadFile</span><span class="token punctuation">(</span><span class="token class-name">String</span> sourceFileName<span class="token punctuation">,</span> <span class="token class-name">String</span> targetFileName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">FileNotFoundException</span> <span class="token punctuation">{</span><span class="token class-name">FileInputStream</span> in<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>sourceFileName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> b <span class="token operator">=</span> <span class="token function">uploadFile</span><span class="token punctuation">(</span>hostname<span class="token punctuation">,</span> port<span class="token punctuation">,</span> ftpusername<span class="token punctuation">,</span> ftppassword<span class="token punctuation">,</span> basePath<span class="token punctuation">,</span> filePath<span class="token punctuation">,</span> targetFileName<span class="token punctuation">,</span> in<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/** * Description: 向FTP服务器上传文件 * @param host FTP服务器hostname * @param port FTP服务器端口 * @param username FTP登录账号 * @param password FTP登录密码 * @param basePath FTP服务器基础目录 * @param filePath FTP服务器文件存放路径。例如分日期存放：/2015/01/01。文件的路径为basePath+filePath * @param filename 上传到FTP服务器上的文件名 * @param input 输入流 * @return 成功返回true，否则返回false */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">uploadFile</span><span class="token punctuation">(</span><span class="token class-name">String</span> host<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span> <span class="token class-name">String</span> username<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">,</span> <span class="token class-name">String</span> basePath<span class="token punctuation">,</span><span class="token class-name">String</span> filePath<span class="token punctuation">,</span> <span class="token class-name">String</span> filename<span class="token punctuation">,</span> <span class="token class-name">InputStream</span> input<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">boolean</span> result <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token class-name">FTPClient</span> ftp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FTPClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span><span class="token keyword">int</span> reply<span class="token punctuation">;</span>ftp<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 连接FTP服务器</span>logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"连接ftp成功..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 如果采用默认端口，可以使用ftp.connect(host)的方式直接连接FTP服务器</span>ftp<span class="token punctuation">.</span><span class="token function">login</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 登录</span>logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"ftp用户登陆成功！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>reply <span class="token operator">=</span> ftp<span class="token punctuation">.</span><span class="token function">getReplyCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">FTPReply</span><span class="token punctuation">.</span><span class="token function">isPositiveCompletion</span><span class="token punctuation">(</span>reply<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ftp<span class="token punctuation">.</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//切换到上传目录</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ftp<span class="token punctuation">.</span><span class="token function">changeWorkingDirectory</span><span class="token punctuation">(</span>basePath<span class="token operator">+</span>filePath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果目录不存在创建目录</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dirs <span class="token operator">=</span> filePath<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> tempPath <span class="token operator">=</span> basePath<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> dir <span class="token operator">:</span> dirs<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> dir <span class="token operator">||</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">}</span>tempPath <span class="token operator">+=</span> <span class="token string">"/"</span> <span class="token operator">+</span> dir<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ftp<span class="token punctuation">.</span><span class="token function">changeWorkingDirectory</span><span class="token punctuation">(</span>tempPath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ftp<span class="token punctuation">.</span><span class="token function">makeDirectory</span><span class="token punctuation">(</span>tempPath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>ftp<span class="token punctuation">.</span><span class="token function">enterRemotePassiveMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ftp<span class="token punctuation">.</span><span class="token function">changeWorkingDirectory</span><span class="token punctuation">(</span>tempPath<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//设置上传文件的类型为二进制类型</span>ftp<span class="token punctuation">.</span><span class="token function">setFileType</span><span class="token punctuation">(</span>FTP<span class="token punctuation">.</span>BINARY_FILE_TYPE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//上传文件</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ftp<span class="token punctuation">.</span><span class="token function">storeFile</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> input<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"文件 {} 上传失败!"</span><span class="token punctuation">,</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span>input<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ftp<span class="token punctuation">.</span><span class="token function">logout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>result <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"文件 {} 上传成功!"</span><span class="token punctuation">,</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ftp<span class="token punctuation">.</span><span class="token function">isConnected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">try</span> <span class="token punctuation">{</span>ftp<span class="token punctuation">.</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> ioe<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//FileInputStream in=new FileInputStream(new File("D:\\1.jpg"));</span><span class="token comment">//boolean flag = uploadFile("192.168.40.21", 21, "ftpuser", "ftpuser", "/data/ftp","", "123.png", in);</span><span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>flag <span class="token operator">=</span> <span class="token function">ftpUploadFile</span><span class="token punctuation">(</span><span class="token string">"D:\\11.jpg"</span><span class="token punctuation">,</span> <span class="token string">"6666.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>图片访问<br><a href="http://192.168.40.21/6666.jpg">http://192.168.40.21/6666.jpg</a></li></ol><h1 id="五、发布镜像到阿里云"><a href="#五、发布镜像到阿里云" class="headerlink" title="五、发布镜像到阿里云"></a>五、发布镜像到阿里云</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 1.登陆阿里云, 进入容器镜像服务(可以通过下方地址注册登录跳转到容器镜像服务)</span>https://cr.console.aliyun.com/cn-hangzhou/instances/repositories<span class="token comment"># 2. 创建镜像仓库(图1)</span><span class="token comment"># 3. 在docker中登陆 ,根据图2,图3中的操作指南进行操作</span><span class="token comment"># 5. 将正在运行的容器创建成一个镜像(图4)</span><span class="token function">docker</span> commit OPTIONS说明：-a :提交的镜像作者；-m :提交时的说明文字；<span class="token comment"># 4.将镜像推送到阿里云的镜像仓库(最好是根据阿里云上的操作指南)</span><span class="token function">docker</span> tag <span class="token punctuation">[</span>ImageId<span class="token punctuation">]</span> registry.cn-hangzhou.aliyuncs.com/timepause/mydocker:<span class="token punctuation">[</span>镜像版本号<span class="token punctuation">]</span><span class="token function">sudo</span> <span class="token function">docker</span> push registry.cn-hangzhou.aliyuncs.com/timepause/mydocker:<span class="token punctuation">[</span>镜像版本号<span class="token punctuation">]</span><span class="token comment"># 5. 搜索镜像 ,下载镜像(图5,图6)</span><span class="token function">docker</span> pull 复制的镜像地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220405095142522.png" alt="image-20220405095142522"></p><p><img src="/2022/04/05/ctf-xue-xi/yi-ji-chu-zhi-shi/docker/docker-jing-xiang/image-20220405095158514.png" alt="image-20220405095158514"></p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220405095216986.png" alt="image-20220405095216986"></p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220405095230968.png" alt="image-20220405095230968"></p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220405095250515.png" alt="image-20220405095250515"></p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220405095306360.png" alt="image-20220405095306360"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker使用简介</title>
      <link href="/2022/04/04/ctf-xue-xi/yi-ji-chu-zhi-shi/docker/docker-shi-yong-jian-jie/"/>
      <url>/2022/04/04/ctf-xue-xi/yi-ji-chu-zhi-shi/docker/docker-shi-yong-jian-jie/</url>
      
        <content type="html"><![CDATA[<p>​        </p><h1 id="第一章-Docker简介"><a href="#第一章-Docker简介" class="headerlink" title="第一章 Docker简介"></a>第一章 Docker简介</h1><h2 id="1-1-Docker的发展史"><a href="#1-1-Docker的发展史" class="headerlink" title="1.1 Docker的发展史"></a>1.1 Docker的发展史</h2><p>​        2010年几个年轻人成立了一个做PAAS平台的公司dotCloud。起初公司发展的不错，不但拿到过一些融资，还获得了美国著名孵化器YCombinator的支持，后来微软谷歌亚马逊这样的大厂商也纷纷加入PAAS平台，竞争十分激烈，dotCloud举步维艰。</p><p>​        2013年可能是公司发展的不是很好，工程师又不想自己的努力付之东流，于是他们决定将他们的核心技术开源。这项技术就是docker。当时docker的功能就是将linux容器中的应用代码打包，可以轻松的在服务器之间进行迁移。</p><p>​        无心插柳柳成荫，docker技术风靡全球，于是dotCloud公司改名为docker Inc，并全面投入到docker的开发之中。</p><ul><li><p>2014。6 Docker发布了第一个版本 Docker1。0</p></li><li><p>2014。7 获得C轮融资 $4000W</p></li><li><p>2015。4 获得D轮融资 $9500W</p></li><li><p>至今已经发布到docker </p></li></ul><h2 id="1-2-什么是Docker"><a href="#1-2-什么是Docker" class="headerlink" title="1.2 什么是Docker"></a>1.2 什么是Docker</h2><p>​        docker是一个用来装应用的容器，就像杯子可以装水，笔筒可以放笔，书包可以放书，可以把hello word放在docker中，可以把网站放入docker中，可以把任何想得到的程序放在docker中。</p><p>​        我们在理解 <code>docker</code> 之前，首先我们得先区分清楚两个概念，<strong>容器</strong>和<strong>虚拟机</strong>。</p><p>​        我们用的传统虚拟机如 <code>VMware</code> ， <code>VisualBox</code> 之类的需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。每一台虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。</p><p>​        而容器技术是和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。</p><p>​        容器技术是实现操作系统虚拟化的一种途径，可以让您在资源受到隔离的进程中运行应用程序及其依赖关系。通过使用容器，我们可以轻松打包应用程序的代码、配置和依赖关系，将其变成容易使用的构建块，从而实现环境一致性、运营效率、开发人员生产力和版本控制等诸多目标。容器可以帮助保证应用程序快速、可靠、一致地部署，其间不受部署环境的影响。容器还赋予我们对资源更多的精细化控制能力，让我们的基础设施效率更高。通过下面这幅图我们可以很直观的反映出这两者的区别所在。</p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.png"></p><p>​        <strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 <code>Linux</code> 容器解决方案。</p><p>​        而 <code>Linux</code> 容器是 <code>Linux</code> 发展出了另一种虚拟化技术，简单来讲， <code>Linux</code> 容器不是模拟一个完整的操作系统，而是对进程进行隔离，相当于是在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p><p>​        <code>Docker</code> 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 <code>Docker</code> ，就不用担心环境问题。</p><p>​        总体来说， <code>Docker</code> 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p><h2 id="1-3-Docker的优势"><a href="#1-3-Docker的优势" class="headerlink" title="1.3 Docker的优势"></a>1.3 Docker的优势</h2><p> <strong>Docker相比于传统虚拟化方式具有更多的优势：</strong></p><ul><li><code>docker</code> 启动快速属于秒级别。虚拟机通常需要几分钟去启动</li><li><code>docker</code> 需要的资源更少， <code>docker</code> 在操作系统级别进行虚拟化， <code>docker</code> 容器和内核交互，几乎没有性能损耗，性能优于通过 <code>Hypervisor</code> 层与内核层的虚拟化</li><li><code>docker</code> 更轻量， <code>docker</code> 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境， <code>Docker</code> 运行的镜像数远多于虚拟机数量，对系统的利用率非常高</li><li>与虚拟机相比， <code>docker</code> 隔离性更弱， <code>docker</code> 属于进程之间的隔离，虚拟机可实现系统级别隔离</li><li>安全性： <code>docker</code> 的安全性也更弱。 <code>Docker</code> 的租户 <code>root</code> 和宿主机 <code>root</code> 等同，一旦容器内的用户从普通用户权限提升为root权限，它就直接具备了宿主机的root权限，进而可进行无限制的操作。虚拟机租户 <code>root</code> 权限和宿主机的 <code>root</code> 虚拟机权限是分离的，并且虚拟机利用如 <code>Intel</code> 的 <code>VT-d</code> 和 <code>VT-x</code> 的 <code>ring-1</code> 硬件隔离技术，这种隔离技术可以防止虚拟机突破和彼此交互，而容器至今还没有任何形式的硬件隔离，这使得容器容易受到攻击</li><li>可管理性： <code>docker</code> 的集中化管理工具还不算成熟。各种虚拟化技术都有成熟的管理工具，例如 <code>VMware vCenter</code> 提供完备的虚拟机管理能力</li><li>高可用和可恢复性： <code>docker</code> 对业务的高可用支持是通过快速重新部署实现的。虚拟化具备负载均衡，高可用，容错，迁移和数据保护等经过生产实践检验的成熟保障机制， <code>VMware</code> 可承诺虚拟机 <code>99。999%</code> 高可用，保证业务连续性</li><li>快速创建、删除：虚拟化创建是分钟级别的， <code>Docker</code> 容器创建是秒级别的， <code>Docker</code> 的快速迭代性，决定了无论是开发、测试、部署都可以节约大量时间</li><li>交付、部署：虚拟机可以通过镜像实现环境交付的一致性，但镜像分发无法体系化。 <code>Docker</code> 在 <code>Dockerfile</code> 中记录了容器构建过程，可在集群中实现快速分发和快速部署</li></ul><p>我们可以从下面这张表格很清楚地看到容器相比于传统虚拟机的特性的优势所在：</p><table><thead><tr><th align="left">特性</th><th align="left">容器</th><th align="left">虚拟机</th></tr></thead><tbody><tr><td align="left">启动</td><td align="left">秒级</td><td align="left">分钟级</td></tr><tr><td align="left">硬盘使用</td><td align="left">一般为MB</td><td align="left">一般为GB</td></tr><tr><td align="left">性能</td><td align="left">接近原生</td><td align="left">弱于</td></tr><tr><td align="left">系统支持量</td><td align="left">单机支持上千个容器</td><td align="left">一般是几十个</td></tr></tbody></table><h1 id="第二章-了解docker"><a href="#第二章-了解docker" class="headerlink" title="第二章 了解docker"></a>第二章 了解docker</h1><h2 id="2-1-docker思想"><a href="#2-1-docker思想" class="headerlink" title="2.1 docker思想"></a>2.1 docker思想</h2><h3 id="2-1-1-集装箱"><a href="#2-1-1-集装箱" class="headerlink" title="2.1.1 集装箱"></a>2.1.1 集装箱</h3><p>​        没有集装箱之前运输货物，东西零散容易丢失，有了集装箱之后货物不容易丢失，我们可以把货物想象成程序，目前我们要把程序部署到一台新的机器上，可能会启动不起来，比如少一些配置文件什么的或者少了什么数据，有了docker的集装箱可以保证我们的程序不管运行在哪不会缺东西。</p><h3 id="2-1-2-标准化"><a href="#2-1-2-标准化" class="headerlink" title="2.1.2 标准化"></a>2.1.2 标准化</h3><ol><li><strong>运输方式</strong></li></ol><p>​        docker运输东西有一个超级码头，任何地方需要货物都由鲸鱼先送到超级码头，然后再由鲸鱼从超级码头把货物送到目的地去。对应的技术来说，比如我们要把台式机的应用部署到笔记本上，我们可能选择用QQ发过去或者用U盘拷过去，docker就标准化了这个过程，我们只需在台式机上执行一个docker命令，把鲸鱼派过来，把程序送到超级码头去，再在笔记本上执行一个docker命令，然后由鲸鱼把程序从超级码头送到笔记本上去。</p><ol start="2"><li><strong>存储方式</strong></li></ol><p>​        当我们把程序存储到笔记本上时，我们需要一个目录，且我们要记住这个目录，因为下次我们可能还要修改，有了docker之后我们就不用记住了程序在哪里了，我们使用的时候只需要一条命令就行了。</p><ol start="3"><li><strong>API接口</strong></li></ol><p>​        docker提供了一系列rest api的接口，包含了对docker也就是对我们的应用的一个启动停止查看删除等等，如当我们要启动tomcat时我们要执行startup命令，当我们要停止时要执行shutdown命令，如果不是tomcat，我们可能还需要一些别的命令。有了docker我们记docker的命令就可以对其进行操作。</p><h3 id="2-1-3-隔离"><a href="#2-1-3-隔离" class="headerlink" title="2.1.3 隔离"></a>2.1.3 隔离</h3><p>​        我们在使用虚拟机时有自己的cpu，硬盘，内存，完全感觉不到外面主机的存在，docker也差不多，不过它更轻量，我们创建虚拟机可能要几分钟，但是docker只需要一秒。最底层的技术时linux一种内核的限制机制，叫做LXC，LXC是一种轻量级的容器虚拟化技术。最大效率的隔离了进程和资源。通过cgroup，namespace等限制，隔离进程组所使用的物理资源，比如CPU，MEMORY等等，这个机制在7，8年前已经加入到linux内核了，直到2013年docker出世的时候才火起来，大家可能奇怪为什么这么好的技术埋没这么多年都没人发现呢?英雄造时势，时势造英雄，如果没有云计算，敏捷开发，高频度的弹性伸缩需求，没有IT行业这么多年长足的发展，也就没有docker。</p><h2 id="2-2-docker解决的问题"><a href="#2-2-docker解决的问题" class="headerlink" title="2.2 docker解决的问题"></a>2.2 docker解决的问题</h2><h3 id="2-2-1-系统环境不一致"><a href="#2-2-1-系统环境不一致" class="headerlink" title="2.2.1 系统环境不一致"></a>2.2.1 系统环境不一致</h3><p>​        开发:我本地没问题。运维:服务器没问题。 这个问题就变成了皮球。</p><p>​        如果一个应用要正常的启动起来需要什么?比如java web应用。</p><p>​        需要一个操作系统，操作系统之上要jdk，tomcat，我们的代码，配置文件。</p><p>​        操作系统的改变可能会导致我们的应用开不起来，比如我们调用了某些系统命令。</p><p>​        jdk版本也可能导致程序的运行失败。比如class文件需要1。7编译，我们装了个1。6的jdk。</p><p>​        tomcat版本也能导致失败，比如旧的版本一些配置在新版本中不再支持。</p><p>​        代码的话就比如应用了C盘，D盘的一个文件，或者是用了系统的一些环境编码。</p><p>​        配置的话我们可能少了某个配置文件等等。</p><p>​        下面docker来了，它把操作系统，jdk，tomcat，代码，配置全部放到集装箱里。再打包放到鲸鱼上，由鲸鱼给我们送到服务器上，在我的机器上怎么运行，在别的机器上也怎么运行。不会有任何的问题。一句话就是docker解决了运行环境不一致所带来的问题。</p><h3 id="2-2-2-系统好卡，哪个哥们又写死循环了"><a href="#2-2-2-系统好卡，哪个哥们又写死循环了" class="headerlink" title="2.2.2 系统好卡，哪个哥们又写死循环了"></a>2.2.2 系统好卡，哪个哥们又写死循环了</h3><p>​        如果有根别人共用服务器的同学可能有这样的体会，莫名其妙发现自己的程序挂了，一查原因要不是内存不够了，要不是硬盘满了，还有就是发现某个服务变慢了，甚至敲终端都比较卡，但是linux本身就是一个多用户的操作系统本身就可以供多个用户使用，docker的隔离性可以解决这个问题，就算别人的程序还是死循环疯狂吃CPU，还是封装疯狂打日志把硬盘占满，还是内存泄漏，把内存占满，都不会导致我们的程序运行错误。因为docker在启动的时候就限定好了，它最大使用的CPU硬盘，如果超过了，就会杀掉对应进程。</p><h3 id="2-2-3-双11来了，服务器撑不住了"><a href="#2-2-3-双11来了，服务器撑不住了" class="headerlink" title="2.2.3 双11来了，服务器撑不住了"></a>2.2.3 双11来了，服务器撑不住了</h3><p>​        大部分系统业务量并不是每天都比较平均的，特别是一些电商系统，每天总有那么几天业务量是平时的几倍甚至几十倍，如果按双11的规模去准备服务器那么对于平时的规模来说又是极大的浪费，所以就在节日前临时扩展机器，过完节再把多余的节点下线，这就给运维带来了非常大的工作量，一到过节就在各个机器上部署各种各样的服务，我们启动程序需要java，tocmat等等，并且还可能起不来还要调试，这是非常恶心的工作，有了docker一切都变得美好了，只要点一下服务器就可以从10台变成100台甚至1000，1W台。都是分分钟的事情。</p><p>​        为什么会这么快呢？都是用标准的方式把我们的程序运过来，下载过来，再用标准的方式把它运行起来，就可以做到只要在每台机器上都执行一两条命令，就可以让程序正常跑起来，并且不用担心有问题。</p><h1 id="第三章-走进docker"><a href="#第三章-走进docker" class="headerlink" title="第三章 走进docker"></a>第三章 走进docker</h1><p>​        镜像就是上面说的集装箱，仓库就是超级码头，容器就是我们运行程序的地方。docker运行程序的过程就是去仓库把镜像拉到本地，然后用一条命令把镜像运行起来变成容器。</p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/docker%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.png" alt="image-20220404213106368"></p><ul><li><p>build：构建，就是构建镜像。</p></li><li><p>ship：运输，运输镜像，从仓库和主机运输。</p></li><li><p>run：运行的镜像就是一个容器。</p></li></ul><p>build，ship，run和镜像，仓库，容器是一一对应的。</p><h2 id="3-1-镜像"><a href="#3-1-镜像" class="headerlink" title="3.1 镜像"></a>3.1 镜像</h2><p>​        镜像的英文名交image。前面我们讲到了集装箱，鲸鱼拖着的所有集装箱就是一个镜像。</p><p>​        从本质上来说镜像就是一系列文件，了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>​        镜像<code>（Image）</code>就是一堆只读层<code>（read-only layer）</code>的统一视角，也许这个定义有些难以理解，下面的这张图能够帮助读者理解镜像的定义。</p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E9%95%9C%E5%83%8F%E5%AE%9A%E4%B9%89.png" alt="image-20220404213213857"></p><p>​        从左边我们看到了多个只读层，它们重叠在一起。除了最下面一层，其它层都会有一个指针指向下一层。这些层是<code>Docker</code> 内部的实现细节，并且能够在主机的文件系统上访问到。统一文件系统 <code>(union file system)</code> 技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。我们可以在图片的右边看到这个视角的形式。</p><p>​        既然Docker是文件，那么是以什么样的格式在本地保存的呢?</p><p>​        说到<strong>存储格式</strong>，就要提到linux的一个存储技术，叫做<strong>联合文件系统</strong>，是一种分层的文件系统，可以将不同的目录挂到同一个虚拟文件系统下。</p><p>​        比如test1下有三个文件夹，test2下有两个文件夹，还有一个readme文件。联合文件系统就是可以在一个文件夹(test)中看到多个文件夹(test1，test2)中的内容。</p><p>​        通过这种方式可以实现文件的分层，test1可以把它看作第一层，test2可以把它看作第二层，每一层有每一层自己的文件，docker就是利用了这种分层的概念实现了镜像存储。</p><p>​        下图就是镜像的存储格式，这张图是分层的，最下面一层，上面也是一层层的好像集装箱罗列在一起。这就是镜像最直观的存储方式。下面是操作系统的引导，上面是linux操作系统，再上面是一些相关的软件，如果是我们自己的程序，就可以是tomcat，jdk，再往上是应用代码，每一层是我们自己都可以控制得，最上面一层先忽略不看，因为这是和容器有关的。注意一点，docker镜像系统的每一层都是只读的，然后把每一层加载完成之后这些文件都会被看成是同一个目录，相当于只有一个文件系统。docker的这种文件系统被称之为镜像。</p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E9%95%9C%E5%83%8F%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F.png" alt="image-20220404212652771"></p><h2 id="3-2-容器"><a href="#3-2-容器" class="headerlink" title="3.2 容器"></a>3.2 容器</h2><p>​        容器 <code>(container)</code> 的定义和镜像 <code>(image)</code> 几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E5%AE%B9%E5%99%A8%E5%AE%9A%E4%B9%89.png" alt="image-20220404213243444"></p><p>​        由于容器的定义并没有提及是否要运行容器，所以实际上，容器 = 镜像 + 读写层。</p><p>​        为了便于理解，大家可以把容器想象成虚拟机，每个虚拟机都有自己的文件系统，可以把图1整个一部分看成是文件系统，与虚拟机系统的区别是这里面的文件系统是一层一层的，并且最下面的n层都是只读的，只有上面一层是可写的。为什么要有可写的这层呢?大家的程序运行起来，势必会要写一些日志，写一些文件，或者对系统的某一些文件做一些修改，所以容器在最上面一层创建了可读可写的文件系统。</p><p>​        在程序的运行过程中，如果要写镜像文件时，因为镜像的每一层都是只读的，它会把文件的每一层拷到文件的最上层，然后再对它进行修改，修改之后，当我们的应用读一个文件时会从顶层进行查找，如果没有才会找下一层。</p><p>​        由于容器的最上一层是可以修改的，镜像是不能修改的，这样就能保证镜像可以生成多个容器独立运行，没有任何干扰。</p><h2 id="3-3-仓库"><a href="#3-3-仓库" class="headerlink" title="3.3 仓库"></a>3.3 仓库</h2><p>​        我们的镜像是要在其它机器上运行，如何进行传输呢?</p><p>​        这就用到了docker仓库，我们要先把我们的镜像传到docker仓库中，再由目的地把docker仓库拉过去，这就完成了这样的一次传输过程。</p><p>​        谁提供了这样的仓库呢?docker自己提供了，hub。docker。com，但是非常慢，为了解决这个问题，国内很多公司也在做自己的仓库。比较知名的是由网易蜂巢提供的 <a href="https://c.163yun.com/hub#/m/home/">https://c.163yun.com/hub#/m/home/</a></p><p>​         <code>Docker</code> 仓库是集中存放镜像文件的场所。镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<code>Docker Registry</code> (仓库注册服务器)就是这样的服务。有时候会把仓库 <code>(Repository)</code> 和仓库注册服务器 <code>(Registry)</code> 混为一谈，并不严格区分。<code>Docker</code> 仓库的概念跟 <code>Git</code> 类似，注册服务器可以理解为 <code>GitHub</code> 这样的托管服务。实际上，一个 <code>Docker Registry</code> 中可以包含多个仓库 <code>(Repository)</code> ，每个仓库可以包含多个标签 <code>(Tag)</code>，每个标签对应着一个镜像。所以说，镜像仓库是 <code>Docker</code> 用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。</p><p>​        通常，<strong>一个仓库会包含同一个软件不同版本的镜像</strong>，而<strong>标签就常用于对应该软件的各个版本</strong> 。我们可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签.。</p><p>仓库又可以分为两种形式：</p><ul><li><code>public</code>(公有仓库)</li><li><code>private</code>(私有仓库)</li></ul><p>​        <code>Docker Registry</code> 公有仓库是开放给用户使用、允许用户管理镜像的 <code>Registry</code> 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>​        除了使用公开服务外，用户还可以在本地搭建私有 <code>Docker Registry</code> 。<code>Docker</code> 官方提供了 <code>Docker Registry</code>镜像，可以直接使用做为私有 <code>Registry</code> 服务。当用户创建了自己的镜像之后就可以使用 <code>push</code> 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 <code>pull</code> 下来就可以了。</p><p>​        我们主要把 <code>Docker</code> 的一些常见概念如 <code>Image</code> ， <code>Container</code> ， <code>Repository</code> 做了详细的阐述，也从传统虚拟化方式的角度阐述了 <code>docker</code> 的优势，我们从下图可以直观地看到 <code>Docker</code> 的架构：</p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/docker%E6%9E%B6%E6%9E%84.png" alt="image-20220404213553615" style="zoom:65%;"><p>​        <code>Docker</code> 使用 <code>C/S</code> 结构，即<strong>客户端/服务器</strong>体系结构。 <code>Docker</code> 客户端与 <code>Docker</code> 服务器进行交互，Docker服务端负责构建、运行和分发 <code>Docker</code> 镜像。 <code>Docker</code> 客户端和服务端可以运行在一台机器上，也可以通过 <code>RESTful</code> 、 <code>stock</code> 或网络接口与远程 <code>Docker</code> 服务端进行通信。</p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/docker%E7%BB%93%E6%9E%84.png" alt="image-20220404212904989" style="zoom:67%;"><p><code>Docker</code> 的核心组件包括：</p><ol><li><strong>Docker Client</strong></li><li><strong>Docker daemon</strong></li><li><strong>Docker Image</strong></li><li><strong>Docker Registry</strong></li><li><strong>Docker Container</strong></li></ol><p>​        这张图展示了 <code>Docker</code> 客户端、服务端和 <code>Docker</code> 仓库（即 <code>Docker Hub</code> 和 <code>Docker Cloud</code> ），默认情况下<code>Docker</code> 会在 <code>Docker</code> 中央仓库寻找镜像文件，这种利用仓库管理镜像的设计理念类似于 <code>Git</code> ，当然这个仓库是可以通过修改配置来指定的，甚至我们可以创建我们自己的私有仓库。</p><h1 id="第四章-docker安装"><a href="#第四章-docker安装" class="headerlink" title="第四章 docker安装"></a>第四章 docker安装</h1><h2 id="4-1-CentOS环境下"><a href="#4-1-CentOS环境下" class="headerlink" title="4.1 CentOS环境下"></a>4.1 CentOS环境下</h2><p>​        <code>Docker</code> 的安装和使用有一些前提条件，主要体现在体系架构和内核的支持上。对于体系架构，除了 <code>Docker</code> 一开始就支持的 <code>X86-64</code> ，其他体系架构的支持则一直在不断地完善和推进中。</p><p>​        <code>Docker</code> 分为 <code>CE</code> 和 <code>EE</code> 两大版本。 <code>CE</code> 即社区版（免费，支持周期 <code>7</code> 个月）， <code>EE</code> 即企业版，强调安全，付费使用，支持周期 <code>24</code> 个月。</p><p>​        我们在安装前可以参看官方文档获取最新的 <code>Docker</code> 支持情况，官方文档在这里：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">https</span><span class="token punctuation">:</span>//docs.docker.com/install/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>Docker</code> 对于内核支持的功能，即内核的配置选项也有一定的要求(比如必须开启 <code>Cgroup</code> 和 <code>Namespace</code> 相关选项，以及其他的网络和存储驱动等)， <code>Docker</code> 源码中提供了一个检测脚本来检测和指导内核的配置，脚本链接在这里：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">https</span><span class="token punctuation">:</span>//raw.githubusercontent.com/docker/docker/master/contrib/check-config.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在满足前提条件后，安装就变得非常的简单了。</p><p><code>Docker CE</code> 的安装请参考官方文档：</p><ul><li><code>MacOS</code>：<a href="https://docs.docker.com/docker-for-mac/install/">https://docs.docker.com/docker-for-mac/install/</a></li><li><code>Windows</code>：<a href="https://docs.docker.com/docker-for-windows/install/">https://docs.docker.com/docker-for-windows/install/</a></li><li><code>Ubuntu</code>：<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">https://docs.docker.com/install/linux/docker-ce/ubuntu/</a></li><li><code>Debian</code>：<a href="https://docs.docker.com/install/linux/docker-ce/debian/">https://docs.docker.com/install/linux/docker-ce/debian/</a></li><li><code>CentOS</code>：<a href="https://docs.docker.com/install/linux/docker-ce/centos/">https://docs.docker.com/install/linux/docker-ce/centos/</a></li><li><code>Fedora</code>：<a href="https://docs.docker.com/install/linux/docker-ce/fedora/">https://docs.docker.com/install/linux/docker-ce/fedora/</a></li><li>其他 <code>Linux</code> 发行版：<a href="https://docs.docker.com/install/linux/docker-ce/binaries/">https://docs.docker.com/install/linux/docker-ce/binaries/</a></li></ul><ol><li>Docker 要求 CentOS 系统的内核版本高于 3.10，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。</li></ol><p>通过 <strong>uname -r</strong> 命令查看你当前的内核版本</p><ol start="2"><li>如果安装过请先卸载</li></ol><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">yum</span> <span class="token attr-value">remove docker \           docker-client \           docker-client-latest \           docker-common \           docker-latest \           docker-latest-logrotate \           docker-logrotate \           docker-engine</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>安装依赖设置yum仓库</li></ol><p>安装依赖:</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">yum</span> <span class="token attr-value">install -y yum-utils \  device-mapper-persistent-data \  lvm2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>设置仓库:</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">yum-config-manager</span> <span class="token attr-value">\    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="4"><li><p>安装docker</p><p>​    <code>Docker</code> 软件包已经包括在默认的 <code>CentOS-Extras</code> 软件源里。因此想要安装 <code>docker</code>，只需要运行下面的 <code>yum</code> 命令</p></li></ol><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">sudo</span> <span class="token attr-value">yum install docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        当然在测试或开发环境中 <code>Docker</code> 官方为了简化安装流程，提供了一套便捷的安装脚本，<code>CentOS</code> 系统上可以使用这套脚本安装：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">curl</span> <span class="token attr-value">-fsSL get.docker.com -o get-docker.sh</span><span class="token attr-name">sh</span> <span class="token attr-value">get-docker.sh</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        具体可以参看 <code>docker-install</code> 的脚本：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">https</span><span class="token punctuation">:</span><span class="token attr-value">//github.com/docker/docker-install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 <code>Docker CE</code> 的 <code>Edge</code> 版本安装在系统中。</p><p>​        安装完成后，运行下面的命令，验证是否安装成功：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">version</span>or<span class="token attr-name">docker</span> <span class="token attr-value">info</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        返回docker的版本相关信息，证明 <code>docker</code> 安装成功</p><p><strong>或者</strong>通过以下命令安装：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">yum</span> <span class="token attr-value">install docker-ce docker-ce-cli containerd.io</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="5"><li>启动并加入开机启动</li></ol><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">systemctl</span> <span class="token attr-value">start docker</span><span class="token attr-name">systemctl</span> <span class="token attr-value">enable docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="6"><li><p>Docker简单运用</p><p>​    我们通过最简单的 <code>image</code> 文件 <code>hello world</code>，感受一下 <code>Docker</code> 的魅力吧！</p><p>​    我们直接运行下面的命令，将名为 <code>hello-world</code> 的 <code>image</code> 文件从仓库抓取到本地。</p></li></ol><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">pull library/hello-world</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>docker pull images</code> 是抓取 <code>image</code> 文件， <code>library/hello-world</code> 是 <code>image</code> 文件在仓库里面的位置，其中 <code>library</code> 是 <code>image</code> 文件所在的组， <code>hello-world</code> 是 <code>image</code> 文件的名字。</p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/pull%E6%93%8D%E4%BD%9C.png" alt="image-20220404214137451"></p><p>​        抓取成功以后，就可以在本机看到这个 <code>image</code> 文件了。</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">images</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们可以看到如下结果：</p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="image-20220404214157935"></p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">run hello-world</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显示如下即安装成功! </p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">[root@iZ2ze68ge5c1uwlkmnb9ixZ</span> <span class="token attr-value">zcapp]# docker run hello-world</span><span class="token attr-name">Unable</span> <span class="token attr-value">to find image 'hello-world:latest' locally</span><span class="token attr-name">latest</span><span class="token punctuation">:</span> <span class="token attr-value">Pulling from library/hello-world</span><span class="token attr-name">1b930d010525</span><span class="token punctuation">:</span> <span class="token attr-value">Pull complete </span><span class="token attr-name">Digest</span><span class="token punctuation">:</span> <span class="token attr-value">sha256:0e11c388b664df8a27a901dce21eb89f11d8292f7fca1b3e3c4321bf7897bffe</span><span class="token attr-name">Status</span><span class="token punctuation">:</span> <span class="token attr-value">Downloaded newer image for hello-world:latest</span><span class="token attr-name">Hello</span> <span class="token attr-value">from Docker!</span><span class="token attr-name">This</span> <span class="token attr-value">message shows that your installation appears to be working correctly。</span><span class="token attr-name">To</span> <span class="token attr-value">generate this message， Docker took the following steps:</span><span class="token attr-name"> 1.</span> <span class="token attr-value">The Docker client contacted the Docker daemon。</span><span class="token attr-name"> 2.</span> <span class="token attr-value">The Docker daemon pulled the "hello-world" image from the Docker Hub。</span>    (amd64)<span class="token attr-name"> 3.</span> <span class="token attr-value">The Docker daemon created a new container from that image which runs the</span><span class="token attr-name">    executable</span> <span class="token attr-value">that produces the output you are currently reading。</span><span class="token attr-name"> 4.</span> <span class="token attr-value">The Docker daemon streamed that output to the Docker client, which sent it</span><span class="token attr-name">    to</span> <span class="token attr-value">your terminal。</span><span class="token attr-name">To</span> <span class="token attr-value">try something more ambitious， you can run an Ubuntu container with:</span><span class="token attr-name"> $</span> <span class="token attr-value">docker run -it ubuntu bash</span><span class="token attr-name">Share</span> <span class="token attr-value">images， automate workflows, and more with a free Docker ID:</span><span class="token attr-name"> https</span><span class="token punctuation">:</span><span class="token attr-value">//hub.docker.com/</span><span class="token attr-name">For</span> <span class="token attr-value">more examples and ideas,visit:</span><span class="token attr-name"> https</span><span class="token punctuation">:</span><span class="token attr-value">//docs.docker.com/get-started/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-2-Ubuntu环境下"><a href="#4-2-Ubuntu环境下" class="headerlink" title="4.2 Ubuntu环境下"></a>4.2 Ubuntu环境下</h2><h3 id="第1步-安装Docker"><a href="#第1步-安装Docker" class="headerlink" title="第1步 - 安装Docker"></a>第1步 - 安装Docker</h3><p>官方Ubuntu存储库中提供的Docker安装包，但是可能不是最新的版本。为了确保我们获得最新版本，我们将从官方Docker存储库安装Docker。为此，我们将添加一个新的资源包，从Docker添加GPG密钥以确保下载有效，然后安装该包。</p><p>首先，更新现有的包列表：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">sudo</span> <span class="token attr-value">apt update</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>接下来，使用<code>apt</code>安装一些允许通过HTTPS才能使用的软件包：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">sudo</span> <span class="token attr-value">apt install apt-transport-https ca-certificates curl software-properties-common</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>然后将官方Docker存储库的GPG密钥添加到您的系统：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">curl</span> <span class="token attr-value">-fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>将Docker存储库添加到APT源：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">sudo</span> <span class="token attr-value">add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>接下来，使用新添加的repo源中的Docker包更新包数据库：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">sudo</span> <span class="token attr-value">apt update</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>确保您要从Docker repo安装而不是默认的Ubuntu repo：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">apt-cache</span> <span class="token attr-value">policy docker-ce</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>虽然Docker的版本号可能不同，但您还是会看到这样的输出：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker-ce</span><span class="token punctuation">:</span><span class="token attr-name">  Installed</span><span class="token punctuation">:</span> <span class="token attr-value">(none)</span><span class="token attr-name">  Candidate</span><span class="token punctuation">:</span> <span class="token attr-value">18.03.1~ce~3-0~ubuntu</span><span class="token attr-name">  Version</span> <span class="token attr-value">table:</span><span class="token attr-name">     18.03.1~ce~3-0~ubuntu</span> <span class="token attr-value">500</span><span class="token attr-name">        500</span> <span class="token attr-value">https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>复制</p><p>现在<code>docker-ce</code>还没有安装，用上面这个命令我们能看到安装源来自的Docker官方存储库。</p><p>最后，安装Docker：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">sudo</span> <span class="token attr-value">apt install docker-ce</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>现在应该安装好Docker了，检查它是否正在运行：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">sudo</span> <span class="token attr-value">systemctl status docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>输出应类似于以下内容，表明该服务处于工作状态：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">●</span> <span class="token attr-value">docker.service - Docker Application Container Engine</span><span class="token attr-name">   Loaded</span><span class="token punctuation">:</span> <span class="token attr-value">loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled)</span><span class="token attr-name">   Active</span><span class="token punctuation">:</span> <span class="token attr-value">active (running) since Thu 2018-07-05 15:08:39 UTC; 2min 55s ago</span><span class="token attr-name">     Docs</span><span class="token punctuation">:</span> <span class="token attr-value">https://docs.docker.com</span><span class="token attr-name"> Main</span> <span class="token attr-value">PID: 10096 (dockerd)</span><span class="token attr-name">    Tasks</span><span class="token punctuation">:</span> <span class="token attr-value">16</span><span class="token attr-name">   CGroup</span><span class="token punctuation">:</span> <span class="token attr-value">/system.slice/docker.service</span><span class="token attr-name">           ├─10096</span> <span class="token attr-value">/usr/bin/dockerd -H fd://</span><span class="token attr-name">           └─10113</span> <span class="token attr-value">docker-containerd --config /var/run/docker/containerd/containerd.toml</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>复制</p><p>Docker不仅可以为您提供Docker服务，还可以为您提供docker命令行工具或Docker客户端。我们将在本教程后面探讨如何使用docker命令。</p><h3 id="第2步-在不输入Sudo情况下执行Docker（可选）"><a href="#第2步-在不输入Sudo情况下执行Docker（可选）" class="headerlink" title="第2步 - 在不输入Sudo情况下执行Docker（可选）"></a>第2步 - 在不输入Sudo情况下执行Docker（可选）</h3><p>默认情况下，该<code>docker</code>命令只能由<strong>root</strong>用户或<strong>docker</strong>组中的用户运行，该用户在Docker的安装过程中自动创建。如果您尝试运行该<code>docker</code>命令而不使用<code>sudo</code>或不在<strong>docker</strong>组中中用户运行，您将看到如下输出：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span><span class="token punctuation">:</span> <span class="token attr-value">Cannot connect to the Docker daemon. Is the docker daemon running on this host?.</span><span class="token attr-name">See</span> <span class="token attr-value">'docker run --help'.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>复制</p><p>要想在在运行<code>docker</code>命令时不输入<code>sudo</code>，请将用户名添加到<code>docker</code>组中：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">sudo</span> <span class="token attr-value">usermod -aG docker ${USER}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>要应用新的组成员身份，请注销服务器并重新登录，或输入以下内容：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">su</span> <span class="token attr-value">- ${USER}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>系统将提示您输入用户密码以继续。</p><p>通过输入以下内容确认您的用户现已添加到<strong>docker</strong>组：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">id</span> <span class="token attr-value">-nG</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">sammy</span> <span class="token attr-value">sudo docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>如果您需要将用户添加到您未登录的<code>docker</code>组中，请使用以下方式明确声明该用户名：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">sudo</span> <span class="token attr-value">usermod -aG docker username</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>本文的其余部分假定您以<strong>docker</strong>组中的用户身份运行该<code>docker</code>命令。如果您不是这样做，请在前面添加<code>sudo</code>命令。</p><h3 id="第3步-使用Docker命令"><a href="#第3步-使用Docker命令" class="headerlink" title="第3步 - 使用Docker命令"></a>第3步 - 使用Docker命令</h3><p>命令使用包括传递一系列<code>docker</code>选项和命令，后跟参数。语法采用以下形式：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">[option] [command] [arguments]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>要查看所有可用的子命令，请输入：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>可用子命令的完整列表包括：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">attach</span> <span class="token attr-value">     Attach local standard input, output, and error streams to a running container</span><span class="token attr-name">build</span> <span class="token attr-value">      Build an image from a Dockerfile</span><span class="token attr-name">commit</span> <span class="token attr-value">     Create a new image from a container's changes</span><span class="token attr-name">cp</span> <span class="token attr-value">         Copy files/folders between a container and the local filesystem</span><span class="token attr-name">create</span> <span class="token attr-value">     Create a new container</span><span class="token attr-name">diff</span> <span class="token attr-value">       Inspect changes to files or directories on a container's filesystem</span><span class="token attr-name">events</span> <span class="token attr-value">     Get real time events from the server</span><span class="token attr-name">exec</span> <span class="token attr-value">       Run a command in a running container</span><span class="token attr-name">export</span> <span class="token attr-value">     Export a container's filesystem as a tar archive</span><span class="token attr-name">history</span> <span class="token attr-value">    Show the history of an image</span><span class="token attr-name">images</span> <span class="token attr-value">     List images</span><span class="token attr-name">import</span> <span class="token attr-value">     Import the contents from a tarball to create a filesystem image</span><span class="token attr-name">info</span> <span class="token attr-value">       Display system-wide information</span><span class="token attr-name">inspect</span> <span class="token attr-value">    Return low-level information on Docker objects</span><span class="token attr-name">kill</span> <span class="token attr-value">       Kill one or more running containers</span><span class="token attr-name">load</span> <span class="token attr-value">       Load an image from a tar archive or STDIN</span><span class="token attr-name">login</span> <span class="token attr-value">      Log in to a Docker registry</span><span class="token attr-name">logout</span> <span class="token attr-value">     Log out from a Docker registry</span><span class="token attr-name">logs</span> <span class="token attr-value">       Fetch the logs of a container</span><span class="token attr-name">pause</span> <span class="token attr-value">      Pause all processes within one or more containers</span><span class="token attr-name">port</span> <span class="token attr-value">       List port mappings or a specific mapping for the container</span><span class="token attr-name">ps</span> <span class="token attr-value">         List containers</span><span class="token attr-name">pull</span> <span class="token attr-value">       Pull an image or a repository from a registry</span><span class="token attr-name">push</span> <span class="token attr-value">       Push an image or a repository to a registry</span><span class="token attr-name">rename</span> <span class="token attr-value">     Rename a container</span><span class="token attr-name">restart</span> <span class="token attr-value">    Restart one or more containers</span><span class="token attr-name">rm</span> <span class="token attr-value">         Remove one or more containers</span><span class="token attr-name">rmi</span> <span class="token attr-value">        Remove one or more images</span><span class="token attr-name">run</span> <span class="token attr-value">        Run a command in a new container</span><span class="token attr-name">save</span> <span class="token attr-value">       Save one or more images to a tar archive (streamed to STDOUT by default)</span><span class="token attr-name">search</span> <span class="token attr-value">     Search the Docker Hub for images</span><span class="token attr-name">start</span> <span class="token attr-value">      Start one or more stopped containers</span><span class="token attr-name">stats</span> <span class="token attr-value">      Display a live stream of container(s) resource usage statistics</span><span class="token attr-name">stop</span> <span class="token attr-value">       Stop one or more running containers</span><span class="token attr-name">tag</span> <span class="token attr-value">        Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span><span class="token attr-name">top</span> <span class="token attr-value">        Display the running processes of a container</span><span class="token attr-name">unpause</span> <span class="token attr-value">    Unpause all processes within one or more containers</span><span class="token attr-name">update</span> <span class="token attr-value">     Update configuration of one or more containers</span><span class="token attr-name">version</span> <span class="token attr-value">    Show the Docker version information</span><span class="token attr-name">wait</span> <span class="token attr-value">       Block until one or more containers stop, then print their exit codes</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>复制</p><p>要查看特定命令，请输入：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">docker-subcommand --help</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>要查看有关Docker的系统信息，请使用：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">info</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>让我们探讨其中的一些命令。我们将从处理镜像开始。</p><h3 id="第4步-使用Docker镜像"><a href="#第4步-使用Docker镜像" class="headerlink" title="第4步 - 使用Docker镜像"></a>第4步 - 使用Docker镜像</h3><p>Docker容器是从Docker镜像构建的。默认情况下，Docker从<a href="https://hub.docker.com/">Docker Hub</a>中提取这些镜像，这是一个由Docker管理的Docker镜像市场，这是Docker项目背后的公司。任何人都可以在Docker Hub上托管他们的Docker镜像，所以您只需要将您的应用程序和Linux放在那边托管即可。</p><p>要检查您是否可以从Docker Hub访问和下载镜像，请输入：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">run hello-world</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>输出下面的内容则Docker正常工作：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">Unable</span> <span class="token attr-value">to find image 'hello-world:latest' locally</span><span class="token attr-name">latest</span><span class="token punctuation">:</span> <span class="token attr-value">Pulling from library/hello-world</span><span class="token attr-name">9bb5a5d4561a</span><span class="token punctuation">:</span> <span class="token attr-value">Pull complete</span><span class="token attr-name">Digest</span><span class="token punctuation">:</span> <span class="token attr-value">sha256:3e1764d0f546ceac4565547df2ac4907fe46f007ea229fd7ef2718514bcec35d</span><span class="token attr-name">Status</span><span class="token punctuation">:</span> <span class="token attr-value">Downloaded newer image for hello-world:latest</span><span class="token attr-name">Hello</span> <span class="token attr-value">from Docker!</span><span class="token attr-name">This</span> <span class="token attr-value">message shows that your installation appears to be working correctly.</span>...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>复制</p><p>Docker最初无法在本地找到<code>hello-world</code>镜像，因此它从Docker Hub下载了镜像，Docker Hub是默认存储库。下载映像后，Docker从映像创建了一个容器，并在容器中执行了应用程序，显示了该消息。</p><p>您可以使用<code>docker</code>带子命令的<code>search</code>命令搜索Docker Hub上可用的镜像。例如，要搜索Ubuntu映像，请输入：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">search ubuntu</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>该脚本将对Docker Hub进行抓取，并返回名称与搜索字符串匹配的所有镜像的列表。输出将类似于：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">NAME</span> <span class="token attr-value">                                                     DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><span class="token attr-name">ubuntu</span> <span class="token attr-value">                                                   Ubuntu is a Debian-based Linux operating sys…   7917                [OK]</span><span class="token attr-name">dorowu/ubuntu-desktop-lxde-vnc</span> <span class="token attr-value">                           Ubuntu with openssh-server and NoVNC            193                                     [OK]</span><span class="token attr-name">rastasheep/ubuntu-sshd</span> <span class="token attr-value">                                   Dockerized SSH service, built on top of offi…   156                                     [OK]</span><span class="token attr-name">ansible/ubuntu14.04-ansible</span> <span class="token attr-value">                              Ubuntu 14.04 LTS with ansible                   93                                      [OK]</span><span class="token attr-name">ubuntu-upstart</span> <span class="token attr-value">                                           Upstart is an event-based replacement for th…   87                  [OK]</span><span class="token attr-name">neurodebian</span> <span class="token attr-value">                                              NeuroDebian provides neuroscience research s…   50                  [OK]</span><span class="token attr-name">ubuntu-debootstrap</span> <span class="token attr-value">                                       debootstrap --variant=minbase --components=m…   38                  [OK]</span><span class="token attr-name">1and1internet/ubuntu-16-nginx-php-phpmyadmin-mysql-5</span> <span class="token attr-value">     ubuntu-16-nginx-php-phpmyadmin-mysql-5          36                                      [OK]</span><span class="token attr-name">nuagebec/ubuntu</span> <span class="token attr-value">                                          Simple always updated Ubuntu docker images w…   23                                      [OK]</span><span class="token attr-name">tutum/ubuntu</span> <span class="token attr-value">                                             Simple Ubuntu docker images with SSH access     18</span><span class="token attr-name">i386/ubuntu</span> <span class="token attr-value">                                              Ubuntu is a Debian-based Linux operating sys…   13</span><span class="token attr-name">ppc64le/ubuntu</span> <span class="token attr-value">                                           Ubuntu is a Debian-based Linux operating sys…   12</span><span class="token attr-name">1and1internet/ubuntu-16-apache-php-7.0</span> <span class="token attr-value">                   ubuntu-16-apache-php-7.0                        10                                      [OK]</span><span class="token attr-name">1and1internet/ubuntu-16-nginx-php-phpmyadmin-mariadb-10</span> <span class="token attr-value">  ubuntu-16-nginx-php-phpmyadmin-mariadb-10       6                                       [OK]</span><span class="token attr-name">eclipse/ubuntu_jdk8</span> <span class="token attr-value">                                      Ubuntu, JDK8, Maven 3, git, curl, nmap, mc, …   6                                       [OK]</span><span class="token attr-name">codenvy/ubuntu_jdk8</span> <span class="token attr-value">                                      Ubuntu, JDK8, Maven 3, git, curl, nmap, mc, …   4                                       [OK]</span><span class="token attr-name">darksheer/ubuntu</span> <span class="token attr-value">                                         Base Ubuntu Image -- Updated hourly             4                                       [OK]</span><span class="token attr-name">1and1internet/ubuntu-16-apache</span> <span class="token attr-value">                           ubuntu-16-apache                                3                                       [OK]</span><span class="token attr-name">1and1internet/ubuntu-16-nginx-php-5.6-wordpress-4</span> <span class="token attr-value">        ubuntu-16-nginx-php-5.6-wordpress-4             3                                       [OK]</span><span class="token attr-name">1and1internet/ubuntu-16-sshd</span> <span class="token attr-value">                             ubuntu-16-sshd                                  1                                       [OK]</span><span class="token attr-name">pivotaldata/ubuntu</span> <span class="token attr-value">                                       A quick freshening-up of the base Ubuntu doc…   1</span><span class="token attr-name">1and1internet/ubuntu-16-healthcheck</span> <span class="token attr-value">                      ubuntu-16-healthcheck                           0                                       [OK]</span><span class="token attr-name">pivotaldata/ubuntu-gpdb-dev</span> <span class="token attr-value">                              Ubuntu images for GPDB development              0</span><span class="token attr-name">smartentry/ubuntu</span> <span class="token attr-value">                                        ubuntu with smartentry                          0                                       [OK]</span>ossobv/ubuntu...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>复制</p><p>在<strong>OFFICIAL</strong>列中，带<strong>OK</strong>标记的表明这个镜像由公司构建和支持。其他镜像则由个人创建。确定要使用的映像后，可以使用命令<code>pull</code>将其下载到计算机。</p><p>执行以下<code>ubuntu</code>命令将官方映像下载到您的计算机：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">pull ubuntu</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>您将看到以下输出：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">Using</span> <span class="token attr-value">default tag: latest</span><span class="token attr-name">latest</span><span class="token punctuation">:</span> <span class="token attr-value">Pulling from library/ubuntu</span><span class="token attr-name">6b98dfc16071</span><span class="token punctuation">:</span> <span class="token attr-value">Pull complete</span><span class="token attr-name">4001a1209541</span><span class="token punctuation">:</span> <span class="token attr-value">Pull complete</span><span class="token attr-name">6319fc68c576</span><span class="token punctuation">:</span> <span class="token attr-value">Pull complete</span><span class="token attr-name">b24603670dc3</span><span class="token punctuation">:</span> <span class="token attr-value">Pull complete</span><span class="token attr-name">97f170c87c6f</span><span class="token punctuation">:</span> <span class="token attr-value">Pull complete</span><span class="token attr-name">Digest</span><span class="token punctuation">:</span> <span class="token attr-value">sha256:5f4bdc3467537cbbe563e80db2c3ec95d548a9145d64453b06939c4592d67b6d</span><span class="token attr-name">Status</span><span class="token punctuation">:</span> <span class="token attr-value">Downloaded newer image for ubuntu:latest</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>复制</p><p>下载映像后，可以使用子命令<code>run</code>运行容器。正如示例中那样，如果在使用子命令docker执行时未下载<code>hello-world</code>镜像，则Docker客户端将首先下载镜像，然后使用<code>run</code>运行容器。</p><p>要查看已下载到计算机的镜像，请输入：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">images</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>输出应类似于以下内容：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">REPOSITORY</span> <span class="token attr-value">         TAG                 IMAGE ID            CREATED             SIZE</span><span class="token attr-name">ubuntu</span> <span class="token attr-value">             latest              113a43faa138        4 weeks ago         81.2MB</span><span class="token attr-name">hello-world</span> <span class="token attr-value">        latest              e38bc07ac18e        2 months ago        1.85kB</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>复制</p><p>正如您将在本教程后面看到的那样，用于运行容器的镜像可以被修改并用于生成新镜像，然后可以将其上传到Docker Hub或其他Docker镜像托管网站。</p><p>我们来看看如何更详细地运行容器。</p><h3 id="第5步-运行Docker容器"><a href="#第5步-运行Docker容器" class="headerlink" title="第5步 - 运行Docker容器"></a>第5步 - 运行Docker容器</h3><p>在您在上一步中<code>hello-world</code>容器是运行并发出一个测试消息之后退出容器。容器可以比这更有用，它们可以是交互式的。毕竟，它们类似于虚拟机，只是更加有利于资源。</p><p>举个例子，让我们使用Ubuntu的最新镜像运行一个容器。**-i<strong>和</strong>-t**子命令的意思为您提供了对容器的交互式shell访问：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">run -it ubuntu</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>现在，您应该已经进入docker内部，在这个环境下，您的shell展现如下：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">root@d9b100f2f636</span><span class="token punctuation">:</span><span class="token attr-value">/#</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>请注意命令提示符中的容器ID。在例子中它是<code>d9b100f2f636</code>，稍后您需要该容器ID以在要删除容器时标识容器。现在您可以在容器内运行任何命令。例如，让我们更新容器内的包数据库。您不需要<code>sudo</code>命令添加前缀，因为您以<strong>root</strong>用户身份在容器内操作：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">apt</span> <span class="token attr-value">update</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>然后在其中安装任何应用程序。我们安装Node.js：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">apt</span> <span class="token attr-value">install nodejs</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>这将从官方Ubuntu存储库中安装容器中的Node.js. 安装完成后，验证是否已安装Node.js：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">node</span> <span class="token attr-value">-v</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>您将看到终端中显示的版本号：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">v8.10.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>您在容器内进行的任何更改仅适用于该容器。要退出容器，请输入<code>exit</code>退出。</p><p>让我们看看下一步管理我们系统上的容器。</p><h3 id="第6步-管理Docker容器"><a href="#第6步-管理Docker容器" class="headerlink" title="第6步 - 管理Docker容器"></a>第6步 - 管理Docker容器</h3><p>使用Docker一段时间后，您的计算机上将有许多运行和非运行容器。要查看<strong>运行的</strong>，请使用：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">ps</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>您将看到类似于以下内容的输出：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">CONTAINER</span> <span class="token attr-value">ID        IMAGE               COMMAND             CREATED             </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>在本教程中，您启动了两个容器。一个来自<code>hello-world</code>镜像，另一个来自<code>ubuntu</code>镜像。两个容器都不再运行，但它们仍然存在于您的系统上。</p><p>要查看所有容器的运行状态，请使用<code>docker ps</code>命令加指令<code>-a</code>运行：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">ps -a</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>您将看到类似于此的输出：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">d9b100f2f636</span> <span class="token attr-value">       ubuntu              "/bin/bash"         About an hour ago   Exited (0) 8 minutes ago                           sharp_volhard</span><span class="token attr-name">01c950718166</span> <span class="token attr-value">       hello-world         "/hello"            About an hour ago   Exited (0) About an hour ago                       festive_williams</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>复制</p><p>要查看您创建的最新容器，请使用<code>-l</code>命令：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">ps -l</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">CONTAINER</span> <span class="token attr-value">ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES</span><span class="token attr-name">d9b100f2f636</span> <span class="token attr-value">       ubuntu              "/bin/bash"         About an hour ago   Exited (0) 10 minutes ago                       sharp_volhard</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>复制</p><p>要启动已停止的容器，请使用<code>docker start</code>，后跟容器ID<code>d9b100f2f636</code>。让我们启动基于Ubuntu的容器，命令如下：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">start d9b100f2f636</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>容器将启动，您可以使用docker ps来查看其状态：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">CONTAINER</span> <span class="token attr-value">ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><span class="token attr-name">d9b100f2f636</span> <span class="token attr-value">       ubuntu              "/bin/bash"         About an hour ago   Up 8 seconds                            sharp_volhard</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>复制</p><p>要停止正在运行的容器，请使用<code>docker stop</code>，后跟容器ID或名称<code>sharp_volhard</code>。这次，我们将使用Docker分配容器的名称，即：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">stop sharp_volhard</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>一旦您决定不再需要容器，请使用<code>docker rm</code>命令将其删除。使用该<code>docker ps -a</code>命令查找与映像<code>hello-world</code>关联的容器的容器，然后将其删除。</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">rm festive_williams</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>您可以使用开关启动一个新容器并为其命名–name。您还可以使用该开关创建一个在停止时自行删除的容器–rm。有关这些选项和其他选项的更多信息，请参阅<code>docker run help</code>命令。</p><p>容器可以转换为可用于构建新容器的映像。让我们来看看它是如何工作的。</p><h3 id="步骤7-将容器中的更改提交到Docker镜像"><a href="#步骤7-将容器中的更改提交到Docker镜像" class="headerlink" title="步骤7 - 将容器中的更改提交到Docker镜像"></a>步骤7 - 将容器中的更改提交到Docker镜像</h3><p>当您启动Docker镜像时，您可以像使用虚拟机一样创建，修改和删除文件。您所做的更改仅适用于该容器。您可以启动和停止它，但是一旦使用<code>docker rm</code>命令销毁它，更改将永久丢失。本节介绍如何将容器的状态保存为新的Docker镜像。</p><p>在Ubuntu容器中安装Node.js后，您现在有一个运行镜像的容器，但容器与您用来创建它的镜像不同。但是您可能希望稍后重新使用此容器作为新映像。</p><p>然后使用以下命令将更改提交到新的Docker镜像实例。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">docker commit <span class="token operator">-</span>m <span class="token string">"What you did to the image"</span> <span class="token operator">-</span>a <span class="token string">"Author Name"</span> container_id repository<span class="token operator">/</span>new_image_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>该**-m<strong>是提交信息，可以帮助你和其他人知道你所做的修改，而</strong>-a**用于指定作者。当您启动交互式Docker会话时，这是您在本教程前面提到的那个<code>container_id</code>。除非您在Docker Hub上创建了其他repository存储库，否则通常是您的Docker Hub用户名。</p><p>例如，对于用户<strong>sammy</strong>，使用容器ID：d9b100f2f636 ，命令将是：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">docker commit <span class="token operator">-</span>m <span class="token string">"added Node.js"</span> <span class="token operator">-</span>a <span class="token string">"sammy"</span> d9b100f2f636 sammy<span class="token operator">/</span>ubuntu<span class="token operator">-</span>nodejs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>当你提交镜像后，新的镜像在您的计算机上本地保存。在本教程的后面，您将学习如何将映像推送到<code>Docker Hub</code>之类的Docker镜像市场，以便其他人可以访问它。</p><p>再次列出Docker镜像将显示旧镜像以及从中衍生的新镜像：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">docker images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>你会看到这样的输出：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">REPOSITORY</span> <span class="token attr-value">              TAG                 IMAGE ID            CREATED             SIZE</span><span class="token attr-name">sammy/ubuntu-nodejs</span> <span class="token attr-value">  latest              7c1f35226ca6        7 seconds ago       179MB</span><span class="token attr-name">ubuntu</span> <span class="token attr-value">                  latest              113a43faa138        4 weeks ago         81.2MB</span><span class="token attr-name">hello-world</span> <span class="token attr-value">             latest              e38bc07ac18e        2 months ago        1.85kB</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>复制</p><p>在此示例中，是新镜像<code>ubuntu-nodejs</code>，它是从Docker Hub的<code>ubuntu</code>现有镜像衍生的。镜像大小差异反映了所做的变化。因此，下次需要使用预先安装了NodeJS的Ubuntu运行容器时，您可以使用新映像<code>ubuntu-nodejs</code>。</p><p>您还可以从<code>Dockerfile</code>构建映像，这样可以在新映像中自动安装软件。但是，这超出了本教程的范围。</p><p>现在让我们与他人分享新镜像，以便他们可以从中创建容器。</p><h3 id="步骤8-将Docker镜像推送到Docker存储库"><a href="#步骤8-将Docker镜像推送到Docker存储库" class="headerlink" title="步骤8 - 将Docker镜像推送到Docker存储库"></a>步骤8 - 将Docker镜像推送到Docker存储库</h3><p>从现有映像创建新映像之后的下一个步骤是与您几个朋友分享，Docker Hub上的镜像全世界都可以访问，不过你先要安装注册Docker Hub地址才行。</p><p>本节介绍如何将Docker镜像推送到Docker Hub，要推送镜像，请先登录Docker Hub。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">docker login <span class="token operator">-</span>u docker<span class="token operator">-</span>registry<span class="token operator">-</span>username<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>系统将提示您使用Docker Hub密码进行<a href="https://cloud.tencent.com/product/mfas?from=10680">身份验证</a>。然后你可以使用以下方法推送自己的镜像</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">docker push docker<span class="token operator">-</span>registry<span class="token operator">-</span>username<span class="token operator">/</span>docker<span class="token operator">-</span>image<span class="token operator">-</span>name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>要将<code>ubuntu-nodejs</code>镜像推送到<strong>sammy</strong>存储库，命令是：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">docker push sammy<span class="token operator">/</span>ubuntu<span class="token operator">-</span>nodejs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制</p><p>上传镜像时，该过程可能需要一些时间才能完成，完成后，输出将如下所示：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">The</span> <span class="token attr-value">push refers to a repository [docker.io/sammy/ubuntu-nodejs]</span><span class="token attr-name">e3fbbfb44187</span><span class="token punctuation">:</span> <span class="token attr-value">Pushed</span><span class="token attr-name">5f70bf18a086</span><span class="token punctuation">:</span> <span class="token attr-value">Pushed</span><span class="token attr-name">a3b5c80a4eba</span><span class="token punctuation">:</span> <span class="token attr-value">Pushed</span><span class="token attr-name">7f18b442972b</span><span class="token punctuation">:</span> <span class="token attr-value">Pushed</span><span class="token attr-name">3ce512daaf78</span><span class="token punctuation">:</span> <span class="token attr-value">Pushed</span><span class="token attr-name">7aae4540b42d</span><span class="token punctuation">:</span> <span class="token attr-value">Pushed</span>...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>复制</p><p>将镜像推送到注册表后，它应该列在您帐户的控制台上，</p><p>如果推送尝试导致此类错误，那么您可能没有登录：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">The</span> <span class="token attr-value">push refers to a repository [docker.io/sammy/ubuntu-nodejs]</span><span class="token attr-name">e3fbbfb44187</span><span class="token punctuation">:</span> <span class="token attr-value">Preparing</span><span class="token attr-name">5f70bf18a086</span><span class="token punctuation">:</span> <span class="token attr-value">Preparing</span><span class="token attr-name">a3b5c80a4eba</span><span class="token punctuation">:</span> <span class="token attr-value">Preparing</span><span class="token attr-name">7f18b442972b</span><span class="token punctuation">:</span> <span class="token attr-value">Preparing</span><span class="token attr-name">3ce512daaf78</span><span class="token punctuation">:</span> <span class="token attr-value">Preparing</span><span class="token attr-name">7aae4540b42d</span><span class="token punctuation">:</span> <span class="token attr-value">Waiting</span><span class="token attr-name">unauthorized</span><span class="token punctuation">:</span> <span class="token attr-value">authentication required</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>复制</p><p>登录docker login并尝试重复推送。然后验证是否存在于Docker Hub存储库页面上。</p><p>您现在可以使用<code>docker pull sammy/ubuntu-node&lt;^&gt;</code>将镜像拉取到新计算机并使用它来运行新容器。</p><h1 id="第五章-docker初体验"><a href="#第五章-docker初体验" class="headerlink" title="第五章 docker初体验"></a>第五章 docker初体验</h1><h2 id="5-1-docker基本命令"><a href="#5-1-docker基本命令" class="headerlink" title="5.1 docker基本命令"></a>5.1 docker基本命令</h2><h3 id="5-1-1-创建容器"><a href="#5-1-1-创建容器" class="headerlink" title="5.1.1 创建容器"></a>5.1.1 创建容器</h3><p><code>docker create </code>命令通过镜像去创建一个容器，同时吐出容器 id。</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">&gt;</span> <span class="token attr-value">docker create --name ubuntuContainer ubuntu:18.04</span>0da83bc6515ea1df100c32cccaddc070199b72263663437b8fe424aadccf4778<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>用 <code>docker start</code>即可运行改容器。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> <span class="token function">docker</span> start ubuntuContainer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用 <code>docker ps</code>即可查看运行中的 container</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">&gt;</span> <span class="token attr-value">docker ps</span><span class="token attr-name">CONTAINER</span> <span class="token attr-value">ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><span class="token attr-name">9298a27262da</span> <span class="token attr-value">       ubuntu:18.04        "/bin/bash"         4 minutes ago       Up About a minute                       ubuntuContainer</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>用 <code>docker exec</code>即可进入该 container。</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">&gt;</span> <span class="token attr-value">docker exec -it 9298</span><span class="token attr-name">root@9298a27262da</span><span class="token punctuation">:</span><span class="token attr-value">/# ls</span><span class="token attr-name">bin</span> <span class="token attr-value"> boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><span class="token attr-name">root@9298a27262da</span><span class="token punctuation">:</span><span class="token attr-value">/# exit</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>用 <code>docker run</code> 可以一步到位创建并运行一个容器，然后进入该容器。</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">&gt;</span> <span class="token attr-value">docker run -it --name runUbuntuContainer ubuntu:18.04 /bin/bash</span><span class="token attr-name">root@57cdd61d4383</span><span class="token punctuation">:</span><span class="token attr-value">/# ls</span><span class="token attr-name">bin</span> <span class="token attr-value"> boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><span class="token attr-name">root@57cdd61d4383</span><span class="token punctuation">:</span><span class="token attr-value">/#</span><span class="token comment"># docker ps 可以查到已经成功运行了 runUbuntuContainer</span><span class="token attr-name">&gt;</span> <span class="token attr-value">docker ps</span><span class="token attr-name">CONTAINER</span> <span class="token attr-value">ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><span class="token attr-name">57cdd61d4383</span> <span class="token attr-value">       ubuntu:18.04        "/bin/bash"         9 seconds ago       Up 8 seconds                            runUbuntuContainer</span><span class="token attr-name">9298a27262da</span> <span class="token attr-value">       ubuntu:18.04        "/bin/bash"         9 minutes ago       Up 6 minutes                    </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-1-2-查看删除镜像"><a href="#5-1-2-查看删除镜像" class="headerlink" title="5.1.2 查看删除镜像"></a>5.1.2 查看删除镜像</h3><ul><li><p><strong>列出镜像</strong>：<em>docker images [OPTIONS] [REPOSITORY]</em></p><p>-a，–all=false，显示所有镜像</p><p>-f，–filter=[]，显示时过滤条件</p><p>–no-trunc=false，指定不使用截断的形式显示数据</p><p>-q，–quiet=false，只显示镜像的唯一id</p></li></ul><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F.png" alt="image-20220405084822992" style="zoom:80%;"><ul><li><p><strong>查看镜像</strong>：<code>docker inspect [OPTIONS] CONTAINER|IMAGE [CONTAINER|IMAGE]</code></p><p>-f，–format=“”</p></li></ul><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F2.png" alt="image-20220405084914929" style="zoom:80%;"><ul><li><p><strong>删除镜像</strong>：<code>docker rmi [OPTIONS] IMAGE [IMAGE]</code></p><p>-f，–force=false，强制删除镜像</p><p>–no-prune=false，保留未打标签的父镜像</p></li><li><p><strong>虚悬镜像</strong>：既没有仓库名，也没有标签，均为\</p></li></ul><h3 id="5-1-3-获取推送镜像"><a href="#5-1-3-获取推送镜像" class="headerlink" title="5.1.3 获取推送镜像"></a>5.1.3 获取推送镜像</h3><ul><li><p><strong>查找镜像</strong>：<code>docker search [OPTIONS] TEAM</code></p><p>–automated=false，仅显示自动化构建的镜像</p><p>–no-trunc=false，不以截断的方式输出</p><p>–filter，添加过滤条件</p></li></ul><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E6%9F%A5%E6%89%BE%E9%95%9C%E5%83%8F.png" alt="image-20220405085006406" style="zoom:80%;"><ul><li><p><strong>拉取镜像</strong>：<code>docker pull [OPTIONS] NAME [:TAG]</code></p><p>-a，–all-tags=false，下载所有的镜像（包含所有TAG）</p></li></ul><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F.png" alt="image-20220405085032856" style="zoom:100%;"><ul><li><p>推送镜像：<code>docker push NAME [:TAG]</code></p><p>Docker允许上传我们自己构建的镜像，需要注册DockerHub的账户。也可以上传到阿里云，地址：<a href="https://cr.console.aliyun.com/#/namespace/index">https://cr.console.aliyun.com/#/namespace/index</a></p></li></ul><h3 id="5-1-4-构建镜像"><a href="#5-1-4-构建镜像" class="headerlink" title="5.1.4 构建镜像"></a>5.1.4 构建镜像</h3><p>​        构建Docker镜像，可以保存对容器的修改，并且再次使用。构建镜像提供了自定义镜像的能力，以软件的形式打包并分发服务及其运行环境。Docker中提供了两种方式来构建镜像：</p><ul><li>通过容器构建：<em>docker commit</em></li><li>通过Dockerfile：<em>docker build</em></li></ul><p><strong>使用commit命令构建镜像</strong></p><p>命令：<code>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code></p><p>参数：  -a，–author=“”，指定镜像的作者信息</p><p>​             -m，–message=“”，提交信息</p><p>​             -p，–pause=true，commit时是否暂停容器</p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F.png" alt="image-20220405085124136"></p><p><strong>使用Dockerfile文件构建镜像</strong></p><p>​        Docker允许我们利用一个类似配置文件的形式来进行构建自定义镜像，在文件中可以指定原始的镜像，自定义镜像的维护人信息，对原始镜像采取的操作以及暴露的端口等信息。比如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Sample Dockerfile</span>FROM ubuntu:16.04MAINTAINER wgp <span class="token string">"Kingdompin@163.com"</span>RUN <span class="token function">apt-get</span> updateRUN <span class="token function">apt-get</span> <span class="token function">install</span> -y nginxEXPOSE <span class="token number">80123456</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>命令：<code>docker build [OPTIONS] DockerFile_PATH | URL | -</code></p><p>参数：  –force-rm=false</p><p>​             –no-cache=false</p><p>​             –pull=false</p><p>​             -q，quite=false，构建时不输出信息</p><p>​             –rm=true</p><p>​             -t，tag=“”，指定输出的镜像名称信息</p><p>​    <img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E7%BC%96%E8%BE%91dockerfile.png" alt="image-20220405085156138" style="zoom:80%;"></p><h2 id="5-2-镜像迁移"><a href="#5-2-镜像迁移" class="headerlink" title="5.2 镜像迁移"></a>5.2 镜像迁移</h2><p>​        我们制作好的镜像，一般会迁移或分享给其他需要的人。Docker提供了几种将我们的镜像迁移、分享给其他人的方式。推荐镜像迁移应该直接使用Docker Registry，无论是直接使用Docker Hub还是使用内网私有Registry都可以。使用镜像频率不高，镜像数量不多的情况下，我们可以选择以下两种方式。</p><h3 id="5-2-1-上传Docker-Hub"><a href="#5-2-1-上传Docker-Hub" class="headerlink" title="5.2.1 上传Docker Hub"></a>5.2.1 上传Docker Hub</h3><p>首先，需要在<a href="https://hub.docker.com/">Docker Hub</a>上申请注册一个帐号。然后我们需要创建仓库，指定仓库名称。</p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/dockerhub.png" alt="image-20220405085249992" style="zoom:80%;"><p>在终端中登录你的Docker Hub账户，输入<code>docker login</code>，输入用户名密码即可登录成功。</p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E7%99%BB%E5%BD%95.png" alt="image-20220405085317592" style="zoom:80%;"><p>查看需要上传的镜像，并将选择的镜像打上标签，标签名需和Docker Hub上新建的仓库名称一致，否则上传失败。给镜像打标签的命令如下。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> tag <span class="token operator">&lt;</span>existing-image<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>hub-user<span class="token operator">&gt;</span>/<span class="token operator">&lt;</span>repo-name<span class="token operator">&gt;</span><span class="token punctuation">[</span>:<span class="token operator">&lt;</span>tag<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中<code>existing-image</code>代表本地待上传的镜像名加tag，后面<code>&lt;hub-user&gt;/&lt;repo-name&gt;[:&lt;tag&gt;]</code>则是为上传更改的标签名，tag不指定则为latest。</p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E4%B8%8A%E4%BC%A0.png" alt="image-20220405085342292"></p><p>可以看到，我们重新为ubuntu:16.04的镜像打上标签，观察IMAGE ID可知，同一镜像可以拥有不同的标签名。接下来，我们利用<code>push</code>命令直接上传镜像。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> push <span class="token operator">&lt;</span>hub-user<span class="token operator">&gt;</span>/<span class="token operator">&lt;</span>repo-name<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>tag<span class="token operator">&gt;</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如图，我们已经上传成功。由于之前介绍的分层存储系统，我们这里是直接对已有的ubuntu镜像进行上传，只是重新打了标签，所以真正上传的只是变化的部分。</p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E6%98%BE%E7%A4%BA.png" alt="image-20220405085403757"></p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/docker%E7%95%8C%E9%9D%A2.png" alt="image-20220405085421009" style="zoom:80%;"><h3 id="5-2-2-导出文件互传"><a href="#5-2-2-导出文件互传" class="headerlink" title="5.2.2 导出文件互传"></a>5.2.2 导出文件互传</h3><p>Docker 还提供了 <code>docker load</code> 和 <code>docker save</code> 命令，用以将镜像保存为一个tar文件。比如这次我们将ubuntu:latest这个镜像保存为tar文件。</p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E6%96%87%E4%BB%B6%E4%BA%92%E4%BC%A0.png" alt="image-20220405085507252" style="zoom:80%;"><p>查看本地磁盘，即可看见名为ubuntu18.04的tar包。我们可以将其拷贝给其他PC，利用load命令重新导入。</p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E6%9F%A5%E7%9C%8B%E6%9C%AC%E5%9C%B0%E7%A3%81%E7%9B%98.png" alt="image-20220405085540271" style="zoom:80%;"><h2 id="5-3-镜像容器日志"><a href="#5-3-镜像容器日志" class="headerlink" title="5.3 镜像容器日志"></a>5.3 镜像容器日志</h2><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 1. 启动守护式容器(后台运行)</span><span class="token attr-name">docker</span> <span class="token attr-value">-d 容器名</span><span class="token comment"># 使用镜像centos:latest以后台模式启动一个容器</span><span class="token attr-name">docker</span> <span class="token attr-value">run -d centos</span><span class="token attr-name">问题：然后docker</span> <span class="token attr-value">ps -a 进行查看, 会发现容器已经退出</span><span class="token attr-name">很重要的要说明的一点</span><span class="token punctuation">:</span> <span class="token attr-value">Docker容器后台运行,就必须有一个前台进程.</span>容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。<span class="token attr-name">这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。例如service</span> <span class="token attr-value">nginx start</span>但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用,这样的容器后台启动后,会立即自杀因为他觉得他没事可做了.所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行<span class="token comment"># 2. 查看容器日志</span><span class="token attr-name">docker</span> <span class="token attr-value">logs -f -t --tail 容器ID</span><span class="token attr-name">eg</span> <span class="token punctuation">:</span><span class="token attr-value">(图1)</span><span class="token attr-name">docker</span> <span class="token attr-value">run -d centos /bin/sh -c "while true;do echo hello testLogs;sleep 2;done"</span><span class="token attr-name">docker</span> <span class="token attr-value">logs -tf --tail 10 02c81778b0e0</span><span class="token attr-name">-t</span> <span class="token attr-value">是加入时间戳</span><span class="token attr-name">-f</span> <span class="token attr-value">跟随最新的日志打印</span><span class="token attr-name">--tail</span> <span class="token attr-value">数字 显示最后多少条</span><span class="token comment"># 3. 查看容器内运行的进程(图2)</span><span class="token attr-name">docker</span> <span class="token attr-value">top 容器ID</span><span class="token comment"># 4. 查看容器内部细节(图3)</span><span class="token attr-name">docker</span> <span class="token attr-value">inspect 容器ID</span><span class="token comment"># 5.进入正在运行的容器并进行交互(图4)</span><span class="token attr-name">docker</span> <span class="token attr-value">exec -it 容器ID bashShell</span><span class="token comment"># 6. 重新进入容器(图5)</span><span class="token attr-name">docker</span> <span class="token attr-value">attach 容器ID bashShell(不写的话默认 /bin/bash下)</span><span class="token comment"># 比较5与6的区别</span><span class="token attr-name">attach</span> <span class="token attr-value">直接进入容器启动命令终端, 不会启动新的线程</span><span class="token attr-name">exec</span> <span class="token attr-value">是在容器中打开新的终端, 并且可以启动新的线程</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="第六章-docker运行nginx"><a href="#第六章-docker运行nginx" class="headerlink" title="第六章 docker运行nginx"></a>第六章 docker运行nginx</h1><h2 id="6-1-运行nginx镜像"><a href="#6-1-运行nginx镜像" class="headerlink" title="6.1 运行nginx镜像"></a>6.1 运行nginx镜像</h2><p>​        我们打开网易蜂巢镜像中心 <a href="https://c.163yun.com/hub#/m/home/">https://c.163yun.com/hub#/m/home/</a></p><p>​        搜索nginx，可以看到有两个nginx，他们的名字和头上和图标都不一样，一个是鲸鱼，一个是两个球。</p><p>​        带有鲸鱼的镜像表示这个镜像是从官网的镜像中心复制过来的。这个镜像与docker的镜像是一摸一样的。我们使用此镜像。</p><p>点进去，会有下载地址，复制里面的地址，然后拉取镜像。</p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E6%9F%A5%E8%AF%A2%E9%95%9C%E5%83%8F.png" alt="image-20220404212013378"></p><p>复制到系统中运行。</p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F.png" alt="image-20220404212027692"></p><p>运行完后可以查看镜像状态</p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E6%9F%A5%E7%9C%8B%E7%8A%B6%E6%80%81.png" alt="image-20220404212040199"></p><p>在前台运行容器命令如下，输入后容器就会运行，按ctrl+c可以终止容器的运行。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run hub.c.163.com/library/nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在后台运行容器:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d hub.c.163.com/library/nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E8%BF%90%E8%A1%8C.png" alt="image-20220404212054623"></p><p>查看运行的容器:</p><pre class="line-numbers language-undefined" data-language="undefined"><code class="language-undefined">docker ps<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="image-20220404212157070"></p><p>更多关于运行的命令:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">docker run <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">help</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为我们在平时运行的时候需要调试容器内部的设置、查看一下日志等等。我们可以通过如下命令进入容器内部:</p><p>命令的大体内容:</p><p><img src="/2022/04/04/ctf-xue-xi/yi-ji-chu-zhi-shi/docker/docker-shi-yong-jian-jie/image-20220404212208939.png" alt="image-20220404212208939"></p><p>命令具体内容: </p><pre class="line-numbers language-python" data-language="python"><code class="language-python">docker <span class="token keyword">exec</span> <span class="token operator">-</span>it 02963d2002b bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> -i保证我们的输入有效，即使在没有detach的情况下也能运行。</p><p>-t表示将分配给我们一个伪终端。我们将在伪终端输入我们的内容。</p><p>后面跟着的是容器的id，即我们上面用ps查询出来的id，这个id可以少写几位，它会自动识别。</p><p>可输入如下命令了解更多:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">docker <span class="token keyword">exec</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">help</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入命令后发现我们前面的标识也变了，相当于进入了一个新的电脑。</p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220404212223139.png" alt="image-20220404212223139"></p><p>可以查询一下nginx在什么位置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">which</span> nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        打开ps查看一下当前运行的进程。我这里提示没有ps命令。我从网上查了一下发现是因为当前系统没有安装这个命令，然后我安装了一下。从命令可以看出，这个nginx容器附带的系统应该是ubuntu不是centos。</p><p>安装ps命令:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">apt<span class="token operator">-</span>get <span class="token keyword">update</span>apt<span class="token operator">-</span>get install procps<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        利用ps命令查看进程，可以发现nginx已经在运行了。</p><pre class="line-numbers language-undefined" data-language="undefined"><code class="language-undefined">ps -ef<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220404212251383.png" alt="image-20220404212251383"></p><p>​        输入 exit即可退出返回原来的系统。 </p><h2 id="6-2-docker网络"><a href="#6-2-docker网络" class="headerlink" title="6.2 docker网络"></a>6.2 docker网络</h2><h3 id="6-2-1-网络介绍"><a href="#6-2-1-网络介绍" class="headerlink" title="6.2.1 网络介绍"></a>6.2.1 网络介绍</h3><p>​        上面我们只运行了nginx，并没有用浏览器进行访问，这里我们尝试用浏览器访问，但是之前我们要了解一下docker网络。</p><p>​        我们直到docker的隔离性，网络也是个隔离性的一部分，linux使用了命名空间来进行资源的隔离，比如pid namespace就是用来隔离进程的，mount namespace是用来隔离文件系统的，<code>network namespace</code> 是用来隔离网络的。每一个<code>network namespace</code>都提供了一个独立的网络环境，包括网卡路由iptable规则等等，都是与以其它的network space隔离的。</p><ol><li>docker容器在默认情况下，一般会分配一个独立的<code>network-namespace</code>，也就是网络类型中的Bridge模式。</li></ol><p>​        在使用Bridge时就涉及到了一个问题，既然它有独立的namesapce，这就需要一种技术使容器内的端口可以在主机上访问到，这种技术就是端口映射，docker可以指定你想把容器内的某一个端口可以在容器所在主机上的某一个端口它俩之间做一个映射，当你在访问主机上的端口时，其实就是访问容器里面的端口。</p><ol start="2"><li><p>还有一种类型是Host模式，如果在启动容器的时候指定使用Host模式，那么这个容器将不会获得一个独立的network namespace，而是和主机共同使用一个，这个时候容器将不会虚拟出自己的网卡，配置出自己的ip。而是使用宿主机上的ip和端口。也就是说在docker上使用网络和在主机上使用网络是一样的。</p></li><li><p>还有一种网络类型是None。也就是没有网络，这种情况docker将不会和外界的任何东西进行通讯。</p></li></ol><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/docker%E7%BD%91%E7%BB%9C.png" alt="image-20220404212311135"></p><h3 id="6-2-2-实际访问端口"><a href="#6-2-2-实际访问端口" class="headerlink" title="6.2.2 实际访问端口"></a>6.2.2 实际访问端口</h3><p>​        刚才我们在运行nginx镜像的时候并没有指定端口映射，所以我们这里停掉nginx容器。</p><pre class="line-numbers language-vbnet" data-language="vbnet"><code class="language-vbnet">docker <span class="token keyword">stop</span> containerId<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220404212327583.png" alt="image-20220404212327583"></p><ol><li><code>-p</code>(小写)是开放一个容器的端口到主机上</li></ol><p>在后台运行，开放主机8080端口映射到容器的80端口上。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">docker run -d -p 8080<span class="token punctuation">:</span>80 hub.c.163.com/library/nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看主机8080端口是否开启</p><pre class="line-numbers language-perl" data-language="perl"><code class="language-perl">netstat <span class="token operator">-</span>na <span class="token operator">|</span>grep <span class="token number">8080</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> <img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220404212340444.png" alt="image-20220404212340444"></p><p>是开启的那么访问 主机ip:8080 即可访问到nginx。</p><ol start="2"><li><code>-P</code>(大写)是开放容器所有的端口到主机上一个随机的端口。</li></ol><p>停掉刚才的docker服务。</p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220404212356259.png" alt="image-20220404212356259"></p><p>使用大P</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">docker run -d -P hub.c.163.com/library/nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到随机给我的端口是32768 </p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220404212411693.png" alt="image-20220404212411693"></p><p>然后用 ip:32768去访问即可访问到nginx。 </p><h1 id="第七章-docker部署第一个java-web应用"><a href="#第七章-docker部署第一个java-web应用" class="headerlink" title="第七章 docker部署第一个java web应用"></a>第七章 docker部署第一个java web应用</h1><p>​        我们还需要学习Dockerfile，它告诉docker我们怎样制作我们的镜像，我们镜像的每一步操作分别是什么，写好Dockerfile后我们使用docker build命令执行Dockerfile里面的每一件事情。最终会把Dockerfile构建出来。</p><p>在这里因为是做一个演示，所以我们使用了一个开源的java web应用Jpress。</p><h2 id="7-1-制作自己的镜像"><a href="#7-1-制作自己的镜像" class="headerlink" title="7.1 制作自己的镜像"></a>7.1 制作自己的镜像</h2><ol><li>从网易的镜像中心找一个tomcat的镜像</li></ol><p><code>docker pull hub.c.163.com/library/tomcat:latest</code></p><p>​        因为tomat镜像肯定有jdk，所以我们就不用单独再装jdk了。</p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220404212425173.png" alt="image-20220404212425173"></p><img src="/2022/04/04/ctf-xue-xi/yi-ji-chu-zhi-shi/docker/docker-shi-yong-jian-jie/image-20220405093609418.png" alt="image-20220405093609418" style="zoom:80%;"><p>2.编写dockerfile</p><p>​        我们需要建立一个dockerfile告诉docker需要做什么，这里我建立了Dockerfile，并将我们的web文件放到了和它同一个目录下。</p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220404212437165.png" alt="image-20220404212437165"></p><p>​        首先我们的镜像是要运行在tomcat中的，所以填写 from tomcat，以tomcat为基础。maintainer是所有者的意思。因为war包是要放在webapps中的，所以我们使用copy命令复制到tomcat的webapps。</p><p>​        为什么webapps在local中?我们可以去下载镜像的网站查询，向下拉就好了。具体网址 : <a href="https://c.163yun.com/hub#/m/repository/?repoId=2955">https://c.163yun.com/hub#/m/repository/?repoId=2955</a></p><p>​        这里说一个个人猜想，每个容器都包含一个自己的系统，所以这里的/usr/local/tomcat/webapps指的是tomcat容器中的位置，那么哪里指定是tomcat容器呢?就是在一开始的from指定的。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">from</span> hub<span class="token punctuation">.</span>c<span class="token punctuation">.</span><span class="token number">163.</span>com<span class="token operator">/</span>library<span class="token operator">/</span>tomcatmaintainer zhangchen <span class="token number">61037</span><span class="token variable">@qq.com</span>COPY jpress<span class="token punctuation">.</span>war <span class="token operator">/</span>usr<span class="token operator">/</span><span class="token keyword">local</span><span class="token operator">/</span>tomcat<span class="token operator">/</span>webapps<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>3。构建容器</p><p>注意这里是<strong>有个点</strong>的，点标明是在根据当前目录构建</p><pre class="line-numbers language-erlang" data-language="erlang"><code class="language-erlang"><span class="token atom">docker</span> <span class="token atom">build</span> <span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220404212453512.png" alt="image-20220404212453512"></p><p>可以使用docker images查看镜像是否build成功</p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220404212503339.png" alt="image-20220404212503339"></p><p>发现一个none，表明构建成功了。</p><p>可以重新构建给它起个名字<code> -t</code>是给镜像指定一个tag</p><pre class="line-numbers language-erlang" data-language="erlang"><code class="language-erlang"><span class="token atom">docker</span> <span class="token atom">build</span> <span class="token operator">-</span><span class="token atom">t</span> <span class="token atom">jpress</span><span class="token punctuation">:</span><span class="token atom">latest</span> <span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220404212522439.png" alt="image-20220404212522439"></p><p>更多的参数查询:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">docker build <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">help</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="7-2-运行自己的镜像"><a href="#7-2-运行自己的镜像" class="headerlink" title="7.2 运行自己的镜像"></a>7.2 运行自己的镜像</h2><p>​        运行我们制作的镜像并指定端口</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">docker run -d -p  8080<span class="token punctuation">:</span>8080 jpress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        访问我们的网站，发现网站已经可以正常访问了。</p><p>​        然后发现它要求我们安装自己的数据库，所以我们利用docker安装mysql。</p><p>​        在镜像中心搜索并拉取mysql</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull hub.c.163.com/library/mysql:latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        在镜像中心查看配置，并配置root用户密码</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">docker run -d -p 3306<span class="token punctuation">:</span>3306 -e MYSQL_ROOT_PASSWORD=123456 hub.c.163.com/library/mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​         发现我们没有创建数据库，于是停止这个容器的运行，并在与剧中创建jpress数据库。</p><pre class="line-numbers language-vbnet" data-language="vbnet"><code class="language-vbnet">docker <span class="token keyword">stop</span> <span class="token number">4</span>be94fb2df1d3a28c1ocker <span class="token keyword">run</span> <span class="token operator">-</span>d <span class="token operator">-</span>p <span class="token number">3306</span><span class="token punctuation">:</span><span class="token number">3306</span> <span class="token operator">-</span>e MYSQL_ROOT_PASSWORD<span class="token operator">=</span><span class="token number">123456</span> <span class="token operator">-</span>e MYSQL_DATABASE<span class="token operator">=</span>jpress hub.c.<span class="token number">163.</span><span class="token keyword">com</span><span class="token operator">/</span>library<span class="token operator">/</span>mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        这样我们的数据库就建立成功了。</p><p>​        进入网站后要输入网站信息，输入数据库地址时，注意不要输入localhost，因为我们jpress是运行在容器内的，我们会访问tomcat容器内的3306，我们应该用ifconfig查询我们本机的ip地址。我这里的内网ip是172.17.10.68</p><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220404212540777.png" alt="image-20220404212540777"></p><p><img src="/2022/04/04/ctf-xue-xi/yi-ji-chu-zhi-shi/docker/docker-shi-yong-jian-jie/image-20220404212553619.png" alt="image-20220404212553619"></p><p>以上都做完后，我们的网站就可以跑起来了。</p><p><a href="http://59.110.164.62:8080/jpress/">http://59.110.164.62:8080/jpress/</a></p><h1 id="第八章-在容器中部署静态网站"><a href="#第八章-在容器中部署静态网站" class="headerlink" title="第八章 在容器中部署静态网站"></a>第八章 在容器中部署静态网站</h1><h2 id="8-1-容器的端口映射"><a href="#8-1-容器的端口映射" class="headerlink" title="8.1 容器的端口映射"></a>8.1 容器的端口映射</h2><p><strong>命令</strong>：<em>run [-P] [-p]</em></p><p>-P，–publish-all=true | false，大写的P表示为容器暴露的所有端口进行映射；</p><p>-p，–publish=[]，小写的p表示为容器指定的端口进行映射，有四种形式：</p><ul><li><em>containerPort</em>：只指定容器的端口，宿主机端口随机映射；</li><li><em>hostPort:containerPort</em>：同时指定容器与宿主机端口一一映射；</li><li><em>ip::containerPort</em>：指定ip和容器的端口；</li><li><em>ip:hostPort:containerPort</em>：指定ip、宿主机端口以及容器端口。</li></ul><p>例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -p <span class="token number">80</span> -i -t ubuntu /bin/bash<span class="token function">docker</span> run -p <span class="token number">8080</span>:80 -i -t ubuntu /bin/bash<span class="token function">docker</span> run -p <span class="token number">0.0</span>.0.0::80 -i -t ubuntu /bin/bash<span class="token function">docker</span> run -p <span class="token number">0.0</span>.0.0:8080:80 -i -t ubuntu /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-2-容器中部署Nginx服务"><a href="#8-2-容器中部署Nginx服务" class="headerlink" title="8.2 容器中部署Nginx服务"></a>8.2 容器中部署Nginx服务</h2><p>准备环境：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 1. 创建映射80端口的交互式容器</span><span class="token function">docker</span> run -p <span class="token number">80</span> --name web -i -t ubuntu /bin/bash<span class="token comment"># 2. 更新源</span><span class="token function">apt-get</span> update<span class="token comment"># 3. 安装Nginx</span><span class="token function">apt-get</span> <span class="token function">install</span> -y nginx<span class="token comment"># 4. 安装Vim</span><span class="token function">apt-get</span> <span class="token function">install</span> -y vim12345678<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建静态页面：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p /var/www/html<span class="token builtin class-name">cd</span> /var/www/html<span class="token function">vim</span> index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220405084338338.png" alt="image-20220405084338338" style="zoom:67%;"><p>修改Nginx配置文件:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看Nginx安装位置</span><span class="token function">whereis</span> nginx<span class="token comment"># 修改配置文件</span><span class="token function">vim</span> /etc/nginx/sites-enabled/default<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220405084432550.png" alt="image-20220405084432550" style="zoom:67%;"><p>运行Nginx:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 启动nginx</span>nginx<span class="token comment"># 查看进程</span><span class="token function">ps</span> -ef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220405084507071.png" alt="image-20220405084507071"></p><p>验证网站访问：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 退出容器</span>Ctrl+P Ctrl+Q<span class="token comment"># 查看容器进程</span><span class="token function">docker</span> <span class="token function">top</span> web<span class="token comment"># 查看容器端口映射情况</span><span class="token function">docker</span> port web<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220405084526325.png" alt="image-20220405084526325"></p><p>通过宿主机地址加映射端口访问：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">127.0.0.1<span class="token punctuation">:</span>32769<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="第九章-使用Docker搭建前端java开发环境"><a href="#第九章-使用Docker搭建前端java开发环境" class="headerlink" title="第九章 使用Docker搭建前端java开发环境"></a>第九章 使用Docker搭建前端java开发环境</h1><h2 id="9-1-搭建环境"><a href="#9-1-搭建环境" class="headerlink" title="9.1 搭建环境"></a>9.1 搭建环境</h2><p>​        下载和安装好docker之后我们就可以开始了，我们下面讲的都是java，不过其他环境同理。</p><h3 id="获取-Ubuntu-镜像。"><a href="#获取-Ubuntu-镜像。" class="headerlink" title="获取 Ubuntu 镜像。"></a>获取 Ubuntu 镜像。</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull ubuntu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        完成后执行 docker images 就能看到一个刚刚更新的镜像了。</p><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -it ubuntu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="安装软件、配置环境变量"><a href="#安装软件、配置环境变量" class="headerlink" title="安装软件、配置环境变量"></a>安装软件、配置环境变量</h3><p>首先更新apt-get</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt-get</span> update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        接下来就可以使用 **apt-get install ** 安装你需要的软件了，如果没有就下载安装包自行安装，同时配置好环境变量，这里就不赘述了。</p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>​        进入tomcat目录，启动服务，在浏览器打开 0.0.0.0:8080, 如果没有错的话你会看到该服务器无法访问。这是因为我们刚才启动的服务是在docker内，如果不做一些操作的话我们是无法访问到docker内部的服务的。</p><p>所以，我们先退出容器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">exit</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        退出之后执行 docker ps -a，就能看到我们刚才的容器依然还在，可能大多刚接触docker的人都会犯这个错误，以为退出容器之后容器就销毁了，其实不然。</p><p>如果我们想再进入这个容器可以执行下面的命令，容器ID请复制自己的。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it 容器ID <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        虽然容器还在运行，但是他并没有持久化，为了防止万一，在我们修改容器里面的内容之后尽快持久化。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> commit 容器ID java<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这个命令的意思是将我们容器持久化为一个新的镜像，名字叫java。</p><p>​        启动这个新建的镜像。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -it -p <span class="token number">8080</span>:8080 java<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        注意看我们的启动命令发生了变化，多了一个 -P 这个命令的意思是将容器内的 8080 端口暴漏到宿主机上。</p><p>​        再次访问 0.0.0.0:8080，我们就能看到那只小花猫了，真可爱。</p><p>​        刚才那个容器还在占用我们的内存怎么办，干掉他。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">rm</span> 容器ID<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        至此我们的第一步已经完成了，接下来我们就要集成我们的代码了。</p><h2 id="9-2-集成代码"><a href="#9-2-集成代码" class="headerlink" title="9.2 集成代码"></a>9.2 集成代码</h2><p>​        我们刚才启动的容器是一个完全的独立的黑盒子，它根本不知道我们的代码再哪里，所以我们就要使用docker的挂载卷让宿主机和容器可以共享目录。</p><p>不好意思，我们又要干掉刚才启动的那个容器了。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -it -v /Users/name/web:/opt/root -p <span class="token number">8080</span>:8080 java<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我们的启动命令又加入了新成员 -v。这个命令的意思就是将用户根目录下的 web 目录挂在到容器中 /opt/root 目录下。</p><p>​        进入目录后我们就能发现web目录下的文件静静的躺在里面，像是沉睡多年的玛丽苏在等待你的呼唤。</p><p>​        开始呼唤吧。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mvn clean <span class="token function">install</span> -U -Plocal -DskipTests<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        一段时间过后我们就会看到打包成功的提示，将war包copy到 tomcat webapps 目录下，就能访问你的项目了。</p><p>​        至此我们的项目终于跑起来了，但是有几个问题。</p><p>​        每次都要跑这么长的命令？好麻烦。</p><p>​        每次改代码都要重新打包，时间很长。</p><p>​        启动日志怎么看？报错了怎么办？</p><p>​        怎么修改前端模板文件不需要重启服务？</p><p>​        基于这些问题，我们就需要写一个脚本来解决了。</p><h2 id="9-3-shell脚本"><a href="#9-3-shell脚本" class="headerlink" title="9.3 shell脚本"></a>9.3 shell脚本</h2><p>脚本将提供下面几个指令</p><ul><li><p>-y 更新maven包-编译-打包-发布-启动tomcat</p></li><li><p>-p 编译-打包-发布-启动tomcat</p></li><li><p>-r 重启tomcat</p></li><li><p>-c 重新编译java文件-发布-启动tomcat</p></li><li><p>-w 监听vm文件,默认5S同步一次</p></li><li><p>-l 查看tomcat日志</p></li><li><p>-h 帮助</p></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 需要变动的变量</span><span class="token comment">#################################################################</span><span class="token comment"># 环境变量,根据conf目录下选择</span><span class="token assign-left variable">DEV</span><span class="token operator">=</span><span class="token string">"local"</span><span class="token comment">#################################################################</span><span class="token comment"># 不需要改动的变量</span><span class="token comment"># war包地址</span><span class="token assign-left variable">WAR_URL</span><span class="token operator">=</span><span class="token string">"/opt/root/target/*.war"</span><span class="token comment"># tomcat 地址</span><span class="token assign-left variable">TOM_URL</span><span class="token operator">=</span><span class="token string">"/usr/share/tomcat7"</span><span class="token comment"># 项目启动地址</span><span class="token assign-left variable">TOM_ROOT</span><span class="token operator">=</span><span class="token string">"<span class="token variable">${TOM_URL}</span>/webapps"</span><span class="token comment"># 文件监听间隔，单位秒</span><span class="token assign-left variable">WT</span><span class="token operator">=</span><span class="token number">5</span><span class="token comment"># 拷贝 vm</span><span class="token assign-left variable">WC_VM</span><span class="token operator">=</span><span class="token string">"src/main/webapp/WEB-INF/tpl /usr/share/tomcat7/webapps/ROOT/WEB-INF/"</span><span class="token comment"># 拷贝class</span><span class="token assign-left variable">WC_JAVA</span><span class="token operator">=</span><span class="token string">"target/classes /usr/share/tomcat7/webapps/ROOT/WEB-INF/"</span><span class="token comment"># 通用方法</span><span class="token comment"># </span><span class="token comment"># 使用新包</span><span class="token keyword">function</span> <span class="token function-name function">newwar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment"># 删除旧包</span>    <span class="token function">rm</span> -rf <span class="token variable">${TOM_ROOT}</span>/*    <span class="token comment"># 移动war包</span>    <span class="token function">mv</span> <span class="token variable">${WAR_URL}</span> <span class="token variable">${TOM_ROOT}</span>/ROOT.war<span class="token punctuation">}</span><span class="token comment"># 重启tomcat</span><span class="token keyword">function</span> <span class="token function-name function">restart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment"># 关闭已启动程序</span>    <span class="token function">killall</span> -9 java    <span class="token comment"># 启动服务</span>    <span class="token variable">${TOM_URL}</span>/bin/startup.sh    <span class="token comment"># 输入启动日志</span>    <span class="token function">tail</span> -f <span class="token variable">${TOM_URL}</span>/logs/catalina.out<span class="token punctuation">}</span><span class="token comment"># 指令处理</span><span class="token keyword">while</span> <span class="token builtin class-name">getopts</span> <span class="token string">":yprcwlh"</span> optname<span class="token keyword">do</span>    <span class="token keyword">case</span> <span class="token string">"<span class="token variable">$optname</span>"</span> <span class="token keyword">in</span>    <span class="token string">"y"</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">"更新jar包"</span>        mvn clean <span class="token function">install</span> -U -P<span class="token variable">${DEV}</span> -DskipTests        newwar        restart        <span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token string">"p"</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">"重新打包"</span>        mvn clean package -P<span class="token variable">${DEV}</span> -DskipTests        newwar        restart        <span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token string">"r"</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">"重启tomcat"</span>        restart        <span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token string">"c"</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">"重新编译并重启服务"</span>        mvn clean compile -P<span class="token variable">${DEV}</span> -DskipTests        <span class="token function">cp</span> -R <span class="token variable">${WC_JAVA}</span>        restart        <span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token string">"w"</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">"开始监听vm文件"</span>        <span class="token comment"># 监听 VM</span>        <span class="token function">watch</span> -n <span class="token variable">${WT}</span> <span class="token function">cp</span> -R <span class="token variable">${WC_VM}</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token string">"l"</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">"日志"</span>        <span class="token comment"># 监听 VM</span>        <span class="token function">tail</span> -f <span class="token variable">${TOM_URL}</span>/logs/catalina.out        <span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token string">"h"</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">" -y 更新maven包-编译-打包-发布-启动一条龙服务"</span>        <span class="token builtin class-name">echo</span> <span class="token string">" -p 编译打包发布启动一条龙服务"</span>        <span class="token builtin class-name">echo</span> <span class="token string">" -r 重启tomcat"</span>        <span class="token builtin class-name">echo</span> <span class="token string">" -c 重新java文件并部署重启服务"</span>        <span class="token builtin class-name">echo</span> <span class="token string">" -w 监听vm文件,默认5S同步一次"</span>        <span class="token builtin class-name">echo</span> <span class="token string">" -l 查看日志"</span>        <span class="token builtin class-name">echo</span> <span class="token string">" -h 帮助"</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token keyword">esac</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-4-推广到团队"><a href="#9-4-推广到团队" class="headerlink" title="9.4 推广到团队"></a>9.4 推广到团队</h2><p>​        经过上面三步，我们的工具已经建好了，但是怎么让其他人也能使用起来呢？</p><p>​        docker 提供了云服务，如果我们的镜像足够小就可以将镜像推送到云上供团队其他人下载运行，但是我们的镜像已经超过了1G。。。所以我们就不能使用这种方式了。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> save java -o ./java.tar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        使用上面的命令可以将镜像持久化到本地文件 java.tar，然后通过其他手段进行传输到其他同学的机器上，我们使用AirDrop，几分钟的事情。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> load -i java.tar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        其他同学可以通过这个命令将我们的镜像加载到他的docker中。</p><p>​        再将shell脚本集成到项目根目录中，就可以愉快的使用了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
