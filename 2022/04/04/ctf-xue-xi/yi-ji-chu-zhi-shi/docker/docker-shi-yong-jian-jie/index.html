<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Docker使用简介, Shuyan">
    <meta name="description" content="​        
第一章 Docker简介1.1 Docker的发展史​        2010年几个年轻人成立了一个做PAAS平台的公司dotCloud。起初公司发展的不错，不但拿到过一些融资，还获得了美国著名孵化器YCombinato">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Docker使用简介 | Shuyan</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    
    <style>
        body{
            background-image: url(https://cdn.jsdelivr.net/gh/Tokisaki-Galaxy/res/site/medias/background.jpg);
            background-repeat:no-repeat;
            background-size: 100% 100%;
            background-attachment:fixed;
        }
    </style>



    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Shuyan" type="application/atom+xml">

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Shuyan</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Shuyan</div>
        <div class="logo-desc">
            
            ShuyanCoding......
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/shuyanCoding/shuyanCoding.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/shuyanCoding/shuyanCoding.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/12.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Docker使用简介</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Linux/">
                                <span class="chip bg-color">Linux</span>
                            </a>
                        
                            <a href="/tags/Docker/">
                                <span class="chip bg-color">Docker</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Linux/" class="post-category">
                                Linux
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-04-04
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>​        </p>
<h1 id="第一章-Docker简介"><a href="#第一章-Docker简介" class="headerlink" title="第一章 Docker简介"></a>第一章 Docker简介</h1><h2 id="1-1-Docker的发展史"><a href="#1-1-Docker的发展史" class="headerlink" title="1.1 Docker的发展史"></a>1.1 Docker的发展史</h2><p>​        2010年几个年轻人成立了一个做PAAS平台的公司dotCloud。起初公司发展的不错，不但拿到过一些融资，还获得了美国著名孵化器YCombinator的支持，后来微软谷歌亚马逊这样的大厂商也纷纷加入PAAS平台，竞争十分激烈，dotCloud举步维艰。</p>
<p>​        2013年可能是公司发展的不是很好，工程师又不想自己的努力付之东流，于是他们决定将他们的核心技术开源。这项技术就是docker。当时docker的功能就是将linux容器中的应用代码打包，可以轻松的在服务器之间进行迁移。</p>
<p>​        无心插柳柳成荫，docker技术风靡全球，于是dotCloud公司改名为docker Inc，并全面投入到docker的开发之中。</p>
<ul>
<li><p>2014。6 Docker发布了第一个版本 Docker1。0</p>
</li>
<li><p>2014。7 获得C轮融资 $4000W</p>
</li>
<li><p>2015。4 获得D轮融资 $9500W</p>
</li>
<li><p>至今已经发布到docker </p>
</li>
</ul>
<h2 id="1-2-什么是Docker"><a href="#1-2-什么是Docker" class="headerlink" title="1.2 什么是Docker"></a>1.2 什么是Docker</h2><p>​        docker是一个用来装应用的容器，就像杯子可以装水，笔筒可以放笔，书包可以放书，可以把hello word放在docker中，可以把网站放入docker中，可以把任何想得到的程序放在docker中。</p>
<p>​        我们在理解 <code>docker</code> 之前，首先我们得先区分清楚两个概念，<strong>容器</strong>和<strong>虚拟机</strong>。</p>
<p>​        我们用的传统虚拟机如 <code>VMware</code> ， <code>VisualBox</code> 之类的需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。每一台虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。</p>
<p>​        而容器技术是和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。</p>
<p>​        容器技术是实现操作系统虚拟化的一种途径，可以让您在资源受到隔离的进程中运行应用程序及其依赖关系。通过使用容器，我们可以轻松打包应用程序的代码、配置和依赖关系，将其变成容易使用的构建块，从而实现环境一致性、运营效率、开发人员生产力和版本控制等诸多目标。容器可以帮助保证应用程序快速、可靠、一致地部署，其间不受部署环境的影响。容器还赋予我们对资源更多的精细化控制能力，让我们的基础设施效率更高。通过下面这幅图我们可以很直观的反映出这两者的区别所在。</p>
<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.png"></p>
<p>​        <strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 <code>Linux</code> 容器解决方案。</p>
<p>​        而 <code>Linux</code> 容器是 <code>Linux</code> 发展出了另一种虚拟化技术，简单来讲， <code>Linux</code> 容器不是模拟一个完整的操作系统，而是对进程进行隔离，相当于是在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p>
<p>​        <code>Docker</code> 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 <code>Docker</code> ，就不用担心环境问题。</p>
<p>​        总体来说， <code>Docker</code> 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p>
<h2 id="1-3-Docker的优势"><a href="#1-3-Docker的优势" class="headerlink" title="1.3 Docker的优势"></a>1.3 Docker的优势</h2><p> <strong>Docker相比于传统虚拟化方式具有更多的优势：</strong></p>
<ul>
<li><code>docker</code> 启动快速属于秒级别。虚拟机通常需要几分钟去启动</li>
<li><code>docker</code> 需要的资源更少， <code>docker</code> 在操作系统级别进行虚拟化， <code>docker</code> 容器和内核交互，几乎没有性能损耗，性能优于通过 <code>Hypervisor</code> 层与内核层的虚拟化</li>
<li><code>docker</code> 更轻量， <code>docker</code> 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境， <code>Docker</code> 运行的镜像数远多于虚拟机数量，对系统的利用率非常高</li>
<li>与虚拟机相比， <code>docker</code> 隔离性更弱， <code>docker</code> 属于进程之间的隔离，虚拟机可实现系统级别隔离</li>
<li>安全性： <code>docker</code> 的安全性也更弱。 <code>Docker</code> 的租户 <code>root</code> 和宿主机 <code>root</code> 等同，一旦容器内的用户从普通用户权限提升为root权限，它就直接具备了宿主机的root权限，进而可进行无限制的操作。虚拟机租户 <code>root</code> 权限和宿主机的 <code>root</code> 虚拟机权限是分离的，并且虚拟机利用如 <code>Intel</code> 的 <code>VT-d</code> 和 <code>VT-x</code> 的 <code>ring-1</code> 硬件隔离技术，这种隔离技术可以防止虚拟机突破和彼此交互，而容器至今还没有任何形式的硬件隔离，这使得容器容易受到攻击</li>
<li>可管理性： <code>docker</code> 的集中化管理工具还不算成熟。各种虚拟化技术都有成熟的管理工具，例如 <code>VMware vCenter</code> 提供完备的虚拟机管理能力</li>
<li>高可用和可恢复性： <code>docker</code> 对业务的高可用支持是通过快速重新部署实现的。虚拟化具备负载均衡，高可用，容错，迁移和数据保护等经过生产实践检验的成熟保障机制， <code>VMware</code> 可承诺虚拟机 <code>99。999%</code> 高可用，保证业务连续性</li>
<li>快速创建、删除：虚拟化创建是分钟级别的， <code>Docker</code> 容器创建是秒级别的， <code>Docker</code> 的快速迭代性，决定了无论是开发、测试、部署都可以节约大量时间</li>
<li>交付、部署：虚拟机可以通过镜像实现环境交付的一致性，但镜像分发无法体系化。 <code>Docker</code> 在 <code>Dockerfile</code> 中记录了容器构建过程，可在集群中实现快速分发和快速部署</li>
</ul>
<p>我们可以从下面这张表格很清楚地看到容器相比于传统虚拟机的特性的优势所在：</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">容器</th>
<th align="left">虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td align="left">启动</td>
<td align="left">秒级</td>
<td align="left">分钟级</td>
</tr>
<tr>
<td align="left">硬盘使用</td>
<td align="left">一般为MB</td>
<td align="left">一般为GB</td>
</tr>
<tr>
<td align="left">性能</td>
<td align="left">接近原生</td>
<td align="left">弱于</td>
</tr>
<tr>
<td align="left">系统支持量</td>
<td align="left">单机支持上千个容器</td>
<td align="left">一般是几十个</td>
</tr>
</tbody></table>
<h1 id="第二章-了解docker"><a href="#第二章-了解docker" class="headerlink" title="第二章 了解docker"></a>第二章 了解docker</h1><h2 id="2-1-docker思想"><a href="#2-1-docker思想" class="headerlink" title="2.1 docker思想"></a>2.1 docker思想</h2><h3 id="2-1-1-集装箱"><a href="#2-1-1-集装箱" class="headerlink" title="2.1.1 集装箱"></a>2.1.1 集装箱</h3><p>​        没有集装箱之前运输货物，东西零散容易丢失，有了集装箱之后货物不容易丢失，我们可以把货物想象成程序，目前我们要把程序部署到一台新的机器上，可能会启动不起来，比如少一些配置文件什么的或者少了什么数据，有了docker的集装箱可以保证我们的程序不管运行在哪不会缺东西。</p>
<h3 id="2-1-2-标准化"><a href="#2-1-2-标准化" class="headerlink" title="2.1.2 标准化"></a>2.1.2 标准化</h3><ol>
<li><strong>运输方式</strong></li>
</ol>
<p>​        docker运输东西有一个超级码头，任何地方需要货物都由鲸鱼先送到超级码头，然后再由鲸鱼从超级码头把货物送到目的地去。对应的技术来说，比如我们要把台式机的应用部署到笔记本上，我们可能选择用QQ发过去或者用U盘拷过去，docker就标准化了这个过程，我们只需在台式机上执行一个docker命令，把鲸鱼派过来，把程序送到超级码头去，再在笔记本上执行一个docker命令，然后由鲸鱼把程序从超级码头送到笔记本上去。</p>
<ol start="2">
<li><strong>存储方式</strong></li>
</ol>
<p>​        当我们把程序存储到笔记本上时，我们需要一个目录，且我们要记住这个目录，因为下次我们可能还要修改，有了docker之后我们就不用记住了程序在哪里了，我们使用的时候只需要一条命令就行了。</p>
<ol start="3">
<li><strong>API接口</strong></li>
</ol>
<p>​        docker提供了一系列rest api的接口，包含了对docker也就是对我们的应用的一个启动停止查看删除等等，如当我们要启动tomcat时我们要执行startup命令，当我们要停止时要执行shutdown命令，如果不是tomcat，我们可能还需要一些别的命令。有了docker我们记docker的命令就可以对其进行操作。</p>
<h3 id="2-1-3-隔离"><a href="#2-1-3-隔离" class="headerlink" title="2.1.3 隔离"></a>2.1.3 隔离</h3><p>​        我们在使用虚拟机时有自己的cpu，硬盘，内存，完全感觉不到外面主机的存在，docker也差不多，不过它更轻量，我们创建虚拟机可能要几分钟，但是docker只需要一秒。最底层的技术时linux一种内核的限制机制，叫做LXC，LXC是一种轻量级的容器虚拟化技术。最大效率的隔离了进程和资源。通过cgroup，namespace等限制，隔离进程组所使用的物理资源，比如CPU，MEMORY等等，这个机制在7，8年前已经加入到linux内核了，直到2013年docker出世的时候才火起来，大家可能奇怪为什么这么好的技术埋没这么多年都没人发现呢?英雄造时势，时势造英雄，如果没有云计算，敏捷开发，高频度的弹性伸缩需求，没有IT行业这么多年长足的发展，也就没有docker。</p>
<h2 id="2-2-docker解决的问题"><a href="#2-2-docker解决的问题" class="headerlink" title="2.2 docker解决的问题"></a>2.2 docker解决的问题</h2><h3 id="2-2-1-系统环境不一致"><a href="#2-2-1-系统环境不一致" class="headerlink" title="2.2.1 系统环境不一致"></a>2.2.1 系统环境不一致</h3><p>​        开发:我本地没问题。运维:服务器没问题。 这个问题就变成了皮球。</p>
<p>​        如果一个应用要正常的启动起来需要什么?比如java web应用。</p>
<p>​        需要一个操作系统，操作系统之上要jdk，tomcat，我们的代码，配置文件。</p>
<p>​        操作系统的改变可能会导致我们的应用开不起来，比如我们调用了某些系统命令。</p>
<p>​        jdk版本也可能导致程序的运行失败。比如class文件需要1。7编译，我们装了个1。6的jdk。</p>
<p>​        tomcat版本也能导致失败，比如旧的版本一些配置在新版本中不再支持。</p>
<p>​        代码的话就比如应用了C盘，D盘的一个文件，或者是用了系统的一些环境编码。</p>
<p>​        配置的话我们可能少了某个配置文件等等。</p>
<p>​        下面docker来了，它把操作系统，jdk，tomcat，代码，配置全部放到集装箱里。再打包放到鲸鱼上，由鲸鱼给我们送到服务器上，在我的机器上怎么运行，在别的机器上也怎么运行。不会有任何的问题。一句话就是docker解决了运行环境不一致所带来的问题。</p>
<h3 id="2-2-2-系统好卡，哪个哥们又写死循环了"><a href="#2-2-2-系统好卡，哪个哥们又写死循环了" class="headerlink" title="2.2.2 系统好卡，哪个哥们又写死循环了"></a>2.2.2 系统好卡，哪个哥们又写死循环了</h3><p>​        如果有根别人共用服务器的同学可能有这样的体会，莫名其妙发现自己的程序挂了，一查原因要不是内存不够了，要不是硬盘满了，还有就是发现某个服务变慢了，甚至敲终端都比较卡，但是linux本身就是一个多用户的操作系统本身就可以供多个用户使用，docker的隔离性可以解决这个问题，就算别人的程序还是死循环疯狂吃CPU，还是封装疯狂打日志把硬盘占满，还是内存泄漏，把内存占满，都不会导致我们的程序运行错误。因为docker在启动的时候就限定好了，它最大使用的CPU硬盘，如果超过了，就会杀掉对应进程。</p>
<h3 id="2-2-3-双11来了，服务器撑不住了"><a href="#2-2-3-双11来了，服务器撑不住了" class="headerlink" title="2.2.3 双11来了，服务器撑不住了"></a>2.2.3 双11来了，服务器撑不住了</h3><p>​        大部分系统业务量并不是每天都比较平均的，特别是一些电商系统，每天总有那么几天业务量是平时的几倍甚至几十倍，如果按双11的规模去准备服务器那么对于平时的规模来说又是极大的浪费，所以就在节日前临时扩展机器，过完节再把多余的节点下线，这就给运维带来了非常大的工作量，一到过节就在各个机器上部署各种各样的服务，我们启动程序需要java，tocmat等等，并且还可能起不来还要调试，这是非常恶心的工作，有了docker一切都变得美好了，只要点一下服务器就可以从10台变成100台甚至1000，1W台。都是分分钟的事情。</p>
<p>​        为什么会这么快呢？都是用标准的方式把我们的程序运过来，下载过来，再用标准的方式把它运行起来，就可以做到只要在每台机器上都执行一两条命令，就可以让程序正常跑起来，并且不用担心有问题。</p>
<h1 id="第三章-走进docker"><a href="#第三章-走进docker" class="headerlink" title="第三章 走进docker"></a>第三章 走进docker</h1><p>​        镜像就是上面说的集装箱，仓库就是超级码头，容器就是我们运行程序的地方。docker运行程序的过程就是去仓库把镜像拉到本地，然后用一条命令把镜像运行起来变成容器。</p>
<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/docker%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.png" alt="image-20220404213106368"></p>
<ul>
<li><p>build：构建，就是构建镜像。</p>
</li>
<li><p>ship：运输，运输镜像，从仓库和主机运输。</p>
</li>
<li><p>run：运行的镜像就是一个容器。</p>
</li>
</ul>
<p>build，ship，run和镜像，仓库，容器是一一对应的。</p>
<h2 id="3-1-镜像"><a href="#3-1-镜像" class="headerlink" title="3.1 镜像"></a>3.1 镜像</h2><p>​        镜像的英文名交image。前面我们讲到了集装箱，鲸鱼拖着的所有集装箱就是一个镜像。</p>
<p>​        从本质上来说镜像就是一系列文件，了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<p>​        镜像<code>（Image）</code>就是一堆只读层<code>（read-only layer）</code>的统一视角，也许这个定义有些难以理解，下面的这张图能够帮助读者理解镜像的定义。</p>
<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E9%95%9C%E5%83%8F%E5%AE%9A%E4%B9%89.png" alt="image-20220404213213857"></p>
<p>​        从左边我们看到了多个只读层，它们重叠在一起。除了最下面一层，其它层都会有一个指针指向下一层。这些层是<code>Docker</code> 内部的实现细节，并且能够在主机的文件系统上访问到。统一文件系统 <code>(union file system)</code> 技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。我们可以在图片的右边看到这个视角的形式。</p>
<p>​        既然Docker是文件，那么是以什么样的格式在本地保存的呢?</p>
<p>​        说到<strong>存储格式</strong>，就要提到linux的一个存储技术，叫做<strong>联合文件系统</strong>，是一种分层的文件系统，可以将不同的目录挂到同一个虚拟文件系统下。</p>
<p>​        比如test1下有三个文件夹，test2下有两个文件夹，还有一个readme文件。联合文件系统就是可以在一个文件夹(test)中看到多个文件夹(test1，test2)中的内容。</p>
<p>​        通过这种方式可以实现文件的分层，test1可以把它看作第一层，test2可以把它看作第二层，每一层有每一层自己的文件，docker就是利用了这种分层的概念实现了镜像存储。</p>
<p>​        下图就是镜像的存储格式，这张图是分层的，最下面一层，上面也是一层层的好像集装箱罗列在一起。这就是镜像最直观的存储方式。下面是操作系统的引导，上面是linux操作系统，再上面是一些相关的软件，如果是我们自己的程序，就可以是tomcat，jdk，再往上是应用代码，每一层是我们自己都可以控制得，最上面一层先忽略不看，因为这是和容器有关的。注意一点，docker镜像系统的每一层都是只读的，然后把每一层加载完成之后这些文件都会被看成是同一个目录，相当于只有一个文件系统。docker的这种文件系统被称之为镜像。</p>
<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E9%95%9C%E5%83%8F%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F.png" alt="image-20220404212652771"></p>
<h2 id="3-2-容器"><a href="#3-2-容器" class="headerlink" title="3.2 容器"></a>3.2 容器</h2><p>​        容器 <code>(container)</code> 的定义和镜像 <code>(image)</code> 几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</p>
<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E5%AE%B9%E5%99%A8%E5%AE%9A%E4%B9%89.png" alt="image-20220404213243444"></p>
<p>​        由于容器的定义并没有提及是否要运行容器，所以实际上，容器 = 镜像 + 读写层。</p>
<p>​        为了便于理解，大家可以把容器想象成虚拟机，每个虚拟机都有自己的文件系统，可以把图1整个一部分看成是文件系统，与虚拟机系统的区别是这里面的文件系统是一层一层的，并且最下面的n层都是只读的，只有上面一层是可写的。为什么要有可写的这层呢?大家的程序运行起来，势必会要写一些日志，写一些文件，或者对系统的某一些文件做一些修改，所以容器在最上面一层创建了可读可写的文件系统。</p>
<p>​        在程序的运行过程中，如果要写镜像文件时，因为镜像的每一层都是只读的，它会把文件的每一层拷到文件的最上层，然后再对它进行修改，修改之后，当我们的应用读一个文件时会从顶层进行查找，如果没有才会找下一层。</p>
<p>​        由于容器的最上一层是可以修改的，镜像是不能修改的，这样就能保证镜像可以生成多个容器独立运行，没有任何干扰。</p>
<h2 id="3-3-仓库"><a href="#3-3-仓库" class="headerlink" title="3.3 仓库"></a>3.3 仓库</h2><p>​        我们的镜像是要在其它机器上运行，如何进行传输呢?</p>
<p>​        这就用到了docker仓库，我们要先把我们的镜像传到docker仓库中，再由目的地把docker仓库拉过去，这就完成了这样的一次传输过程。</p>
<p>​        谁提供了这样的仓库呢?docker自己提供了，hub。docker。com，但是非常慢，为了解决这个问题，国内很多公司也在做自己的仓库。比较知名的是由网易蜂巢提供的 <a target="_blank" rel="noopener" href="https://c.163yun.com/hub#/m/home/">https://c.163yun.com/hub#/m/home/</a></p>
<p>​         <code>Docker</code> 仓库是集中存放镜像文件的场所。镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<code>Docker Registry</code> (仓库注册服务器)就是这样的服务。有时候会把仓库 <code>(Repository)</code> 和仓库注册服务器 <code>(Registry)</code> 混为一谈，并不严格区分。<code>Docker</code> 仓库的概念跟 <code>Git</code> 类似，注册服务器可以理解为 <code>GitHub</code> 这样的托管服务。实际上，一个 <code>Docker Registry</code> 中可以包含多个仓库 <code>(Repository)</code> ，每个仓库可以包含多个标签 <code>(Tag)</code>，每个标签对应着一个镜像。所以说，镜像仓库是 <code>Docker</code> 用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。</p>
<p>​        通常，<strong>一个仓库会包含同一个软件不同版本的镜像</strong>，而<strong>标签就常用于对应该软件的各个版本</strong> 。我们可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签.。</p>
<p>仓库又可以分为两种形式：</p>
<ul>
<li><code>public</code>(公有仓库)</li>
<li><code>private</code>(私有仓库)</li>
</ul>
<p>​        <code>Docker Registry</code> 公有仓库是开放给用户使用、允许用户管理镜像的 <code>Registry</code> 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p>
<p>​        除了使用公开服务外，用户还可以在本地搭建私有 <code>Docker Registry</code> 。<code>Docker</code> 官方提供了 <code>Docker Registry</code>镜像，可以直接使用做为私有 <code>Registry</code> 服务。当用户创建了自己的镜像之后就可以使用 <code>push</code> 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 <code>pull</code> 下来就可以了。</p>
<p>​        我们主要把 <code>Docker</code> 的一些常见概念如 <code>Image</code> ， <code>Container</code> ， <code>Repository</code> 做了详细的阐述，也从传统虚拟化方式的角度阐述了 <code>docker</code> 的优势，我们从下图可以直观地看到 <code>Docker</code> 的架构：</p>
<img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/docker%E6%9E%B6%E6%9E%84.png" alt="image-20220404213553615" style="zoom:65%;">

<p>​        <code>Docker</code> 使用 <code>C/S</code> 结构，即<strong>客户端/服务器</strong>体系结构。 <code>Docker</code> 客户端与 <code>Docker</code> 服务器进行交互，Docker服务端负责构建、运行和分发 <code>Docker</code> 镜像。 <code>Docker</code> 客户端和服务端可以运行在一台机器上，也可以通过 <code>RESTful</code> 、 <code>stock</code> 或网络接口与远程 <code>Docker</code> 服务端进行通信。</p>
<img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/docker%E7%BB%93%E6%9E%84.png" alt="image-20220404212904989" style="zoom:67%;">



<p><code>Docker</code> 的核心组件包括：</p>
<ol>
<li><strong>Docker Client</strong></li>
<li><strong>Docker daemon</strong></li>
<li><strong>Docker Image</strong></li>
<li><strong>Docker Registry</strong></li>
<li><strong>Docker Container</strong></li>
</ol>
<p>​        这张图展示了 <code>Docker</code> 客户端、服务端和 <code>Docker</code> 仓库（即 <code>Docker Hub</code> 和 <code>Docker Cloud</code> ），默认情况下<code>Docker</code> 会在 <code>Docker</code> 中央仓库寻找镜像文件，这种利用仓库管理镜像的设计理念类似于 <code>Git</code> ，当然这个仓库是可以通过修改配置来指定的，甚至我们可以创建我们自己的私有仓库。</p>
<h1 id="第四章-docker安装"><a href="#第四章-docker安装" class="headerlink" title="第四章 docker安装"></a>第四章 docker安装</h1><h2 id="4-1-CentOS环境下"><a href="#4-1-CentOS环境下" class="headerlink" title="4.1 CentOS环境下"></a>4.1 CentOS环境下</h2><p>​        <code>Docker</code> 的安装和使用有一些前提条件，主要体现在体系架构和内核的支持上。对于体系架构，除了 <code>Docker</code> 一开始就支持的 <code>X86-64</code> ，其他体系架构的支持则一直在不断地完善和推进中。</p>
<p>​        <code>Docker</code> 分为 <code>CE</code> 和 <code>EE</code> 两大版本。 <code>CE</code> 即社区版（免费，支持周期 <code>7</code> 个月）， <code>EE</code> 即企业版，强调安全，付费使用，支持周期 <code>24</code> 个月。</p>
<p>​        我们在安装前可以参看官方文档获取最新的 <code>Docker</code> 支持情况，官方文档在这里：</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">https</span><span class="token punctuation">:</span>//docs.docker.com/install/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​        <code>Docker</code> 对于内核支持的功能，即内核的配置选项也有一定的要求(比如必须开启 <code>Cgroup</code> 和 <code>Namespace</code> 相关选项，以及其他的网络和存储驱动等)， <code>Docker</code> 源码中提供了一个检测脚本来检测和指导内核的配置，脚本链接在这里：</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">https</span><span class="token punctuation">:</span>//raw.githubusercontent.com/docker/docker/master/contrib/check-config.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在满足前提条件后，安装就变得非常的简单了。</p>
<p><code>Docker CE</code> 的安装请参考官方文档：</p>
<ul>
<li><code>MacOS</code>：<a target="_blank" rel="noopener" href="https://docs.docker.com/docker-for-mac/install/">https://docs.docker.com/docker-for-mac/install/</a></li>
<li><code>Windows</code>：<a target="_blank" rel="noopener" href="https://docs.docker.com/docker-for-windows/install/">https://docs.docker.com/docker-for-windows/install/</a></li>
<li><code>Ubuntu</code>：<a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">https://docs.docker.com/install/linux/docker-ce/ubuntu/</a></li>
<li><code>Debian</code>：<a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/debian/">https://docs.docker.com/install/linux/docker-ce/debian/</a></li>
<li><code>CentOS</code>：<a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/centos/">https://docs.docker.com/install/linux/docker-ce/centos/</a></li>
<li><code>Fedora</code>：<a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/fedora/">https://docs.docker.com/install/linux/docker-ce/fedora/</a></li>
<li>其他 <code>Linux</code> 发行版：<a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/binaries/">https://docs.docker.com/install/linux/docker-ce/binaries/</a></li>
</ul>
<ol>
<li>Docker 要求 CentOS 系统的内核版本高于 3.10，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。</li>
</ol>
<p>通过 <strong>uname -r</strong> 命令查看你当前的内核版本</p>
<ol start="2">
<li>如果安装过请先卸载</li>
</ol>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">yum</span> <span class="token attr-value">remove docker \
           docker-client \
           docker-client-latest \
           docker-common \
           docker-latest \
           docker-latest-logrotate \
           docker-logrotate \
           docker-engine</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="3">
<li>安装依赖设置yum仓库</li>
</ol>
<p>安装依赖:</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">yum</span> <span class="token attr-value">install -y yum-utils \
  device-mapper-persistent-data \
  lvm2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>设置仓库:</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">yum-config-manager</span> <span class="token attr-value">\
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ol start="4">
<li><p>安装docker</p>
<p>​    <code>Docker</code> 软件包已经包括在默认的 <code>CentOS-Extras</code> 软件源里。因此想要安装 <code>docker</code>，只需要运行下面的 <code>yum</code> 命令</p>
</li>
</ol>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">sudo</span> <span class="token attr-value">yum install docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​        当然在测试或开发环境中 <code>Docker</code> 官方为了简化安装流程，提供了一套便捷的安装脚本，<code>CentOS</code> 系统上可以使用这套脚本安装：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">curl</span> <span class="token attr-value">-fsSL get.docker.com -o get-docker.sh</span>
<span class="token attr-name">sh</span> <span class="token attr-value">get-docker.sh</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>​        具体可以参看 <code>docker-install</code> 的脚本：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">https</span><span class="token punctuation">:</span><span class="token attr-value">//github.com/docker/docker-install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​        执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 <code>Docker CE</code> 的 <code>Edge</code> 版本安装在系统中。</p>
<p>​        安装完成后，运行下面的命令，验证是否安装成功：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">version</span>
or
<span class="token attr-name">docker</span> <span class="token attr-value">info</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>​        返回docker的版本相关信息，证明 <code>docker</code> 安装成功</p>
<p><strong>或者</strong>通过以下命令安装：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">yum</span> <span class="token attr-value">install docker-ce docker-ce-cli containerd.io</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="5">
<li>启动并加入开机启动</li>
</ol>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">systemctl</span> <span class="token attr-value">start docker</span>
<span class="token attr-name">systemctl</span> <span class="token attr-value">enable docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ol start="6">
<li><p>Docker简单运用</p>
<p>​    我们通过最简单的 <code>image</code> 文件 <code>hello world</code>，感受一下 <code>Docker</code> 的魅力吧！</p>
<p>​    我们直接运行下面的命令，将名为 <code>hello-world</code> 的 <code>image</code> 文件从仓库抓取到本地。</p>
</li>
</ol>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">pull library/hello-world</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​        <code>docker pull images</code> 是抓取 <code>image</code> 文件， <code>library/hello-world</code> 是 <code>image</code> 文件在仓库里面的位置，其中 <code>library</code> 是 <code>image</code> 文件所在的组， <code>hello-world</code> 是 <code>image</code> 文件的名字。</p>
<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/pull%E6%93%8D%E4%BD%9C.png" alt="image-20220404214137451"></p>
<p>​        抓取成功以后，就可以在本机看到这个 <code>image</code> 文件了。</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">images</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>我们可以看到如下结果：</p>
<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="image-20220404214157935"></p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">run hello-world</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>显示如下即安装成功! </p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">[root@iZ2ze68ge5c1uwlkmnb9ixZ</span> <span class="token attr-value">zcapp]# docker run hello-world</span>

<span class="token attr-name">Unable</span> <span class="token attr-value">to find image 'hello-world:latest' locally</span>
<span class="token attr-name">latest</span><span class="token punctuation">:</span> <span class="token attr-value">Pulling from library/hello-world</span>
<span class="token attr-name">1b930d010525</span><span class="token punctuation">:</span> <span class="token attr-value">Pull complete </span>
<span class="token attr-name">Digest</span><span class="token punctuation">:</span> <span class="token attr-value">sha256:0e11c388b664df8a27a901dce21eb89f11d8292f7fca1b3e3c4321bf7897bffe</span>
<span class="token attr-name">Status</span><span class="token punctuation">:</span> <span class="token attr-value">Downloaded newer image for hello-world:latest</span>
<span class="token attr-name">Hello</span> <span class="token attr-value">from Docker!</span>
<span class="token attr-name">This</span> <span class="token attr-value">message shows that your installation appears to be working correctly。</span>
<span class="token attr-name">To</span> <span class="token attr-value">generate this message， Docker took the following steps:</span>
<span class="token attr-name"> 1.</span> <span class="token attr-value">The Docker client contacted the Docker daemon。</span>
<span class="token attr-name"> 2.</span> <span class="token attr-value">The Docker daemon pulled the "hello-world" image from the Docker Hub。</span>
    (amd64)
<span class="token attr-name"> 3.</span> <span class="token attr-value">The Docker daemon created a new container from that image which runs the</span>
<span class="token attr-name">    executable</span> <span class="token attr-value">that produces the output you are currently reading。</span>
<span class="token attr-name"> 4.</span> <span class="token attr-value">The Docker daemon streamed that output to the Docker client, which sent it</span>
<span class="token attr-name">    to</span> <span class="token attr-value">your terminal。</span>
<span class="token attr-name">To</span> <span class="token attr-value">try something more ambitious， you can run an Ubuntu container with:</span>
<span class="token attr-name"> $</span> <span class="token attr-value">docker run -it ubuntu bash</span>
<span class="token attr-name">Share</span> <span class="token attr-value">images， automate workflows, and more with a free Docker ID:</span>
<span class="token attr-name"> https</span><span class="token punctuation">:</span><span class="token attr-value">//hub.docker.com/</span>
<span class="token attr-name">For</span> <span class="token attr-value">more examples and ideas,visit:</span>
<span class="token attr-name"> https</span><span class="token punctuation">:</span><span class="token attr-value">//docs.docker.com/get-started/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="4-2-Ubuntu环境下"><a href="#4-2-Ubuntu环境下" class="headerlink" title="4.2 Ubuntu环境下"></a>4.2 Ubuntu环境下</h2><h3 id="第1步-安装Docker"><a href="#第1步-安装Docker" class="headerlink" title="第1步 - 安装Docker"></a>第1步 - 安装Docker</h3><p>官方Ubuntu存储库中提供的Docker安装包，但是可能不是最新的版本。为了确保我们获得最新版本，我们将从官方Docker存储库安装Docker。为此，我们将添加一个新的资源包，从Docker添加GPG密钥以确保下载有效，然后安装该包。</p>
<p>首先，更新现有的包列表：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">sudo</span> <span class="token attr-value">apt update</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>接下来，使用<code>apt</code>安装一些允许通过HTTPS才能使用的软件包：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">sudo</span> <span class="token attr-value">apt install apt-transport-https ca-certificates curl software-properties-common</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>然后将官方Docker存储库的GPG密钥添加到您的系统：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">curl</span> <span class="token attr-value">-fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>将Docker存储库添加到APT源：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">sudo</span> <span class="token attr-value">add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>接下来，使用新添加的repo源中的Docker包更新包数据库：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">sudo</span> <span class="token attr-value">apt update</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>确保您要从Docker repo安装而不是默认的Ubuntu repo：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">apt-cache</span> <span class="token attr-value">policy docker-ce</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>虽然Docker的版本号可能不同，但您还是会看到这样的输出：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker-ce</span><span class="token punctuation">:</span>
<span class="token attr-name">  Installed</span><span class="token punctuation">:</span> <span class="token attr-value">(none)</span>
<span class="token attr-name">  Candidate</span><span class="token punctuation">:</span> <span class="token attr-value">18.03.1~ce~3-0~ubuntu</span>
<span class="token attr-name">  Version</span> <span class="token attr-value">table:</span>
<span class="token attr-name">     18.03.1~ce~3-0~ubuntu</span> <span class="token attr-value">500</span>
<span class="token attr-name">        500</span> <span class="token attr-value">https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>复制</p>
<p>现在<code>docker-ce</code>还没有安装，用上面这个命令我们能看到安装源来自的Docker官方存储库。</p>
<p>最后，安装Docker：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">sudo</span> <span class="token attr-value">apt install docker-ce</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>现在应该安装好Docker了，检查它是否正在运行：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">sudo</span> <span class="token attr-value">systemctl status docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>输出应类似于以下内容，表明该服务处于工作状态：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">●</span> <span class="token attr-value">docker.service - Docker Application Container Engine</span>
<span class="token attr-name">   Loaded</span><span class="token punctuation">:</span> <span class="token attr-value">loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled)</span>
<span class="token attr-name">   Active</span><span class="token punctuation">:</span> <span class="token attr-value">active (running) since Thu 2018-07-05 15:08:39 UTC; 2min 55s ago</span>
<span class="token attr-name">     Docs</span><span class="token punctuation">:</span> <span class="token attr-value">https://docs.docker.com</span>
<span class="token attr-name"> Main</span> <span class="token attr-value">PID: 10096 (dockerd)</span>
<span class="token attr-name">    Tasks</span><span class="token punctuation">:</span> <span class="token attr-value">16</span>
<span class="token attr-name">   CGroup</span><span class="token punctuation">:</span> <span class="token attr-value">/system.slice/docker.service</span>
<span class="token attr-name">           ├─10096</span> <span class="token attr-value">/usr/bin/dockerd -H fd://</span>
<span class="token attr-name">           └─10113</span> <span class="token attr-value">docker-containerd --config /var/run/docker/containerd/containerd.toml</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>复制</p>
<p>Docker不仅可以为您提供Docker服务，还可以为您提供docker命令行工具或Docker客户端。我们将在本教程后面探讨如何使用docker命令。</p>
<h3 id="第2步-在不输入Sudo情况下执行Docker（可选）"><a href="#第2步-在不输入Sudo情况下执行Docker（可选）" class="headerlink" title="第2步 - 在不输入Sudo情况下执行Docker（可选）"></a>第2步 - 在不输入Sudo情况下执行Docker（可选）</h3><p>默认情况下，该<code>docker</code>命令只能由<strong>root</strong>用户或<strong>docker</strong>组中的用户运行，该用户在Docker的安装过程中自动创建。如果您尝试运行该<code>docker</code>命令而不使用<code>sudo</code>或不在<strong>docker</strong>组中中用户运行，您将看到如下输出：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span><span class="token punctuation">:</span> <span class="token attr-value">Cannot connect to the Docker daemon. Is the docker daemon running on this host?.</span>
<span class="token attr-name">See</span> <span class="token attr-value">'docker run --help'.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>复制</p>
<p>要想在在运行<code>docker</code>命令时不输入<code>sudo</code>，请将用户名添加到<code>docker</code>组中：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">sudo</span> <span class="token attr-value">usermod -aG docker ${USER}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>要应用新的组成员身份，请注销服务器并重新登录，或输入以下内容：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">su</span> <span class="token attr-value">- ${USER}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>系统将提示您输入用户密码以继续。</p>
<p>通过输入以下内容确认您的用户现已添加到<strong>docker</strong>组：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">id</span> <span class="token attr-value">-nG</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">sammy</span> <span class="token attr-value">sudo docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>如果您需要将用户添加到您未登录的<code>docker</code>组中，请使用以下方式明确声明该用户名：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">sudo</span> <span class="token attr-value">usermod -aG docker username</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>本文的其余部分假定您以<strong>docker</strong>组中的用户身份运行该<code>docker</code>命令。如果您不是这样做，请在前面添加<code>sudo</code>命令。</p>
<h3 id="第3步-使用Docker命令"><a href="#第3步-使用Docker命令" class="headerlink" title="第3步 - 使用Docker命令"></a>第3步 - 使用Docker命令</h3><p>命令使用包括传递一系列<code>docker</code>选项和命令，后跟参数。语法采用以下形式：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">[option] [command] [arguments]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>要查看所有可用的子命令，请输入：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>可用子命令的完整列表包括：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">attach</span> <span class="token attr-value">     Attach local standard input, output, and error streams to a running container</span>
<span class="token attr-name">build</span> <span class="token attr-value">      Build an image from a Dockerfile</span>
<span class="token attr-name">commit</span> <span class="token attr-value">     Create a new image from a container's changes</span>
<span class="token attr-name">cp</span> <span class="token attr-value">         Copy files/folders between a container and the local filesystem</span>
<span class="token attr-name">create</span> <span class="token attr-value">     Create a new container</span>
<span class="token attr-name">diff</span> <span class="token attr-value">       Inspect changes to files or directories on a container's filesystem</span>
<span class="token attr-name">events</span> <span class="token attr-value">     Get real time events from the server</span>
<span class="token attr-name">exec</span> <span class="token attr-value">       Run a command in a running container</span>
<span class="token attr-name">export</span> <span class="token attr-value">     Export a container's filesystem as a tar archive</span>
<span class="token attr-name">history</span> <span class="token attr-value">    Show the history of an image</span>
<span class="token attr-name">images</span> <span class="token attr-value">     List images</span>
<span class="token attr-name">import</span> <span class="token attr-value">     Import the contents from a tarball to create a filesystem image</span>
<span class="token attr-name">info</span> <span class="token attr-value">       Display system-wide information</span>
<span class="token attr-name">inspect</span> <span class="token attr-value">    Return low-level information on Docker objects</span>
<span class="token attr-name">kill</span> <span class="token attr-value">       Kill one or more running containers</span>
<span class="token attr-name">load</span> <span class="token attr-value">       Load an image from a tar archive or STDIN</span>
<span class="token attr-name">login</span> <span class="token attr-value">      Log in to a Docker registry</span>
<span class="token attr-name">logout</span> <span class="token attr-value">     Log out from a Docker registry</span>
<span class="token attr-name">logs</span> <span class="token attr-value">       Fetch the logs of a container</span>
<span class="token attr-name">pause</span> <span class="token attr-value">      Pause all processes within one or more containers</span>
<span class="token attr-name">port</span> <span class="token attr-value">       List port mappings or a specific mapping for the container</span>
<span class="token attr-name">ps</span> <span class="token attr-value">         List containers</span>
<span class="token attr-name">pull</span> <span class="token attr-value">       Pull an image or a repository from a registry</span>
<span class="token attr-name">push</span> <span class="token attr-value">       Push an image or a repository to a registry</span>
<span class="token attr-name">rename</span> <span class="token attr-value">     Rename a container</span>
<span class="token attr-name">restart</span> <span class="token attr-value">    Restart one or more containers</span>
<span class="token attr-name">rm</span> <span class="token attr-value">         Remove one or more containers</span>
<span class="token attr-name">rmi</span> <span class="token attr-value">        Remove one or more images</span>
<span class="token attr-name">run</span> <span class="token attr-value">        Run a command in a new container</span>
<span class="token attr-name">save</span> <span class="token attr-value">       Save one or more images to a tar archive (streamed to STDOUT by default)</span>
<span class="token attr-name">search</span> <span class="token attr-value">     Search the Docker Hub for images</span>
<span class="token attr-name">start</span> <span class="token attr-value">      Start one or more stopped containers</span>
<span class="token attr-name">stats</span> <span class="token attr-value">      Display a live stream of container(s) resource usage statistics</span>
<span class="token attr-name">stop</span> <span class="token attr-value">       Stop one or more running containers</span>
<span class="token attr-name">tag</span> <span class="token attr-value">        Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span>
<span class="token attr-name">top</span> <span class="token attr-value">        Display the running processes of a container</span>
<span class="token attr-name">unpause</span> <span class="token attr-value">    Unpause all processes within one or more containers</span>
<span class="token attr-name">update</span> <span class="token attr-value">     Update configuration of one or more containers</span>
<span class="token attr-name">version</span> <span class="token attr-value">    Show the Docker version information</span>
<span class="token attr-name">wait</span> <span class="token attr-value">       Block until one or more containers stop, then print their exit codes</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>复制</p>
<p>要查看特定命令，请输入：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">docker-subcommand --help</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>要查看有关Docker的系统信息，请使用：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">info</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>让我们探讨其中的一些命令。我们将从处理镜像开始。</p>
<h3 id="第4步-使用Docker镜像"><a href="#第4步-使用Docker镜像" class="headerlink" title="第4步 - 使用Docker镜像"></a>第4步 - 使用Docker镜像</h3><p>Docker容器是从Docker镜像构建的。默认情况下，Docker从<a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>中提取这些镜像，这是一个由Docker管理的Docker镜像市场，这是Docker项目背后的公司。任何人都可以在Docker Hub上托管他们的Docker镜像，所以您只需要将您的应用程序和Linux放在那边托管即可。</p>
<p>要检查您是否可以从Docker Hub访问和下载镜像，请输入：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">run hello-world</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>输出下面的内容则Docker正常工作：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">Unable</span> <span class="token attr-value">to find image 'hello-world:latest' locally</span>
<span class="token attr-name">latest</span><span class="token punctuation">:</span> <span class="token attr-value">Pulling from library/hello-world</span>
<span class="token attr-name">9bb5a5d4561a</span><span class="token punctuation">:</span> <span class="token attr-value">Pull complete</span>
<span class="token attr-name">Digest</span><span class="token punctuation">:</span> <span class="token attr-value">sha256:3e1764d0f546ceac4565547df2ac4907fe46f007ea229fd7ef2718514bcec35d</span>
<span class="token attr-name">Status</span><span class="token punctuation">:</span> <span class="token attr-value">Downloaded newer image for hello-world:latest</span>

<span class="token attr-name">Hello</span> <span class="token attr-value">from Docker!</span>
<span class="token attr-name">This</span> <span class="token attr-value">message shows that your installation appears to be working correctly.</span>
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>复制</p>
<p>Docker最初无法在本地找到<code>hello-world</code>镜像，因此它从Docker Hub下载了镜像，Docker Hub是默认存储库。下载映像后，Docker从映像创建了一个容器，并在容器中执行了应用程序，显示了该消息。</p>
<p>您可以使用<code>docker</code>带子命令的<code>search</code>命令搜索Docker Hub上可用的镜像。例如，要搜索Ubuntu映像，请输入：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">search ubuntu</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>该脚本将对Docker Hub进行抓取，并返回名称与搜索字符串匹配的所有镜像的列表。输出将类似于：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">NAME</span> <span class="token attr-value">                                                     DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span>
<span class="token attr-name">ubuntu</span> <span class="token attr-value">                                                   Ubuntu is a Debian-based Linux operating sys…   7917                [OK]</span>
<span class="token attr-name">dorowu/ubuntu-desktop-lxde-vnc</span> <span class="token attr-value">                           Ubuntu with openssh-server and NoVNC            193                                     [OK]</span>
<span class="token attr-name">rastasheep/ubuntu-sshd</span> <span class="token attr-value">                                   Dockerized SSH service, built on top of offi…   156                                     [OK]</span>
<span class="token attr-name">ansible/ubuntu14.04-ansible</span> <span class="token attr-value">                              Ubuntu 14.04 LTS with ansible                   93                                      [OK]</span>
<span class="token attr-name">ubuntu-upstart</span> <span class="token attr-value">                                           Upstart is an event-based replacement for th…   87                  [OK]</span>
<span class="token attr-name">neurodebian</span> <span class="token attr-value">                                              NeuroDebian provides neuroscience research s…   50                  [OK]</span>
<span class="token attr-name">ubuntu-debootstrap</span> <span class="token attr-value">                                       debootstrap --variant=minbase --components=m…   38                  [OK]</span>
<span class="token attr-name">1and1internet/ubuntu-16-nginx-php-phpmyadmin-mysql-5</span> <span class="token attr-value">     ubuntu-16-nginx-php-phpmyadmin-mysql-5          36                                      [OK]</span>
<span class="token attr-name">nuagebec/ubuntu</span> <span class="token attr-value">                                          Simple always updated Ubuntu docker images w…   23                                      [OK]</span>
<span class="token attr-name">tutum/ubuntu</span> <span class="token attr-value">                                             Simple Ubuntu docker images with SSH access     18</span>
<span class="token attr-name">i386/ubuntu</span> <span class="token attr-value">                                              Ubuntu is a Debian-based Linux operating sys…   13</span>
<span class="token attr-name">ppc64le/ubuntu</span> <span class="token attr-value">                                           Ubuntu is a Debian-based Linux operating sys…   12</span>
<span class="token attr-name">1and1internet/ubuntu-16-apache-php-7.0</span> <span class="token attr-value">                   ubuntu-16-apache-php-7.0                        10                                      [OK]</span>
<span class="token attr-name">1and1internet/ubuntu-16-nginx-php-phpmyadmin-mariadb-10</span> <span class="token attr-value">  ubuntu-16-nginx-php-phpmyadmin-mariadb-10       6                                       [OK]</span>
<span class="token attr-name">eclipse/ubuntu_jdk8</span> <span class="token attr-value">                                      Ubuntu, JDK8, Maven 3, git, curl, nmap, mc, …   6                                       [OK]</span>
<span class="token attr-name">codenvy/ubuntu_jdk8</span> <span class="token attr-value">                                      Ubuntu, JDK8, Maven 3, git, curl, nmap, mc, …   4                                       [OK]</span>
<span class="token attr-name">darksheer/ubuntu</span> <span class="token attr-value">                                         Base Ubuntu Image -- Updated hourly             4                                       [OK]</span>
<span class="token attr-name">1and1internet/ubuntu-16-apache</span> <span class="token attr-value">                           ubuntu-16-apache                                3                                       [OK]</span>
<span class="token attr-name">1and1internet/ubuntu-16-nginx-php-5.6-wordpress-4</span> <span class="token attr-value">        ubuntu-16-nginx-php-5.6-wordpress-4             3                                       [OK]</span>
<span class="token attr-name">1and1internet/ubuntu-16-sshd</span> <span class="token attr-value">                             ubuntu-16-sshd                                  1                                       [OK]</span>
<span class="token attr-name">pivotaldata/ubuntu</span> <span class="token attr-value">                                       A quick freshening-up of the base Ubuntu doc…   1</span>
<span class="token attr-name">1and1internet/ubuntu-16-healthcheck</span> <span class="token attr-value">                      ubuntu-16-healthcheck                           0                                       [OK]</span>
<span class="token attr-name">pivotaldata/ubuntu-gpdb-dev</span> <span class="token attr-value">                              Ubuntu images for GPDB development              0</span>
<span class="token attr-name">smartentry/ubuntu</span> <span class="token attr-value">                                        ubuntu with smartentry                          0                                       [OK]</span>
ossobv/ubuntu
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>复制</p>
<p>在<strong>OFFICIAL</strong>列中，带<strong>OK</strong>标记的表明这个镜像由公司构建和支持。其他镜像则由个人创建。确定要使用的映像后，可以使用命令<code>pull</code>将其下载到计算机。</p>
<p>执行以下<code>ubuntu</code>命令将官方映像下载到您的计算机：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">pull ubuntu</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>您将看到以下输出：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">Using</span> <span class="token attr-value">default tag: latest</span>
<span class="token attr-name">latest</span><span class="token punctuation">:</span> <span class="token attr-value">Pulling from library/ubuntu</span>
<span class="token attr-name">6b98dfc16071</span><span class="token punctuation">:</span> <span class="token attr-value">Pull complete</span>
<span class="token attr-name">4001a1209541</span><span class="token punctuation">:</span> <span class="token attr-value">Pull complete</span>
<span class="token attr-name">6319fc68c576</span><span class="token punctuation">:</span> <span class="token attr-value">Pull complete</span>
<span class="token attr-name">b24603670dc3</span><span class="token punctuation">:</span> <span class="token attr-value">Pull complete</span>
<span class="token attr-name">97f170c87c6f</span><span class="token punctuation">:</span> <span class="token attr-value">Pull complete</span>
<span class="token attr-name">Digest</span><span class="token punctuation">:</span> <span class="token attr-value">sha256:5f4bdc3467537cbbe563e80db2c3ec95d548a9145d64453b06939c4592d67b6d</span>
<span class="token attr-name">Status</span><span class="token punctuation">:</span> <span class="token attr-value">Downloaded newer image for ubuntu:latest</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>复制</p>
<p>下载映像后，可以使用子命令<code>run</code>运行容器。正如示例中那样，如果在使用子命令docker执行时未下载<code>hello-world</code>镜像，则Docker客户端将首先下载镜像，然后使用<code>run</code>运行容器。</p>
<p>要查看已下载到计算机的镜像，请输入：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">images</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>输出应类似于以下内容：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">REPOSITORY</span> <span class="token attr-value">         TAG                 IMAGE ID            CREATED             SIZE</span>
<span class="token attr-name">ubuntu</span> <span class="token attr-value">             latest              113a43faa138        4 weeks ago         81.2MB</span>
<span class="token attr-name">hello-world</span> <span class="token attr-value">        latest              e38bc07ac18e        2 months ago        1.85kB</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>复制</p>
<p>正如您将在本教程后面看到的那样，用于运行容器的镜像可以被修改并用于生成新镜像，然后可以将其上传到Docker Hub或其他Docker镜像托管网站。</p>
<p>我们来看看如何更详细地运行容器。</p>
<h3 id="第5步-运行Docker容器"><a href="#第5步-运行Docker容器" class="headerlink" title="第5步 - 运行Docker容器"></a>第5步 - 运行Docker容器</h3><p>在您在上一步中<code>hello-world</code>容器是运行并发出一个测试消息之后退出容器。容器可以比这更有用，它们可以是交互式的。毕竟，它们类似于虚拟机，只是更加有利于资源。</p>
<p>举个例子，让我们使用Ubuntu的最新镜像运行一个容器。**-i<strong>和</strong>-t**子命令的意思为您提供了对容器的交互式shell访问：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">run -it ubuntu</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>现在，您应该已经进入docker内部，在这个环境下，您的shell展现如下：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">root@d9b100f2f636</span><span class="token punctuation">:</span><span class="token attr-value">/#</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>请注意命令提示符中的容器ID。在例子中它是<code>d9b100f2f636</code>，稍后您需要该容器ID以在要删除容器时标识容器。现在您可以在容器内运行任何命令。例如，让我们更新容器内的包数据库。您不需要<code>sudo</code>命令添加前缀，因为您以<strong>root</strong>用户身份在容器内操作：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">apt</span> <span class="token attr-value">update</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>然后在其中安装任何应用程序。我们安装Node.js：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">apt</span> <span class="token attr-value">install nodejs</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>这将从官方Ubuntu存储库中安装容器中的Node.js. 安装完成后，验证是否已安装Node.js：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">node</span> <span class="token attr-value">-v</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>您将看到终端中显示的版本号：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">v8.10.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>您在容器内进行的任何更改仅适用于该容器。要退出容器，请输入<code>exit</code>退出。</p>
<p>让我们看看下一步管理我们系统上的容器。</p>
<h3 id="第6步-管理Docker容器"><a href="#第6步-管理Docker容器" class="headerlink" title="第6步 - 管理Docker容器"></a>第6步 - 管理Docker容器</h3><p>使用Docker一段时间后，您的计算机上将有许多运行和非运行容器。要查看<strong>运行的</strong>，请使用：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">ps</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>您将看到类似于以下内容的输出：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">CONTAINER</span> <span class="token attr-value">ID        IMAGE               COMMAND             CREATED             </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>在本教程中，您启动了两个容器。一个来自<code>hello-world</code>镜像，另一个来自<code>ubuntu</code>镜像。两个容器都不再运行，但它们仍然存在于您的系统上。</p>
<p>要查看所有容器的运行状态，请使用<code>docker ps</code>命令加指令<code>-a</code>运行：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">ps -a</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>您将看到类似于此的输出：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">d9b100f2f636</span> <span class="token attr-value">       ubuntu              "/bin/bash"         About an hour ago   Exited (0) 8 minutes ago                           sharp_volhard</span>
<span class="token attr-name">01c950718166</span> <span class="token attr-value">       hello-world         "/hello"            About an hour ago   Exited (0) About an hour ago                       festive_williams</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>复制</p>
<p>要查看您创建的最新容器，请使用<code>-l</code>命令：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">ps -l</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">CONTAINER</span> <span class="token attr-value">ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES</span>
<span class="token attr-name">d9b100f2f636</span> <span class="token attr-value">       ubuntu              "/bin/bash"         About an hour ago   Exited (0) 10 minutes ago                       sharp_volhard</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>复制</p>
<p>要启动已停止的容器，请使用<code>docker start</code>，后跟容器ID<code>d9b100f2f636</code>。让我们启动基于Ubuntu的容器，命令如下：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">start d9b100f2f636</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>容器将启动，您可以使用docker ps来查看其状态：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">CONTAINER</span> <span class="token attr-value">ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span>
<span class="token attr-name">d9b100f2f636</span> <span class="token attr-value">       ubuntu              "/bin/bash"         About an hour ago   Up 8 seconds                            sharp_volhard</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>复制</p>
<p>要停止正在运行的容器，请使用<code>docker stop</code>，后跟容器ID或名称<code>sharp_volhard</code>。这次，我们将使用Docker分配容器的名称，即：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">stop sharp_volhard</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>一旦您决定不再需要容器，请使用<code>docker rm</code>命令将其删除。使用该<code>docker ps -a</code>命令查找与映像<code>hello-world</code>关联的容器的容器，然后将其删除。</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">docker</span> <span class="token attr-value">rm festive_williams</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>您可以使用开关启动一个新容器并为其命名–name。您还可以使用该开关创建一个在停止时自行删除的容器–rm。有关这些选项和其他选项的更多信息，请参阅<code>docker run help</code>命令。</p>
<p>容器可以转换为可用于构建新容器的映像。让我们来看看它是如何工作的。</p>
<h3 id="步骤7-将容器中的更改提交到Docker镜像"><a href="#步骤7-将容器中的更改提交到Docker镜像" class="headerlink" title="步骤7 - 将容器中的更改提交到Docker镜像"></a>步骤7 - 将容器中的更改提交到Docker镜像</h3><p>当您启动Docker镜像时，您可以像使用虚拟机一样创建，修改和删除文件。您所做的更改仅适用于该容器。您可以启动和停止它，但是一旦使用<code>docker rm</code>命令销毁它，更改将永久丢失。本节介绍如何将容器的状态保存为新的Docker镜像。</p>
<p>在Ubuntu容器中安装Node.js后，您现在有一个运行镜像的容器，但容器与您用来创建它的镜像不同。但是您可能希望稍后重新使用此容器作为新映像。</p>
<p>然后使用以下命令将更改提交到新的Docker镜像实例。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">docker commit <span class="token operator">-</span>m <span class="token string">"What you did to the image"</span> <span class="token operator">-</span>a <span class="token string">"Author Name"</span> container_id repository<span class="token operator">/</span>new_image_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>该**-m<strong>是提交信息，可以帮助你和其他人知道你所做的修改，而</strong>-a**用于指定作者。当您启动交互式Docker会话时，这是您在本教程前面提到的那个<code>container_id</code>。除非您在Docker Hub上创建了其他repository存储库，否则通常是您的Docker Hub用户名。</p>
<p>例如，对于用户<strong>sammy</strong>，使用容器ID：d9b100f2f636 ，命令将是：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">docker commit <span class="token operator">-</span>m <span class="token string">"added Node.js"</span> <span class="token operator">-</span>a <span class="token string">"sammy"</span> d9b100f2f636 sammy<span class="token operator">/</span>ubuntu<span class="token operator">-</span>nodejs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>当你提交镜像后，新的镜像在您的计算机上本地保存。在本教程的后面，您将学习如何将映像推送到<code>Docker Hub</code>之类的Docker镜像市场，以便其他人可以访问它。</p>
<p>再次列出Docker镜像将显示旧镜像以及从中衍生的新镜像：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">docker images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>你会看到这样的输出：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">REPOSITORY</span> <span class="token attr-value">              TAG                 IMAGE ID            CREATED             SIZE</span>
<span class="token attr-name">sammy/ubuntu-nodejs</span> <span class="token attr-value">  latest              7c1f35226ca6        7 seconds ago       179MB</span>
<span class="token attr-name">ubuntu</span> <span class="token attr-value">                  latest              113a43faa138        4 weeks ago         81.2MB</span>
<span class="token attr-name">hello-world</span> <span class="token attr-value">             latest              e38bc07ac18e        2 months ago        1.85kB</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>复制</p>
<p>在此示例中，是新镜像<code>ubuntu-nodejs</code>，它是从Docker Hub的<code>ubuntu</code>现有镜像衍生的。镜像大小差异反映了所做的变化。因此，下次需要使用预先安装了NodeJS的Ubuntu运行容器时，您可以使用新映像<code>ubuntu-nodejs</code>。</p>
<p>您还可以从<code>Dockerfile</code>构建映像，这样可以在新映像中自动安装软件。但是，这超出了本教程的范围。</p>
<p>现在让我们与他人分享新镜像，以便他们可以从中创建容器。</p>
<h3 id="步骤8-将Docker镜像推送到Docker存储库"><a href="#步骤8-将Docker镜像推送到Docker存储库" class="headerlink" title="步骤8 - 将Docker镜像推送到Docker存储库"></a>步骤8 - 将Docker镜像推送到Docker存储库</h3><p>从现有映像创建新映像之后的下一个步骤是与您几个朋友分享，Docker Hub上的镜像全世界都可以访问，不过你先要安装注册Docker Hub地址才行。</p>
<p>本节介绍如何将Docker镜像推送到Docker Hub，要推送镜像，请先登录Docker Hub。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">docker login <span class="token operator">-</span>u docker<span class="token operator">-</span>registry<span class="token operator">-</span>username<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>系统将提示您使用Docker Hub密码进行<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/mfas?from=10680">身份验证</a>。然后你可以使用以下方法推送自己的镜像</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">docker push docker<span class="token operator">-</span>registry<span class="token operator">-</span>username<span class="token operator">/</span>docker<span class="token operator">-</span>image<span class="token operator">-</span>name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>要将<code>ubuntu-nodejs</code>镜像推送到<strong>sammy</strong>存储库，命令是：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">docker push sammy<span class="token operator">/</span>ubuntu<span class="token operator">-</span>nodejs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>上传镜像时，该过程可能需要一些时间才能完成，完成后，输出将如下所示：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">The</span> <span class="token attr-value">push refers to a repository [docker.io/sammy/ubuntu-nodejs]</span>
<span class="token attr-name">e3fbbfb44187</span><span class="token punctuation">:</span> <span class="token attr-value">Pushed</span>
<span class="token attr-name">5f70bf18a086</span><span class="token punctuation">:</span> <span class="token attr-value">Pushed</span>
<span class="token attr-name">a3b5c80a4eba</span><span class="token punctuation">:</span> <span class="token attr-value">Pushed</span>
<span class="token attr-name">7f18b442972b</span><span class="token punctuation">:</span> <span class="token attr-value">Pushed</span>
<span class="token attr-name">3ce512daaf78</span><span class="token punctuation">:</span> <span class="token attr-value">Pushed</span>
<span class="token attr-name">7aae4540b42d</span><span class="token punctuation">:</span> <span class="token attr-value">Pushed</span>

...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>复制</p>
<p>将镜像推送到注册表后，它应该列在您帐户的控制台上，</p>
<p>如果推送尝试导致此类错误，那么您可能没有登录：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">The</span> <span class="token attr-value">push refers to a repository [docker.io/sammy/ubuntu-nodejs]</span>
<span class="token attr-name">e3fbbfb44187</span><span class="token punctuation">:</span> <span class="token attr-value">Preparing</span>
<span class="token attr-name">5f70bf18a086</span><span class="token punctuation">:</span> <span class="token attr-value">Preparing</span>
<span class="token attr-name">a3b5c80a4eba</span><span class="token punctuation">:</span> <span class="token attr-value">Preparing</span>
<span class="token attr-name">7f18b442972b</span><span class="token punctuation">:</span> <span class="token attr-value">Preparing</span>
<span class="token attr-name">3ce512daaf78</span><span class="token punctuation">:</span> <span class="token attr-value">Preparing</span>
<span class="token attr-name">7aae4540b42d</span><span class="token punctuation">:</span> <span class="token attr-value">Waiting</span>
<span class="token attr-name">unauthorized</span><span class="token punctuation">:</span> <span class="token attr-value">authentication required</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>复制</p>
<p>登录docker login并尝试重复推送。然后验证是否存在于Docker Hub存储库页面上。</p>
<p>您现在可以使用<code>docker pull sammy/ubuntu-node&lt;^&gt;</code>将镜像拉取到新计算机并使用它来运行新容器。</p>
<h1 id="第五章-docker初体验"><a href="#第五章-docker初体验" class="headerlink" title="第五章 docker初体验"></a>第五章 docker初体验</h1><h2 id="5-1-docker基本命令"><a href="#5-1-docker基本命令" class="headerlink" title="5.1 docker基本命令"></a>5.1 docker基本命令</h2><h3 id="5-1-1-创建容器"><a href="#5-1-1-创建容器" class="headerlink" title="5.1.1 创建容器"></a>5.1.1 创建容器</h3><p><code>docker create </code>命令通过镜像去创建一个容器，同时吐出容器 id。</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">&gt;</span> <span class="token attr-value">docker create --name ubuntuContainer ubuntu:18.04</span>

0da83bc6515ea1df100c32cccaddc070199b72263663437b8fe424aadccf4778<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>用 <code>docker start</code>即可运行改容器。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> <span class="token function">docker</span> start ubuntuContainer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>用 <code>docker ps</code>即可查看运行中的 container</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">&gt;</span> <span class="token attr-value">docker ps</span>

<span class="token attr-name">CONTAINER</span> <span class="token attr-value">ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span>
<span class="token attr-name">9298a27262da</span> <span class="token attr-value">       ubuntu:18.04        "/bin/bash"         4 minutes ago       Up About a minute                       ubuntuContainer</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>用 <code>docker exec</code>即可进入该 container。</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">&gt;</span> <span class="token attr-value">docker exec -it 9298</span>

<span class="token attr-name">root@9298a27262da</span><span class="token punctuation">:</span><span class="token attr-value">/# ls</span>
<span class="token attr-name">bin</span> <span class="token attr-value"> boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span>
<span class="token attr-name">root@9298a27262da</span><span class="token punctuation">:</span><span class="token attr-value">/# exit</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<p>用 <code>docker run</code> 可以一步到位创建并运行一个容器，然后进入该容器。</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">&gt;</span> <span class="token attr-value">docker run -it --name runUbuntuContainer ubuntu:18.04 /bin/bash</span>

<span class="token attr-name">root@57cdd61d4383</span><span class="token punctuation">:</span><span class="token attr-value">/# ls</span>
<span class="token attr-name">bin</span> <span class="token attr-value"> boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span>
<span class="token attr-name">root@57cdd61d4383</span><span class="token punctuation">:</span><span class="token attr-value">/#</span>

<span class="token comment"># docker ps 可以查到已经成功运行了 runUbuntuContainer</span>
<span class="token attr-name">&gt;</span> <span class="token attr-value">docker ps</span>
<span class="token attr-name">CONTAINER</span> <span class="token attr-value">ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span>
<span class="token attr-name">57cdd61d4383</span> <span class="token attr-value">       ubuntu:18.04        "/bin/bash"         9 seconds ago       Up 8 seconds                            runUbuntuContainer</span>
<span class="token attr-name">9298a27262da</span> <span class="token attr-value">       ubuntu:18.04        "/bin/bash"         9 minutes ago       Up 6 minutes                    </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="5-1-2-查看删除镜像"><a href="#5-1-2-查看删除镜像" class="headerlink" title="5.1.2 查看删除镜像"></a>5.1.2 查看删除镜像</h3><ul>
<li><p><strong>列出镜像</strong>：<em>docker images [OPTIONS] [REPOSITORY]</em></p>
<p>-a，–all=false，显示所有镜像</p>
<p>-f，–filter=[]，显示时过滤条件</p>
<p>–no-trunc=false，指定不使用截断的形式显示数据</p>
<p>-q，–quiet=false，只显示镜像的唯一id</p>
</li>
</ul>
<img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F.png" alt="image-20220405084822992" style="zoom:80%;">

<ul>
<li><p><strong>查看镜像</strong>：<code>docker inspect [OPTIONS] CONTAINER|IMAGE [CONTAINER|IMAGE]</code></p>
<p>-f，–format=“”</p>
</li>
</ul>
<img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F2.png" alt="image-20220405084914929" style="zoom:80%;">

<ul>
<li><p><strong>删除镜像</strong>：<code>docker rmi [OPTIONS] IMAGE [IMAGE]</code></p>
<p>-f，–force=false，强制删除镜像</p>
<p>–no-prune=false，保留未打标签的父镜像</p>
</li>
<li><p><strong>虚悬镜像</strong>：既没有仓库名，也没有标签，均为\</p>
</li>
</ul>
<h3 id="5-1-3-获取推送镜像"><a href="#5-1-3-获取推送镜像" class="headerlink" title="5.1.3 获取推送镜像"></a>5.1.3 获取推送镜像</h3><ul>
<li><p><strong>查找镜像</strong>：<code>docker search [OPTIONS] TEAM</code></p>
<p>–automated=false，仅显示自动化构建的镜像</p>
<p>–no-trunc=false，不以截断的方式输出</p>
<p>–filter，添加过滤条件</p>
</li>
</ul>
<img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E6%9F%A5%E6%89%BE%E9%95%9C%E5%83%8F.png" alt="image-20220405085006406" style="zoom:80%;">



<ul>
<li><p><strong>拉取镜像</strong>：<code>docker pull [OPTIONS] NAME [:TAG]</code></p>
<p>-a，–all-tags=false，下载所有的镜像（包含所有TAG）</p>
</li>
</ul>
<img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F.png" alt="image-20220405085032856" style="zoom:100%;">

<ul>
<li><p>推送镜像：<code>docker push NAME [:TAG]</code></p>
<p>Docker允许上传我们自己构建的镜像，需要注册DockerHub的账户。也可以上传到阿里云，地址：<a target="_blank" rel="noopener" href="https://cr.console.aliyun.com/#/namespace/index">https://cr.console.aliyun.com/#/namespace/index</a></p>
</li>
</ul>
<h3 id="5-1-4-构建镜像"><a href="#5-1-4-构建镜像" class="headerlink" title="5.1.4 构建镜像"></a>5.1.4 构建镜像</h3><p>​        构建Docker镜像，可以保存对容器的修改，并且再次使用。构建镜像提供了自定义镜像的能力，以软件的形式打包并分发服务及其运行环境。Docker中提供了两种方式来构建镜像：</p>
<ul>
<li>通过容器构建：<em>docker commit</em></li>
<li>通过Dockerfile：<em>docker build</em></li>
</ul>
<p><strong>使用commit命令构建镜像</strong></p>
<p>命令：<code>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code></p>
<p>参数：  -a，–author=“”，指定镜像的作者信息</p>
<p>​             -m，–message=“”，提交信息</p>
<p>​             -p，–pause=true，commit时是否暂停容器</p>
<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F.png" alt="image-20220405085124136"></p>
<p><strong>使用Dockerfile文件构建镜像</strong></p>
<p>​        Docker允许我们利用一个类似配置文件的形式来进行构建自定义镜像，在文件中可以指定原始的镜像，自定义镜像的维护人信息，对原始镜像采取的操作以及暴露的端口等信息。比如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Sample Dockerfile</span>
FROM ubuntu:16.04
MAINTAINER wgp <span class="token string">"Kingdompin@163.com"</span>
RUN <span class="token function">apt-get</span> update
RUN <span class="token function">apt-get</span> <span class="token function">install</span> -y nginx
EXPOSE <span class="token number">80123456</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>命令：<code>docker build [OPTIONS] DockerFile_PATH | URL | -</code></p>
<p>参数：  –force-rm=false</p>
<p>​             –no-cache=false</p>
<p>​             –pull=false</p>
<p>​             -q，quite=false，构建时不输出信息</p>
<p>​             –rm=true</p>
<p>​             -t，tag=“”，指定输出的镜像名称信息</p>
<p>​    <img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E7%BC%96%E8%BE%91dockerfile.png" alt="image-20220405085156138" style="zoom:80%;"></p>
<h2 id="5-2-镜像迁移"><a href="#5-2-镜像迁移" class="headerlink" title="5.2 镜像迁移"></a>5.2 镜像迁移</h2><p>​        我们制作好的镜像，一般会迁移或分享给其他需要的人。Docker提供了几种将我们的镜像迁移、分享给其他人的方式。推荐镜像迁移应该直接使用Docker Registry，无论是直接使用Docker Hub还是使用内网私有Registry都可以。使用镜像频率不高，镜像数量不多的情况下，我们可以选择以下两种方式。</p>
<h3 id="5-2-1-上传Docker-Hub"><a href="#5-2-1-上传Docker-Hub" class="headerlink" title="5.2.1 上传Docker Hub"></a>5.2.1 上传Docker Hub</h3><p>首先，需要在<a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>上申请注册一个帐号。然后我们需要创建仓库，指定仓库名称。</p>
<img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/dockerhub.png" alt="image-20220405085249992" style="zoom:80%;">

<p>在终端中登录你的Docker Hub账户，输入<code>docker login</code>，输入用户名密码即可登录成功。</p>
<img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E7%99%BB%E5%BD%95.png" alt="image-20220405085317592" style="zoom:80%;">

<p>查看需要上传的镜像，并将选择的镜像打上标签，标签名需和Docker Hub上新建的仓库名称一致，否则上传失败。给镜像打标签的命令如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> tag <span class="token operator">&lt;</span>existing-image<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>hub-user<span class="token operator">&gt;</span>/<span class="token operator">&lt;</span>repo-name<span class="token operator">&gt;</span><span class="token punctuation">[</span>:<span class="token operator">&lt;</span>tag<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其中<code>existing-image</code>代表本地待上传的镜像名加tag，后面<code>&lt;hub-user&gt;/&lt;repo-name&gt;[:&lt;tag&gt;]</code>则是为上传更改的标签名，tag不指定则为latest。</p>
<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E4%B8%8A%E4%BC%A0.png" alt="image-20220405085342292"></p>
<p>可以看到，我们重新为ubuntu:16.04的镜像打上标签，观察IMAGE ID可知，同一镜像可以拥有不同的标签名。接下来，我们利用<code>push</code>命令直接上传镜像。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> push <span class="token operator">&lt;</span>hub-user<span class="token operator">&gt;</span>/<span class="token operator">&lt;</span>repo-name<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>tag<span class="token operator">&gt;</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如图，我们已经上传成功。由于之前介绍的分层存储系统，我们这里是直接对已有的ubuntu镜像进行上传，只是重新打了标签，所以真正上传的只是变化的部分。</p>
<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E6%98%BE%E7%A4%BA.png" alt="image-20220405085403757"></p>
<img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/docker%E7%95%8C%E9%9D%A2.png" alt="image-20220405085421009" style="zoom:80%;">



<h3 id="5-2-2-导出文件互传"><a href="#5-2-2-导出文件互传" class="headerlink" title="5.2.2 导出文件互传"></a>5.2.2 导出文件互传</h3><p>Docker 还提供了 <code>docker load</code> 和 <code>docker save</code> 命令，用以将镜像保存为一个tar文件。比如这次我们将ubuntu:latest这个镜像保存为tar文件。</p>
<img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E6%96%87%E4%BB%B6%E4%BA%92%E4%BC%A0.png" alt="image-20220405085507252" style="zoom:80%;">

<p>查看本地磁盘，即可看见名为ubuntu18.04的tar包。我们可以将其拷贝给其他PC，利用load命令重新导入。</p>
<img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E6%9F%A5%E7%9C%8B%E6%9C%AC%E5%9C%B0%E7%A3%81%E7%9B%98.png" alt="image-20220405085540271" style="zoom:80%;">



<h2 id="5-3-镜像容器日志"><a href="#5-3-镜像容器日志" class="headerlink" title="5.3 镜像容器日志"></a>5.3 镜像容器日志</h2><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 1. 启动守护式容器(后台运行)</span>
<span class="token attr-name">docker</span> <span class="token attr-value">-d 容器名</span>

<span class="token comment"># 使用镜像centos:latest以后台模式启动一个容器</span>
<span class="token attr-name">docker</span> <span class="token attr-value">run -d centos</span>

<span class="token attr-name">问题：然后docker</span> <span class="token attr-value">ps -a 进行查看, 会发现容器已经退出</span>
<span class="token attr-name">很重要的要说明的一点</span><span class="token punctuation">:</span> <span class="token attr-value">Docker容器后台运行,就必须有一个前台进程.</span>
容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。

<span class="token attr-name">这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。例如service</span> <span class="token attr-value">nginx start</span>
但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用,
这样的容器后台启动后,会立即自杀因为他觉得他没事可做了.
所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行

<span class="token comment"># 2. 查看容器日志</span>
<span class="token attr-name">docker</span> <span class="token attr-value">logs -f -t --tail 容器ID</span>

<span class="token attr-name">eg</span> <span class="token punctuation">:</span><span class="token attr-value">(图1)</span>
<span class="token attr-name">docker</span> <span class="token attr-value">run -d centos /bin/sh -c "while true;do echo hello testLogs;sleep 2;done"</span>
<span class="token attr-name">docker</span> <span class="token attr-value">logs -tf --tail 10 02c81778b0e0</span>

<span class="token attr-name">-t</span> <span class="token attr-value">是加入时间戳</span>
<span class="token attr-name">-f</span> <span class="token attr-value">跟随最新的日志打印</span>
<span class="token attr-name">--tail</span> <span class="token attr-value">数字 显示最后多少条</span>


<span class="token comment"># 3. 查看容器内运行的进程(图2)</span>
<span class="token attr-name">docker</span> <span class="token attr-value">top 容器ID</span>

<span class="token comment"># 4. 查看容器内部细节(图3)</span>
<span class="token attr-name">docker</span> <span class="token attr-value">inspect 容器ID</span>

<span class="token comment"># 5.进入正在运行的容器并进行交互(图4)</span>
<span class="token attr-name">docker</span> <span class="token attr-value">exec -it 容器ID bashShell</span>

<span class="token comment"># 6. 重新进入容器(图5)</span>
<span class="token attr-name">docker</span> <span class="token attr-value">attach 容器ID bashShell(不写的话默认 /bin/bash下)</span>

<span class="token comment"># 比较5与6的区别</span>
<span class="token attr-name">attach</span> <span class="token attr-value">直接进入容器启动命令终端, 不会启动新的线程</span>
<span class="token attr-name">exec</span> <span class="token attr-value">是在容器中打开新的终端, 并且可以启动新的线程</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h1 id="第六章-docker运行nginx"><a href="#第六章-docker运行nginx" class="headerlink" title="第六章 docker运行nginx"></a>第六章 docker运行nginx</h1><h2 id="6-1-运行nginx镜像"><a href="#6-1-运行nginx镜像" class="headerlink" title="6.1 运行nginx镜像"></a>6.1 运行nginx镜像</h2><p>​        我们打开网易蜂巢镜像中心 <a target="_blank" rel="noopener" href="https://c.163yun.com/hub#/m/home/">https://c.163yun.com/hub#/m/home/</a></p>
<p>​        搜索nginx，可以看到有两个nginx，他们的名字和头上和图标都不一样，一个是鲸鱼，一个是两个球。</p>
<p>​        带有鲸鱼的镜像表示这个镜像是从官网的镜像中心复制过来的。这个镜像与docker的镜像是一摸一样的。我们使用此镜像。</p>
<p>点进去，会有下载地址，复制里面的地址，然后拉取镜像。</p>
<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E6%9F%A5%E8%AF%A2%E9%95%9C%E5%83%8F.png" alt="image-20220404212013378"></p>
<p>复制到系统中运行。</p>
<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F.png" alt="image-20220404212027692"></p>
<p>运行完后可以查看镜像状态</p>
<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E6%9F%A5%E7%9C%8B%E7%8A%B6%E6%80%81.png" alt="image-20220404212040199"></p>
<p>在前台运行容器命令如下，输入后容器就会运行，按ctrl+c可以终止容器的运行。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run hub.c.163.com/library/nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在后台运行容器:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d hub.c.163.com/library/nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E8%BF%90%E8%A1%8C.png" alt="image-20220404212054623"></p>
<p>查看运行的容器:</p>
<pre class="line-numbers language-undefined" data-language="undefined"><code class="language-undefined">docker ps<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="image-20220404212157070"></p>
<p>更多关于运行的命令:</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">docker run <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">help</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>因为我们在平时运行的时候需要调试容器内部的设置、查看一下日志等等。我们可以通过如下命令进入容器内部:</p>
<p>命令的大体内容:</p>
<p><img src="/2022/04/04/ctf-xue-xi/yi-ji-chu-zhi-shi/docker/docker-shi-yong-jian-jie/image-20220404212208939.png" alt="image-20220404212208939"></p>
<p>命令具体内容: </p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">docker <span class="token keyword">exec</span> <span class="token operator">-</span>it 02963d2002b bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p> -i保证我们的输入有效，即使在没有detach的情况下也能运行。</p>
<p>-t表示将分配给我们一个伪终端。我们将在伪终端输入我们的内容。</p>
<p>后面跟着的是容器的id，即我们上面用ps查询出来的id，这个id可以少写几位，它会自动识别。</p>
<p>可输入如下命令了解更多:</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">docker <span class="token keyword">exec</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">help</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>输入命令后发现我们前面的标识也变了，相当于进入了一个新的电脑。</p>
<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220404212223139.png" alt="image-20220404212223139"></p>
<p>可以查询一下nginx在什么位置</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">which</span> nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​        打开ps查看一下当前运行的进程。我这里提示没有ps命令。我从网上查了一下发现是因为当前系统没有安装这个命令，然后我安装了一下。从命令可以看出，这个nginx容器附带的系统应该是ubuntu不是centos。</p>
<p>安装ps命令:</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">apt<span class="token operator">-</span>get <span class="token keyword">update</span>
apt<span class="token operator">-</span>get install procps<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>​        利用ps命令查看进程，可以发现nginx已经在运行了。</p>
<pre class="line-numbers language-undefined" data-language="undefined"><code class="language-undefined">ps -ef<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220404212251383.png" alt="image-20220404212251383"></p>
<p>​        输入 exit即可退出返回原来的系统。 </p>
<h2 id="6-2-docker网络"><a href="#6-2-docker网络" class="headerlink" title="6.2 docker网络"></a>6.2 docker网络</h2><h3 id="6-2-1-网络介绍"><a href="#6-2-1-网络介绍" class="headerlink" title="6.2.1 网络介绍"></a>6.2.1 网络介绍</h3><p>​        上面我们只运行了nginx，并没有用浏览器进行访问，这里我们尝试用浏览器访问，但是之前我们要了解一下docker网络。</p>
<p>​        我们直到docker的隔离性，网络也是个隔离性的一部分，linux使用了命名空间来进行资源的隔离，比如pid namespace就是用来隔离进程的，mount namespace是用来隔离文件系统的，<code>network namespace</code> 是用来隔离网络的。每一个<code>network namespace</code>都提供了一个独立的网络环境，包括网卡路由iptable规则等等，都是与以其它的network space隔离的。</p>
<ol>
<li>docker容器在默认情况下，一般会分配一个独立的<code>network-namespace</code>，也就是网络类型中的Bridge模式。</li>
</ol>
<p>​        在使用Bridge时就涉及到了一个问题，既然它有独立的namesapce，这就需要一种技术使容器内的端口可以在主机上访问到，这种技术就是端口映射，docker可以指定你想把容器内的某一个端口可以在容器所在主机上的某一个端口它俩之间做一个映射，当你在访问主机上的端口时，其实就是访问容器里面的端口。</p>
<ol start="2">
<li><p>还有一种类型是Host模式，如果在启动容器的时候指定使用Host模式，那么这个容器将不会获得一个独立的network namespace，而是和主机共同使用一个，这个时候容器将不会虚拟出自己的网卡，配置出自己的ip。而是使用宿主机上的ip和端口。也就是说在docker上使用网络和在主机上使用网络是一样的。</p>
</li>
<li><p>还有一种网络类型是None。也就是没有网络，这种情况docker将不会和外界的任何东西进行通讯。</p>
</li>
</ol>
<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/docker%E7%BD%91%E7%BB%9C.png" alt="image-20220404212311135"></p>
<h3 id="6-2-2-实际访问端口"><a href="#6-2-2-实际访问端口" class="headerlink" title="6.2.2 实际访问端口"></a>6.2.2 实际访问端口</h3><p>​        刚才我们在运行nginx镜像的时候并没有指定端口映射，所以我们这里停掉nginx容器。</p>
<pre class="line-numbers language-vbnet" data-language="vbnet"><code class="language-vbnet">docker <span class="token keyword">stop</span> containerId<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220404212327583.png" alt="image-20220404212327583"></p>
<ol>
<li><code>-p</code>(小写)是开放一个容器的端口到主机上</li>
</ol>
<p>在后台运行，开放主机8080端口映射到容器的80端口上。</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">docker run -d -p 8080<span class="token punctuation">:</span>80 hub.c.163.com/library/nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>查看主机8080端口是否开启</p>
<pre class="line-numbers language-perl" data-language="perl"><code class="language-perl">netstat <span class="token operator">-</span>na <span class="token operator">|</span>grep <span class="token number">8080</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p> <img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220404212340444.png" alt="image-20220404212340444"></p>
<p>是开启的那么访问 主机ip:8080 即可访问到nginx。</p>
<ol start="2">
<li><code>-P</code>(大写)是开放容器所有的端口到主机上一个随机的端口。</li>
</ol>
<p>停掉刚才的docker服务。</p>
<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220404212356259.png" alt="image-20220404212356259"></p>
<p>使用大P</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">docker run -d -P hub.c.163.com/library/nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>可以看到随机给我的端口是32768 </p>
<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220404212411693.png" alt="image-20220404212411693"></p>
<p>然后用 ip:32768去访问即可访问到nginx。 </p>
<h1 id="第七章-docker部署第一个java-web应用"><a href="#第七章-docker部署第一个java-web应用" class="headerlink" title="第七章 docker部署第一个java web应用"></a>第七章 docker部署第一个java web应用</h1><p>​        我们还需要学习Dockerfile，它告诉docker我们怎样制作我们的镜像，我们镜像的每一步操作分别是什么，写好Dockerfile后我们使用docker build命令执行Dockerfile里面的每一件事情。最终会把Dockerfile构建出来。</p>
<p>在这里因为是做一个演示，所以我们使用了一个开源的java web应用Jpress。</p>
<h2 id="7-1-制作自己的镜像"><a href="#7-1-制作自己的镜像" class="headerlink" title="7.1 制作自己的镜像"></a>7.1 制作自己的镜像</h2><ol>
<li>从网易的镜像中心找一个tomcat的镜像</li>
</ol>
<p><code>docker pull hub.c.163.com/library/tomcat:latest</code></p>
<p>​        因为tomat镜像肯定有jdk，所以我们就不用单独再装jdk了。</p>
<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220404212425173.png" alt="image-20220404212425173"></p>
<img src="/2022/04/04/ctf-xue-xi/yi-ji-chu-zhi-shi/docker/docker-shi-yong-jian-jie/image-20220405093609418.png" alt="image-20220405093609418" style="zoom:80%;">



<p>2.编写dockerfile</p>
<p>​        我们需要建立一个dockerfile告诉docker需要做什么，这里我建立了Dockerfile，并将我们的web文件放到了和它同一个目录下。</p>
<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220404212437165.png" alt="image-20220404212437165"></p>
<p>​        首先我们的镜像是要运行在tomcat中的，所以填写 from tomcat，以tomcat为基础。maintainer是所有者的意思。因为war包是要放在webapps中的，所以我们使用copy命令复制到tomcat的webapps。</p>
<p>​        为什么webapps在local中?我们可以去下载镜像的网站查询，向下拉就好了。具体网址 : <a target="_blank" rel="noopener" href="https://c.163yun.com/hub#/m/repository/?repoId=2955">https://c.163yun.com/hub#/m/repository/?repoId=2955</a></p>
<p>​        这里说一个个人猜想，每个容器都包含一个自己的系统，所以这里的/usr/local/tomcat/webapps指的是tomcat容器中的位置，那么哪里指定是tomcat容器呢?就是在一开始的from指定的。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">from</span> hub<span class="token punctuation">.</span>c<span class="token punctuation">.</span><span class="token number">163.</span>com<span class="token operator">/</span>library<span class="token operator">/</span>tomcat
maintainer zhangchen <span class="token number">61037</span><span class="token variable">@qq.com</span>
COPY jpress<span class="token punctuation">.</span>war <span class="token operator">/</span>usr<span class="token operator">/</span><span class="token keyword">local</span><span class="token operator">/</span>tomcat<span class="token operator">/</span>webapps<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>3。构建容器</p>
<p>注意这里是<strong>有个点</strong>的，点标明是在根据当前目录构建</p>
<pre class="line-numbers language-erlang" data-language="erlang"><code class="language-erlang"><span class="token atom">docker</span> <span class="token atom">build</span> <span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220404212453512.png" alt="image-20220404212453512"></p>
<p>可以使用docker images查看镜像是否build成功</p>
<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220404212503339.png" alt="image-20220404212503339"></p>
<p>发现一个none，表明构建成功了。</p>
<p>可以重新构建给它起个名字<code> -t</code>是给镜像指定一个tag</p>
<pre class="line-numbers language-erlang" data-language="erlang"><code class="language-erlang"><span class="token atom">docker</span> <span class="token atom">build</span> <span class="token operator">-</span><span class="token atom">t</span> <span class="token atom">jpress</span><span class="token punctuation">:</span><span class="token atom">latest</span> <span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220404212522439.png" alt="image-20220404212522439"></p>
<p>更多的参数查询:</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">docker build <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">help</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="7-2-运行自己的镜像"><a href="#7-2-运行自己的镜像" class="headerlink" title="7.2 运行自己的镜像"></a>7.2 运行自己的镜像</h2><p>​        运行我们制作的镜像并指定端口</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">docker run -d -p  8080<span class="token punctuation">:</span>8080 jpress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​        访问我们的网站，发现网站已经可以正常访问了。</p>
<p>​        然后发现它要求我们安装自己的数据库，所以我们利用docker安装mysql。</p>
<p>​        在镜像中心搜索并拉取mysql</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull hub.c.163.com/library/mysql:latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​        在镜像中心查看配置，并配置root用户密码</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">docker run -d -p 3306<span class="token punctuation">:</span>3306 -e MYSQL_ROOT_PASSWORD=123456 hub.c.163.com/library/mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​         发现我们没有创建数据库，于是停止这个容器的运行，并在与剧中创建jpress数据库。</p>
<pre class="line-numbers language-vbnet" data-language="vbnet"><code class="language-vbnet">docker <span class="token keyword">stop</span> <span class="token number">4</span>be94fb2df1d3a28c1
ocker <span class="token keyword">run</span> <span class="token operator">-</span>d <span class="token operator">-</span>p <span class="token number">3306</span><span class="token punctuation">:</span><span class="token number">3306</span> <span class="token operator">-</span>e MYSQL_ROOT_PASSWORD<span class="token operator">=</span><span class="token number">123456</span> <span class="token operator">-</span>e MYSQL_DATABASE<span class="token operator">=</span>jpress hub.c.<span class="token number">163.</span><span class="token keyword">com</span><span class="token operator">/</span>library<span class="token operator">/</span>mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>​        这样我们的数据库就建立成功了。</p>
<p>​        进入网站后要输入网站信息，输入数据库地址时，注意不要输入localhost，因为我们jpress是运行在容器内的，我们会访问tomcat容器内的3306，我们应该用ifconfig查询我们本机的ip地址。我这里的内网ip是172.17.10.68</p>
<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220404212540777.png" alt="image-20220404212540777"></p>
<p><img src="/2022/04/04/ctf-xue-xi/yi-ji-chu-zhi-shi/docker/docker-shi-yong-jian-jie/image-20220404212553619.png" alt="image-20220404212553619"></p>
<p>以上都做完后，我们的网站就可以跑起来了。</p>
<p><a target="_blank" rel="noopener" href="http://59.110.164.62:8080/jpress/">http://59.110.164.62:8080/jpress/</a></p>
<h1 id="第八章-在容器中部署静态网站"><a href="#第八章-在容器中部署静态网站" class="headerlink" title="第八章 在容器中部署静态网站"></a>第八章 在容器中部署静态网站</h1><h2 id="8-1-容器的端口映射"><a href="#8-1-容器的端口映射" class="headerlink" title="8.1 容器的端口映射"></a>8.1 容器的端口映射</h2><p><strong>命令</strong>：<em>run [-P] [-p]</em></p>
<p>-P，–publish-all=true | false，大写的P表示为容器暴露的所有端口进行映射；</p>
<p>-p，–publish=[]，小写的p表示为容器指定的端口进行映射，有四种形式：</p>
<ul>
<li><em>containerPort</em>：只指定容器的端口，宿主机端口随机映射；</li>
<li><em>hostPort:containerPort</em>：同时指定容器与宿主机端口一一映射；</li>
<li><em>ip::containerPort</em>：指定ip和容器的端口；</li>
<li><em>ip:hostPort:containerPort</em>：指定ip、宿主机端口以及容器端口。</li>
</ul>
<p>例如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -p <span class="token number">80</span> -i -t ubuntu /bin/bash
<span class="token function">docker</span> run -p <span class="token number">8080</span>:80 -i -t ubuntu /bin/bash
<span class="token function">docker</span> run -p <span class="token number">0.0</span>.0.0::80 -i -t ubuntu /bin/bash
<span class="token function">docker</span> run -p <span class="token number">0.0</span>.0.0:8080:80 -i -t ubuntu /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="8-2-容器中部署Nginx服务"><a href="#8-2-容器中部署Nginx服务" class="headerlink" title="8.2 容器中部署Nginx服务"></a>8.2 容器中部署Nginx服务</h2><p>准备环境：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 1. 创建映射80端口的交互式容器</span>
<span class="token function">docker</span> run -p <span class="token number">80</span> --name web -i -t ubuntu /bin/bash
<span class="token comment"># 2. 更新源</span>
<span class="token function">apt-get</span> update
<span class="token comment"># 3. 安装Nginx</span>
<span class="token function">apt-get</span> <span class="token function">install</span> -y nginx
<span class="token comment"># 4. 安装Vim</span>
<span class="token function">apt-get</span> <span class="token function">install</span> -y vim12345678<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建静态页面：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p /var/www/html
<span class="token builtin class-name">cd</span> /var/www/html
<span class="token function">vim</span> index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220405084338338.png" alt="image-20220405084338338" style="zoom:67%;">



<p>修改Nginx配置文件:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看Nginx安装位置</span>
<span class="token function">whereis</span> nginx
<span class="token comment"># 修改配置文件</span>
<span class="token function">vim</span> /etc/nginx/sites-enabled/default<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220405084432550.png" alt="image-20220405084432550" style="zoom:67%;">



<p>运行Nginx:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 启动nginx</span>
nginx
<span class="token comment"># 查看进程</span>
<span class="token function">ps</span> -ef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220405084507071.png" alt="image-20220405084507071"></p>
<p>验证网站访问：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 退出容器</span>
Ctrl+P Ctrl+Q
<span class="token comment"># 查看容器进程</span>
<span class="token function">docker</span> <span class="token function">top</span> web
<span class="token comment"># 查看容器端口映射情况</span>
<span class="token function">docker</span> port web<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://shuyancoding.oss-cn-beijing.aliyuncs.com/image-20220405084526325.png" alt="image-20220405084526325"></p>
<p>通过宿主机地址加映射端口访问：</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">127.0.0.1<span class="token punctuation">:</span>32769<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h1 id="第九章-使用Docker搭建前端java开发环境"><a href="#第九章-使用Docker搭建前端java开发环境" class="headerlink" title="第九章 使用Docker搭建前端java开发环境"></a>第九章 使用Docker搭建前端java开发环境</h1><h2 id="9-1-搭建环境"><a href="#9-1-搭建环境" class="headerlink" title="9.1 搭建环境"></a>9.1 搭建环境</h2><p>​        下载和安装好docker之后我们就可以开始了，我们下面讲的都是java，不过其他环境同理。</p>
<h3 id="获取-Ubuntu-镜像。"><a href="#获取-Ubuntu-镜像。" class="headerlink" title="获取 Ubuntu 镜像。"></a>获取 Ubuntu 镜像。</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull ubuntu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​        完成后执行 docker images 就能看到一个刚刚更新的镜像了。</p>
<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -it ubuntu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="安装软件、配置环境变量"><a href="#安装软件、配置环境变量" class="headerlink" title="安装软件、配置环境变量"></a>安装软件、配置环境变量</h3><p>首先更新apt-get</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt-get</span> update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​        接下来就可以使用 **apt-get install ** 安装你需要的软件了，如果没有就下载安装包自行安装，同时配置好环境变量，这里就不赘述了。</p>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>​        进入tomcat目录，启动服务，在浏览器打开 0.0.0.0:8080, 如果没有错的话你会看到该服务器无法访问。这是因为我们刚才启动的服务是在docker内，如果不做一些操作的话我们是无法访问到docker内部的服务的。</p>
<p>所以，我们先退出容器</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">exit</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​        退出之后执行 docker ps -a，就能看到我们刚才的容器依然还在，可能大多刚接触docker的人都会犯这个错误，以为退出容器之后容器就销毁了，其实不然。</p>
<p>如果我们想再进入这个容器可以执行下面的命令，容器ID请复制自己的。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it 容器ID <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​        虽然容器还在运行，但是他并没有持久化，为了防止万一，在我们修改容器里面的内容之后尽快持久化。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> commit 容器ID java<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​        这个命令的意思是将我们容器持久化为一个新的镜像，名字叫java。</p>
<p>​        启动这个新建的镜像。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -it -p <span class="token number">8080</span>:8080 java<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​        注意看我们的启动命令发生了变化，多了一个 -P 这个命令的意思是将容器内的 8080 端口暴漏到宿主机上。</p>
<p>​        再次访问 0.0.0.0:8080，我们就能看到那只小花猫了，真可爱。</p>
<p>​        刚才那个容器还在占用我们的内存怎么办，干掉他。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">rm</span> 容器ID<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​        至此我们的第一步已经完成了，接下来我们就要集成我们的代码了。</p>
<h2 id="9-2-集成代码"><a href="#9-2-集成代码" class="headerlink" title="9.2 集成代码"></a>9.2 集成代码</h2><p>​        我们刚才启动的容器是一个完全的独立的黑盒子，它根本不知道我们的代码再哪里，所以我们就要使用docker的挂载卷让宿主机和容器可以共享目录。</p>
<p>不好意思，我们又要干掉刚才启动的那个容器了。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -it -v /Users/name/web:/opt/root -p <span class="token number">8080</span>:8080 java<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​        我们的启动命令又加入了新成员 -v。这个命令的意思就是将用户根目录下的 web 目录挂在到容器中 /opt/root 目录下。</p>
<p>​        进入目录后我们就能发现web目录下的文件静静的躺在里面，像是沉睡多年的玛丽苏在等待你的呼唤。</p>
<p>​        开始呼唤吧。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mvn clean <span class="token function">install</span> -U -Plocal -DskipTests<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​        一段时间过后我们就会看到打包成功的提示，将war包copy到 tomcat webapps 目录下，就能访问你的项目了。</p>
<p>​        至此我们的项目终于跑起来了，但是有几个问题。</p>
<p>​        每次都要跑这么长的命令？好麻烦。</p>
<p>​        每次改代码都要重新打包，时间很长。</p>
<p>​        启动日志怎么看？报错了怎么办？</p>
<p>​        怎么修改前端模板文件不需要重启服务？</p>
<p>​        基于这些问题，我们就需要写一个脚本来解决了。</p>
<h2 id="9-3-shell脚本"><a href="#9-3-shell脚本" class="headerlink" title="9.3 shell脚本"></a>9.3 shell脚本</h2><p>脚本将提供下面几个指令</p>
<ul>
<li><p>-y 更新maven包-编译-打包-发布-启动tomcat</p>
</li>
<li><p>-p 编译-打包-发布-启动tomcat</p>
</li>
<li><p>-r 重启tomcat</p>
</li>
<li><p>-c 重新编译java文件-发布-启动tomcat</p>
</li>
<li><p>-w 监听vm文件,默认5S同步一次</p>
</li>
<li><p>-l 查看tomcat日志</p>
</li>
<li><p>-h 帮助</p>
</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 需要变动的变量</span>
<span class="token comment">#################################################################</span>

<span class="token comment"># 环境变量,根据conf目录下选择</span>

<span class="token assign-left variable">DEV</span><span class="token operator">=</span><span class="token string">"local"</span>

<span class="token comment">#################################################################</span>

<span class="token comment"># 不需要改动的变量</span>
<span class="token comment"># war包地址</span>
<span class="token assign-left variable">WAR_URL</span><span class="token operator">=</span><span class="token string">"/opt/root/target/*.war"</span>

<span class="token comment"># tomcat 地址</span>
<span class="token assign-left variable">TOM_URL</span><span class="token operator">=</span><span class="token string">"/usr/share/tomcat7"</span>

<span class="token comment"># 项目启动地址</span>
<span class="token assign-left variable">TOM_ROOT</span><span class="token operator">=</span><span class="token string">"<span class="token variable">${TOM_URL}</span>/webapps"</span>

<span class="token comment"># 文件监听间隔，单位秒</span>
<span class="token assign-left variable">WT</span><span class="token operator">=</span><span class="token number">5</span>

<span class="token comment"># 拷贝 vm</span>
<span class="token assign-left variable">WC_VM</span><span class="token operator">=</span><span class="token string">"src/main/webapp/WEB-INF/tpl /usr/share/tomcat7/webapps/ROOT/WEB-INF/"</span>

<span class="token comment"># 拷贝class</span>
<span class="token assign-left variable">WC_JAVA</span><span class="token operator">=</span><span class="token string">"target/classes /usr/share/tomcat7/webapps/ROOT/WEB-INF/"</span>

<span class="token comment"># 通用方法</span>
<span class="token comment"># </span>

<span class="token comment"># 使用新包</span>
<span class="token keyword">function</span> <span class="token function-name function">newwar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

    <span class="token comment"># 删除旧包</span>
    <span class="token function">rm</span> -rf <span class="token variable">${TOM_ROOT}</span>/*

    <span class="token comment"># 移动war包</span>
    <span class="token function">mv</span> <span class="token variable">${WAR_URL}</span> <span class="token variable">${TOM_ROOT}</span>/ROOT.war
<span class="token punctuation">}</span>

<span class="token comment"># 重启tomcat</span>
<span class="token keyword">function</span> <span class="token function-name function">restart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment"># 关闭已启动程序</span>
    <span class="token function">killall</span> -9 java
    <span class="token comment"># 启动服务</span>
    <span class="token variable">${TOM_URL}</span>/bin/startup.sh
    <span class="token comment"># 输入启动日志</span>
    <span class="token function">tail</span> -f <span class="token variable">${TOM_URL}</span>/logs/catalina.out
<span class="token punctuation">}</span>

<span class="token comment"># 指令处理</span>
<span class="token keyword">while</span> <span class="token builtin class-name">getopts</span> <span class="token string">":yprcwlh"</span> optname
<span class="token keyword">do</span>
    <span class="token keyword">case</span> <span class="token string">"<span class="token variable">$optname</span>"</span> <span class="token keyword">in</span>
    <span class="token string">"y"</span><span class="token punctuation">)</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"更新jar包"</span>

        mvn clean <span class="token function">install</span> -U -P<span class="token variable">${DEV}</span> -DskipTests
        newwar
        restart
        <span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token string">"p"</span><span class="token punctuation">)</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"重新打包"</span>

        mvn clean package -P<span class="token variable">${DEV}</span> -DskipTests

        newwar
        restart
        <span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token string">"r"</span><span class="token punctuation">)</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"重启tomcat"</span>

        restart
        <span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token string">"c"</span><span class="token punctuation">)</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"重新编译并重启服务"</span>

        mvn clean compile -P<span class="token variable">${DEV}</span> -DskipTests
        <span class="token function">cp</span> -R <span class="token variable">${WC_JAVA}</span>
        restart
        <span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token string">"w"</span><span class="token punctuation">)</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"开始监听vm文件"</span>

        <span class="token comment"># 监听 VM</span>
        <span class="token function">watch</span> -n <span class="token variable">${WT}</span> <span class="token function">cp</span> -R <span class="token variable">${WC_VM}</span>
        <span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token string">"l"</span><span class="token punctuation">)</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"日志"</span>

        <span class="token comment"># 监听 VM</span>
        <span class="token function">tail</span> -f <span class="token variable">${TOM_URL}</span>/logs/catalina.out
        <span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token string">"h"</span><span class="token punctuation">)</span>

        <span class="token builtin class-name">echo</span> <span class="token string">" -y 更新maven包-编译-打包-发布-启动一条龙服务"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">" -p 编译打包发布启动一条龙服务"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">" -r 重启tomcat"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">" -c 重新java文件并部署重启服务"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">" -w 监听vm文件,默认5S同步一次"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">" -l 查看日志"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">" -h 帮助"</span>
        <span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token keyword">esac</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="9-4-推广到团队"><a href="#9-4-推广到团队" class="headerlink" title="9.4 推广到团队"></a>9.4 推广到团队</h2><p>​        经过上面三步，我们的工具已经建好了，但是怎么让其他人也能使用起来呢？</p>
<p>​        docker 提供了云服务，如果我们的镜像足够小就可以将镜像推送到云上供团队其他人下载运行，但是我们的镜像已经超过了1G。。。所以我们就不能使用这种方式了。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> save java -o ./java.tar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​        使用上面的命令可以将镜像持久化到本地文件 java.tar，然后通过其他手段进行传输到其他同学的机器上，我们使用AirDrop，几分钟的事情。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> load -i java.tar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​        其他同学可以通过这个命令将我们的镜像加载到他的docker中。</p>
<p>​        再将shell脚本集成到项目根目录中，就可以愉快的使用了。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Shuyan</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://shuyanCoding.github.io/2022/04/04/ctf-xue-xi/yi-ji-chu-zhi-shi/docker/docker-shi-yong-jian-jie/">http://shuyanCoding.github.io/2022/04/04/ctf-xue-xi/yi-ji-chu-zhi-shi/docker/docker-shi-yong-jian-jie/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Shuyan</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Linux/">
                                    <span class="chip bg-color">Linux</span>
                                </a>
                            
                                <a href="/tags/Docker/">
                                    <span class="chip bg-color">Docker</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">您的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/04/05/ctf-xue-xi/yi-ji-chu-zhi-shi/docker/docker-jing-xiang/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/3.jpg" class="responsive-img" alt="Docker镜像">
                        
                        <span class="card-title">Docker镜像</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-04-05
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Docker/" class="post-category">
                                    Docker
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Linux/">
                        <span class="chip bg-color">Linux</span>
                    </a>
                    
                    <a href="/tags/Docker/">
                        <span class="chip bg-color">Docker</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                本篇&nbsp;<i class="far fa-dot-circle"></i>
            </div>
            <div class="card">
                <a href="/2022/04/04/ctf-xue-xi/yi-ji-chu-zhi-shi/docker/docker-shi-yong-jian-jie/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="Docker使用简介">
                        
                        <span class="card-title">Docker使用简介</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-04-04
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Linux/" class="post-category">
                                    Linux
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Linux/">
                        <span class="chip bg-color">Linux</span>
                    </a>
                    
                    <a href="/tags/Docker/">
                        <span class="chip bg-color">Docker</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE' || selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: Shuyan<br />'
            + '文章作者: Shuyan<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023</span>
            
            <a href="/about" target="_blank">Shuyan</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/shuyanCoding" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:24371197969@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2437197969" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2437197969" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://weibo.com/u/7836229572" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/7836229572" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://www.zhihu.com/people/jiu-ye-wei-yang-81" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/jiu-ye-wei-yang-81" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/snow.js"><\/script>');
            }
        </script>
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
